\documentclass[11pt,twoside,a4paper]{book}
%\usepackage[portuguese,brazilian]{babel}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{latexsym}

\usepackage[brazil,brazilian]{babel}
%\usepackage[latin1]{inputenc}
\usepackage[pdftex]{graphicx}           
\usepackage{setspace}                   
\usepackage{indentfirst}                
\usepackage{makeidx}                  
\usepackage[nottoc]{tocbibind}     
\usepackage{courier}                    
\usepackage{type1cm}              
\usepackage{listings}                   
\usepackage{titletoc}
%\usepackage[bf,small,compact]{titlesec} 
\usepackage[fixlanguage]{babelbib}
\usepackage[font=small,format=plain,labelfont=bf,up,textfont=it,up]{caption}
\usepackage[usenames,svgnames,dvipsnames]{xcolor}
\usepackage[a4paper,top=2.54cm,bottom=2.0cm,left=2.0cm,right=2.54cm]{geometry} % margens
%\usepackage[pdftex,plainpages=false,pdfpagelabels,pagebackref,colorlinks=true,citecolor=black,linkcolor=black,urlcolor=black,filecolor=black,bookmarksopen=true]{hyperref} % links em preto
\usepackage[pdftex,plainpages=false,pdfpagelabels,pagebackref,colorlinks=true,citecolor=DarkGreen,linkcolor=NavyBlue,urlcolor=DarkRed,filecolor=green,bookmarksopen=true]{hyperref} % links coloridos
\usepackage[all]{hypcap}                % soluciona o problema com o hyperref e capitulos
\usepackage[square,sort,nonamebreak,comma]{natbib}  
\fontsize{60}{62}\usefont{OT1}{cmr}{m}{n}{\selectfont}
\usepackage{fancyhdr}
\pagestyle{fancy}
\fancyhf{}
\renewcommand{\chaptermark}[1]{\markboth{\MakeUppercase{#1}}{}}
\renewcommand{\sectionmark}[1]{\markright{\MakeUppercase{#1}}{}}
\renewcommand{\headrulewidth}{0pt}
\graphicspath{{./figuras/}}             
\frenchspacing                          
\urlstyle{same}                         
\makeindex                              
\raggedbottom                           
\fontsize{60}{62}\usefont{OT1}{cmr}{m}{n}{\selectfont}
\cleardoublepage
\normalsize
% Ref: http://en.wikibooks.org/wiki/LaTeX/Packages/Listings
\lstset{ %
language=Java,                  % choose the language of the code
basicstyle=\footnotesize,       % the size of the fonts that are used for the code
numbers=left,                   % where to put the line-numbers
numberstyle=\footnotesize,      % the size of the fonts that are used for the line-numbers
stepnumber=1,                   % the step between two line-numbers. If it's 1 each line will be numbered
numbersep=5pt,                  % how far the line-numbers are from the code
showspaces=false,               % show spaces adding particular underscores
showstringspaces=false,         % underline spaces within strings
showtabs=false,                 % show tabs within strings adding particular underscores
frame=single,	                % adds a frame around the code
framerule=0.6pt,
tabsize=2,	                    % sets default tabsize to 2 spaces
captionpos=b,                   % sets the caption-position to bottom
breaklines=true,                % sets automatic line breaking
breakatwhitespace=false,        % sets if automatic breaks should only happen at whitespace
escapeinside={\%*}{*)},         % if you want to add a comment within your code
backgroundcolor=\color[rgb]{1.0,1.0,1.0}, % choose the background color.
rulecolor=\color[rgb]{0.8,0.8,0.8},
extendedchars=true,
xleftmargin=10pt,
xrightmargin=10pt,
framexleftmargin=10pt,
framexrightmargin=10pt
}

%----------------------------------------------
%\title{Uma infraestrutura para o desenvolvimento de aplicações distribuídas baseada em minitransações}
%\author{Leandro Ferro Luzia}
%\date{2012}
%-----------------------------------------------

% Corpo do texto
\begin{document}
\frontmatter 
\fancyhead[RO]{{\footnotesize\rightmark}\hspace{2em}\thepage}
\setcounter{tocdepth}{2}
\fancyhead[LE]{\thepage\hspace{2em}\footnotesize{\leftmark}}
\fancyhead[RE,LO]{}
\fancyhead[RO]{{\footnotesize\rightmark}\hspace{2em}\thepage}

\onehalfspacing

% ---------------------------------------------------------------------------- %
% CAPA
% Nota: O título para as dissertações/teses do IME-USP devem caber em um 
% orifício de 10,7cm de largura x 6,0cm de altura que há na capa fornecida pela SPG.
\thispagestyle{empty}
\begin{center}
    \vspace*{2.3cm}
    \textbf{\Large{Uma infraestrutura para desenvolvimento de aplicações distribuídas baseada em minitransações}}\\
    
    \vspace*{1.2cm}
    \Large{Leandro Ferro Luzia}
    
    \vskip 2cm
    \textsc{
    Dissertação apresentada\\[-0.25cm] 
    ao\\[-0.25cm]
    Instituto de Matemática e Estatística\\[-0.25cm]
    da\\[-0.25cm]
    Universidade de São Paulo\\[-0.25cm]
    para\\[-0.25cm]
    obtenção do título\\[-0.25cm]
    de\\[-0.25cm]
    Mestre em Ciências}
    
    \vskip 1.5cm
    Programa: Ciências da Computação\\
    Orientador: Prof. Dr. Francisco C. R. Reverbel
    \vskip 1cm
    
    \vskip 0.5cm
    \normalsize{São Paulo, Abril de 2012}
\end{center}

% ---------------------------------------------------------------------------- %
% Página de rosto (SÓ PARA A VERSÃO DEPOSITADA - ANTES DA DEFESA)
% Resolução CoPGr 5890 (20/12/2010)
\newpage
\thispagestyle{empty}
    \begin{center}
        \vspace*{2.3 cm}
        \textbf{\Large{Uma infraestrutura para desenvolvimento de aplicações distribuídas baseada em minitransações}}\\
        \vspace*{2 cm}
    \end{center}

    \vskip 2cm

    \begin{flushright}
	Esta é a versão original da dissertação elaborada pelo\\
	candidato Leandro Ferro Luzia, tal como \\
	submetida à Comissão Julgadora.
    \end{flushright}

\pagebreak

\pagenumbering{roman}

\chapter*{Agradecimentos}
Texto texto texto texto texto texto texto texto texto texto texto texto texto
texto texto texto texto texto texto texto texto texto texto texto texto texto
texto texto texto texto texto texto texto texto texto texto texto texto texto
texto texto texto texto. Texto opcional.

\chapter*{Resumo}

\noindent LUZIA, L. F. \textbf{Uma infraestrutura para desenvolvimento de aplicações distribuídas baseada em minitransações}. 
2012. 120 f.
Dissertação (Mestrado) - Instituto de Matemática e Estatística,
Universidade de São Paulo, São Paulo, 2012.
\\

Elemento obrigatório, constituído de uma sequência de frases concisas e
objetivas, em forma de texto.  Deve apresentar os objetivos, métodos empregados,
resultados e conclusões.  O resumo deve ser redigido em parágrafo único, conter
no máximo 500 palavras e ser seguido dos termos representativos do conteúdo do
trabalho (palavras-chave). 
Texto texto texto texto texto texto texto texto texto texto texto texto texto
texto texto texto texto texto texto texto texto texto texto texto texto texto
texto texto texto texto texto texto texto texto texto texto texto texto texto
texto texto texto texto texto texto texto texto texto texto texto texto texto
texto texto texto texto texto texto texto texto texto texto texto texto texto
texto texto texto texto texto texto texto texto.
Texto texto texto texto texto texto texto texto texto texto texto texto texto
texto texto texto texto texto texto texto texto texto texto texto texto texto
texto texto texto texto texto texto texto texto texto texto texto texto texto
texto texto texto texto texto texto texto texto texto texto texto texto texto
texto texto.
\\

\noindent \textbf{Palavras-chave:} palavra-chave1, palavra-chave2, palavra-chave3.

\chapter*{Abstract}
\noindent LUZIA, L. F. \textbf{An infrastructure for developing distributed applications based in minitransactions}. 
2010. 120 f.
Dissertação (Mestrado) - Instituto de Matemática e Estatística,
Universidade de São Paulo, São Paulo, 2012.
\\


Elemento obrigatório, elaborado com as mesmas características do resumo em
língua portuguesa. De acordo com o Regimento da Pós- Graduação da USP (Artigo
99), deve ser redigido em inglês para fins de divulgação. 
Text text text text text text text text text text text text text text text text
text text text text text text text text text text text text text text text text
text text text text text text text text text text text text text text text text
text text text text text text text text text text text text.
Text text text text text text text text text text text text text text text text
text text text text text text text text text text text text text text text text
text text text.
\\

\noindent \textbf{Keywords:} keyword1, keyword2, keyword3.

\tableofcontents

\chapter{Lista de Abreviaturas}
\begin{tabular}{ll}
	ACID		& Atomicidade, Consistência, Isolamento e Durabilidade \\
			& (\emph{Atomicity, Consistency, Isolation and Durability})\\
        SGBD	& Sistema Gerenciador de Banco de Dados\\
	2PC		& Efetivação em Duas Fases (\emph{Two-Phase Commit})\\
	TCP/IP	& Conjunto de protocolos de comunicação utilizado na Internet\\
			& (\emph{Transmition Control Protocol} e \emph{Internet Protocol})\\
\end{tabular}

\listoffigures
\listoftables

\mainmatter

% cabeçalho para as páginas de todos os capítulos
\fancyhead[RE,LO]{\thesection}

\singlespacing              % espaçamento simples

\chapter{Introdução}
\label{chap:introducao}
Há diversos motivos para construir uma aplicação de forma distribuída --- compartilhamento de recursos (permitir o acesso a recursos específicos, como impressoras) (TODO coloco essa parte dos recursos??), tolerância a falhas (adicionando mais máquinas ao sistema aumenta a chance de que, a qualquer momento, haja pelo menos uma máquina capaz de responder pelo sistema) (TODO talvez colocar referência a alguma coisa antigona no lamport) e escalabilidade (particionar e distribuir a carga de processamento do sistema permite que este suporte um número crescente de usuários e informações) (TODO ver alguma referencia para escalabilidade tb) são alguns deles.

Um sistema distribuído é composto por diversas máquinas conectadas por uma rede de comunicação \cite{tanenbaum}. Cada processador tem acesso somente ao seu próprio sistema de armazenamento (memória e disco), e a única forma de compartilharem informação é através da troca de dados pela rede de comunicação. Esta troca de dados é feita através da utilização de protocolos de comunicação, como por exemplo os protocolos da família TCP/IP (TODO colocar referência).

Implementar o compartilhamento de informações sobre o estado da aplicação utilizando a troca de dados na rede não é trivial, em especial quando os dados possuem restrições semânticas que precisam ser mantidas e garantidas como válidas. Se considerarmos o exemplo clássico de um sistema bancário em que as contas dos usuários estão distribuídas entre diversas máquinas e uma solicitação de transferência entre contas que estão em duas máquinas diferentes seja feita, é esperado que esta transferência subtraia uma certa quantia da conta de origem e adicione esta quantia na conta de destino. Se a máquina em que a conta de destino estiver falhar, a quantia subtraída da conta de origem deve ser reposta.

O problema descrito acima exige que as operações efetuadas em cada máquina --- subtrair uma quantia da conta de origem e adicionar essa quantia na conta de destino --- sejam consideradas como uma operação única em que ou as duas operações são bem sucedidas, ou nenhuma das duas irá ocorrer. Uma maneira de se garantir esta execução é através da utilização do protocolo 2PC. Este protocolo permite a coordenação da execução de operações em diversas máquinas e garante que todas as operações em todas as máquinas serão efetivadas somente se todas as máquinas concordarem com a efetivação. Ele basicamente efetua uma rodada de votação entre as máquinas para verificar a possibilidade da efetivação das operações, e uma rodada de notificação, em que as máquinas são notificadas do resultado da votação. As rodadas de votação e notificação ocorrem após a execução das operações, gerando mais mensagens na rede.

As minitransações são baseadas no protocolo 2PC --- há duas rodadas de mensagens, porém as operações para serem executadas são embutidas na própria mensagem da rodada de votação. Na primeira rodada, equivalente à votação do 2PC, as mensagens possuem basicamente três tipos de operações: comparação, leitura e escrita. A operação de comparação é essencial para as minitransações, uma vez que elas determinam o voto da máquina em relação à efetivar ou não. Caso a comparação seja bem sucedida, as escritas serão efetuadas e as leituras serão retornadas como resposta, e a máquina votará para efetivar as operações. Caso contrário nenhum dado será retornado, nenhuma escrita será efetuada e a máquina votará pela não efetivação das operações, fazendo que na rodada de notificação, todas as outras máquinas não efetivem as operações.

\section{Objetivo}
\label{sec:objetivo}
A proposta deste trabalho é implementar uma infraestrutura para sistemas distribuídos que possibilite o compartilhamento de estado entre as máquinas do sistema utilizando minitransações. Ao invés de trocarem mensagens explicitamente, as máquinas verão um repositório que pode crescer de forma a acomodar grandes quantidades de dados e que permite que todas as máquinas tenham sempre acesso a dados consistentes. Assim, esperamos que o desenvolvimento da aplicação distribuída seja mais simples e ajude o desenvolvedor a focar nas necessidades reais da aplicação.

Esta infraestrutura será composta por máquinas que formam o repositório de dados e implementam o protocolo de minitransações. O acesso a essas máquinas será feito pela rede, através da utilização de um protocolo simples da camada de aplicação TCP/IP, de forma a possibilitar que qualquer sistema que implemente o protocolo TCP/IP possa utilizar a infraestrutura.

\section{Organização do texto}
\label{sec:organizacao_do_texto}
Esta introdução apresenta o contexto de utilização das minitransações e os objetivos deste trabalho. O capítulo \ref{chap:conceitos} inicia com uma revisão sobre transações e sua utilidade. A seção \ref{sec:transacoes} trata do conceito de transações. A seção \ref{sec:transacoes_distribuidas} trata do conceito de transações distribuídas e explica em detalhes o protocolo 2PC, ponto de partida para a derivação do procolo de minitransações, que é apresentado detalhadamente na seção \ref{sec:minitransacoes}. O capítulo \ref{chap:implementacao} detalha a implementação da infraestrutura --- a linguagem utilizada, os mecanismos de controle de falhas e gerenciamento de travas. O capítulo \ref{chap:conclusoes} apresenta as conclusões em relação à utilização da infraestrutura desenvolvida.

\chapter{Conceitos}
\label{chap:conceitos}
Como as minitransações são uma extensão do protocolo 2PC, este capítulo irá apresentar uma revisão dos conceitos relacionados a transações, transações distribuídas e, por fim, uma detalhada explicação sobre as minitransações.

\section{Transações}
\label{sec:transacoes}
Uma transação, no contexto da disciplina de bancos de dados, é a unidade de execução de operações em um banco de dados \cite{garcia-molina}. Ela é composta por uma sequência de comandos de leitura e escrita de dados \cite{vaca}. Através das transações os aplicativos acessam ou modificam informações em um banco de dados, e é através da execução de transações que o gerenciador permite que diversas aplicações possam interagir de forma concorrente com o banco de dados.

Há quatro propriedades das transações que o gerenciador de banco de dados precisa garantir em um cenário de acessos concorrentes e falhas de sistema:
\begin{enumerate}
\item \emph{Atomicidade}: ou todas as operações são executadas com sucesso, ou nenhuma operação é executada. Com isso, o desenvolvedor de aplicações não precisa se preocupar com o efeito de transações incompletas, como quando ocorrem falhas do sistema. Esta propriedade é obtida através do desfazimento de operações já executadas de transações que não foram efetivadas. O gerenciador do banco de dados utiliza uma técnica em que as operações são primeiro escritas para um \emph{log}, para depois serem executadas no banco de dados propriamente dito. Caso a transação não seja efetivada, o \emph{log} é utilizado para desfazer as operações já executadas.
\item \emph{Consistência}: cada transação deve levar o banco de dados de um estado consistente para outro estado consistente. Esta propriedade depende essencialmente do desenvolvedor de aplicações --- o gerenciador de banco de dados pode auxiliar através de restrições sobre os dados que podem ser configuradas mas, no final, a semântica da consistência fica sob responsabilidade do desenvolvedor. Se retomarmos ao exemplo do sistema bancário, a transferência entre as contas não deve alterar o valor total da soma dos saldos das contas individuais envolvidas na transação.
\item \emph{Isolamento}: a execução de uma transação não pode interferir na execução de outras transações, garantindo que mesmo que as operações executadas por diferentes transações possam ser intercaladas por questões de performance ou aproveitamento de recursos o resultado final da execução das transações será equivalente ao resultado de alguma execução sequencial de todas as transações.
\item \emph{Durabilidade}: uma vez que a transação tenha sido efetivada, os efeitos de sua execução devem persistir mesmo em casos de falha. A durabilidade garante que os efeitos gerados por uma transação efetivada sejam permanentes, mesmo que ocorram falhas após a efetivação da transação. Um \emph{log} também é utilizado para a garantir a durabilidade. Uma vez que ocorra uma falha e o sistema se recupere, o gerenciador irá vasculhar o \emph{log} em busca de transações que tenham sido efetivadas mas cujos efeitos não estejam refletidos no banco de dados, para executar novamente os comandos da transação.
\end{enumerate}

Estas quatro propriedades são conhecidas como propriedades \emph{ACID} das transações.

\section{Transações distribuídas}
\label{sec:transacoes_distribuidas}
Em um ambiente distribuído, em que uma transação envolva leituras e escritas de dados contidos em diversas máquinas, esta transação será composta de subtransações executando em cada máquina envolvida. A execução coordenada destas subtransações, garantindo as propriedades \emph{ACID}, fica a cargo de um coordenador. O controle de concorrência, necessário para garantir o isolamento, e a recuperação de erros, responsável por garantir a atomicidade e durabilidade precisam ser considerados com cuidado em um ambiente distribuído.

A maneira usual de efetuar controle de concorrência é através do uso de travas (\emph{locks}) nos dados acessados. Em um sistema não distribuído, o controle de alocação e liberação destas travas fica a cargo de um gerenciador de travas, um único componente que centraliza e sabe sobre todas as travas ativas no banco. Em um sistema distribuído, este gerenciamento de travas pode ser feito de três maneiras:
\begin{itemize}
\item \emph{Centralizado}: uma única máquina fica responsável por gerenciar as travas. Esta abordagem é a mais simples, porém deixa o sistema vulnerável --- se a máquina escolhida para o gerenciamento de travas falhar, o sistema ficará indisponível.
\item \emph{Cópia primária}: Em caso de dados replicados, uma das réplicas é escolhida como a cópia primária. Todas as requisições para obtenção e liberação de travas para acessar um dados devem ser enviadas para a máquina que armazena a cópia primária. Dessa forma, é elimina a dependência de um controlador central, mas as leituras de dados em geral passam a causar a comunicação entre a máquina em que a cópia esta sendo lida e a máquina em que a cópia primária de encontra.
\item \emph{Totalmente distribuído}: As requisções de trava de uma cópia são manipuladas pelo gerenciador de travas da máquina em que a cópia esta armazenada. Com esta abordagem é eliminada a necessidade de comunicação entre máquinas durante as leituras de dados mas, durante as escritas, todas as máquinas que contém uma cópia do dado sendo escrito precisarão também efetuar uma trava no dado.
\end{itemize}

A recuperação de falhas em um ambiente distribuído é mais complicado do que em um ambiente centralizado pois, além dos novos erros que podem surgir (como falhas de comunicação ou de máquinas remotas), para efetivar a transação é necessário que todas as subtransações que a compõem sejam bem sucedidas ou que, caso alguma subtransação falhe, a transação seja abortada. Este controle é efetuado através do uso de um protocolo de efetivação.

O protocolo de efetivação mais usado é chamado de protocolo de efetivação de duas fases (\emph{Two-Phase Commit} --- 2PC), e ele será explicado na seção \ref{subsec:2pc}.

\subsection{Protocolo de efetivação de duas fases}
\label{subsec:2pc}
Cada máquina no ambiente distribuído mantém um \emph{log}, e as ações de uma subtransação são escritas no \emph{log} da máquina em que estiver executando. Uma das máquinas atua como coordenadora da transação, e após a execução dos comandos de leitura/escrita da transação, o coordenador inicia o protocolo de efetivação:

\begin{enumerate}
\item O coordenador envia uma mensagem, \emph{PREPARAR}, para cada máquina envolvida na transação.
\item A máquina subordinada (que executa uma subtransação), ao receber uma mensagem \emph{PREPARAR}, precisa decidir se irá efetivar a transação ou não. A esse decisão é dado o nome de voto, podendo ser \emph{SIM} ou \emph{NÃO}. A máquina subordinada primeiro registra em seu \emph{log} o seu voto, e então envia o seu voto para o coordenador.
\item O coordenador coleta todos os votos e, caso todas as subordinadas tenham votado \emph{SIM}, ele registra em seu \emph{log} a decisão de efetivar a transação. Se alguma máquina votou \emph{NÃO} ou falhou em responder, o coordenador registra em seu \emph{log} a decisão de abortar a transação. Após o registro no \emph{log}, o coordenador envia para todas as máquinas a sua decisão, podendo ser uma mensagem do tipo \emph{EFETIVAR} ou \emph{ABORTAR}.
\item Quando a máquina subordinada recebe uma mensagem de decisão, \emph{EFETIVAR} ou \emph{ABORTAR}, ela registra essa decisão em seu \emph{log}, retorna uma mensagem \emph{RECEBIDO} para o coordenador e efetua a ação adequada --- efetiva a transação ou a aborta.
\item Após o coordenador receber todas as mensagens \emph{RECEBIDO} das máquinas subordinadas, ele registra o fim da transação no \emph{log}.
\end{enumerate}

O princípio básico do protocolo é que qualquer máquina envolvida na transação pode decidir abortá-la de forma unilateral, exigindo assim unanimidade na decisão pela efetivação da transação. As mensagens enviadas durante a execução do protocolo indicam uma decisão do remetente, e para garantir que essa decisão sobreviva a falhas na máquina que enviou a mensagem, os dados do \emph{log} são forçados para uma forma de armazenamento estável, como um disco rígido, antes da mensagem ser enviada.

A transação é considerada oficialmente efetivada (ou abortada) no momento que o registro de \emph{EFETIVAR} (ou \emph{ABORTAR}) do \emph{log} do coordenador for escrito para a área de armazenamento estável da máquina. Falhas posteriores não podem mudar o resultado da decisão do coordenador resgistrado em seu \emph{log} e salvo em disco.

\section{Minitransações}
\label{sec:minitransacoes}
As minitransações podem ser vistas como uma otimização do protocolo de efetivação de duas fases descrito em \ref{subsec:2pc} em relação ao número de mensagens utilizadas. Elas constituem um mecanismo simples para ler e alterar dados em um ambiente distribuído garantindo atomicidade, consistência, isolamento e durabilidade \cite{sinfonia}. Porém, este ganho com a redução do número de mensagens utilizadas é obtido através da imposição de certas restrições em relação ao que pode ser feito com uma minitransação, diminuindo sua aplicabilidade.

Em \ref{subsec:derivando-minitransacoes} é apresentado como o protocolo 2PC pode ser usado como ponto de partida para otimizações e para a obtenção do protocolo de minitransações. \ref{subsec:estrutura-minitransacoes} ilustra a estrutura de uma mensagem de uma minitransação, e em \ref{subsec:pros-contras-minitransacoes} são apresentados os pontos negativos e positivos da utilização de minitransações.

\subsection{Otimizando o 2PC}
\label{subsec:derivando-minitransacoes}
A decisão pela efetivação ou cancelamento de uma transação distribuída depende tanto de aspectos operacionais quanto de aspectos semânticos específicos da aplicação. A falha na execução de uma subtransação em alguma máquina do ambiente inviabiliza a efetivação da transação como um todo, e por isso o coordenador é forçado a cancelar a transação. Este tipo de falha operacional não está ligada ao domínio da aplicação, mas sim ao ambiente em que esta aplicação está rodando e está, portanto, fora do controle do coordenador, que pode somente cancelar a transação e, opcionalmente, tentar executá-la novamente. Por outro lado, o aspecto semântico envolvido na decisão pela efetivação ou cancelamento da transação é específico de cada aplicação e depende, direta ou indiretamente, dos dados do sistema.

Considerando novamente o sistema bancário e a operação de transferência de uma determinada quantia entre uma conta de origem e de destino, a transferência só pode ocorrer se o saldo na conta de origem da transferência for maior ou igual à quantia a ser transferida. Esse checagem deve ser feita pela aplicação após a leitura da informação da máquina que armazena os dados da conta de origem, e a decisão pelo cancelamento ou não da transação fica subordinado à semântica dada aos dados do sistema. Isso exige que uma requisição de leitura seja feita e uma resposta seja enviada, para só então a aplicação decidir se vai efetivar e, então, iniciar a primeira fase do protocolo 2PC (votação).

Portanto, podemos ver que do ponto de vista semântico as operações que influenciam na decisão pela possível efetivação ou pelo cancelamento da transação são operações de leitura. As operações de escrita não influenciam nessa decisão, a não ser pelo ponto de vista operacional, ou seja, se ocorrer realmente um erro na operação de escrita. Assim, se tivermos uma transação cuja última ação não afete a decisão do coordenador sobre efetivar a transação, podemos embutir esta última ação na mensagem de votação da primeira fase do protocolo, economizando uma mensagem.

O aspecto semântico da transação em relação aos dados pode ser tratado nos participantes, e não somente no coordenador, caso o participante saiba como o coordenador irá utilizar o dado para fazer sua decisão sobre efetivar ou cancelar a transação. Se isso for possível, podemos então embutir também operações de leitura que influenciam a decisão do coordenador no protocolo de efetivação e fazer o participante adequar seu voto à maneira como o coordenador faria ao analisar o dado retornado.

As minitransações surgem no contexto em que todas as operações de uma subtransação podem ser embutidas dentro do protocolo de efetivação, utilizando somente as trocas de mensagens que ocorreriam no protocolo de efetivação, após a execução dos comandos. Para que isso possa ocorrer, as mensagens do protocolo 2PC precisam ser alteradas para incluir informações sobre os dados a serem comparados, como veremos na próxima seção.

\subsection{As minitransações}
\label{subsec:estrutura-minitransacoes}
Uma minitransação consiste de um conjunto de itens de comparação, de leitura e de escrita. Todos os itens possuem uma referência a qual dado deve ser utilizado, e os itens de comparação e escrita incluem também dados. Estes itens são escolhidos pelo coordenador antes da execução da minitransação, e cada participante efetua os seguintes passos para executar a minitransação recebida:

*** TODO colocar uma imagem com a estrutra da minitransação

\begin{enumerate}
\item Se o conjunto de comparação não for vazio, efetua uma comparação de igualdade entre os dados enviados e os dados armazenados referenciados pelos itens de comparação
\item Se alguma comparação acima falhar, o participante vota por cancelar a transação
\item Caso contrário, os dados referenciados pelos itens de leitura são retornados e os dados referenciados pelos itens de escrita são trocados pelos dados enviados. O participante vota então por efetivar a transação.
\end{enumerate}

As operações de uma minitransação, como apresentadas aqui, incluem o mínimo possível que permite balancear utilidade e performance. Os autores originais (\cite{sinfonia}) executam as operações utilizando como referência aos dados o equivalente a um endereço de memória, e as operações trabalham sobre intervalos de endereços. No referido trabalho, as minitransações são utilizadas como base para a construção de um sistema chamado \emph{Sinfonia} que, assim como o trabalho desenvolvido neste texto, visa facilitar o desenvolvimento de sistemas distribuídos ao oferecer ao desenvolvedor uma alternativa à implementação de protocolos de troca de mensagens na rede. Este sistema \emph{Sinfonia} é composto por um conjunto de máquina, chamados nós de memória (\emph{memory nodes}), que armazenam os dados e exportam um intervalo linear de endereços de memória. O foco de \emph{Sinfonia} é prover a base para o desenvolvimento de sistemas básicos distribuídos, como sistemas de arquivos distribuídos, gerenciadores de travas ou serviços de comunicação de grupos de computadores.

O objetivo deste trabalho é utilizar as minitransações como base para a construção de uma infraestrutura que facilite o desenvolvimento de aplicações distribuídas

\subsection{Vantagens e Desvantagens}
\label{subsec:pros-contras-minitransacoes}

\chapter{Implementação}
\label{chap:implementacao}

Este capítulo irá tratar da implementação da infraestrutura baseada em minitransações e irá apresentar dados comparativos de performance da execução desta infraestrutura.

\chapter{Conclusões}
\label{chap:conclusoes}

% cabeçalho para os apêndices
\renewcommand{\chaptermark}[1]{\markboth{\MakeUppercase{\appendixname\ \thechapter}} {\MakeUppercase{#1}} }
\fancyhead[RE,LO]{}
\appendix

%\include{apendice} 

% ---------------------------------------------------------------------------- %
\backmatter \singlespacing   % espaçamento simples
\bibliographystyle{alpha-ime}% citação bibliográfica alpha
\bibliography{bibliografia}  % associado ao arquivo: 'bibliografia.bib'

% ---------------------------------------------------------------------------- %
% Índice remissivo
%\index{TBP|see{periodicidade região codificante}}
%\index{DSP|see{processamento digital de sinais}}
%\index{STFT|see{transformada de Fourier de tempo reduzido}}
%\index{DFT|see{transformada discreta de Fourier}}
%\index{Fourier!transformada|see{transformada de Fourier}}
%\printindex   % imprime o índice remissivo no documento 

\end{document}
