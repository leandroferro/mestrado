\documentclass[11pt,twoside,a4paper]{book}
%\usepackage[portuguese,brazilian]{babel}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{latexsym}

\usepackage[brazil,brazilian]{babel}
%\usepackage[latin1]{inputenc}
\usepackage[pdftex]{graphicx}           
\usepackage{setspace}                   
\usepackage{indentfirst}                
\usepackage{makeidx}                  
\usepackage[nottoc]{tocbibind}     
\usepackage{courier}                    
\usepackage{type1cm}              
\usepackage{listings}                   
\usepackage{titletoc}
%\usepackage[bf,small,compact]{titlesec} 
\usepackage[fixlanguage]{babelbib}
\usepackage[font=small,format=plain,labelfont=bf,up,textfont=it,up]{caption}
\usepackage[usenames,svgnames,dvipsnames]{xcolor}
\usepackage[a4paper,top=2.54cm,bottom=2.0cm,left=2.0cm,right=2.54cm]{geometry} % margens
%\usepackage[pdftex,plainpages=false,pdfpagelabels,pagebackref,colorlinks=true,citecolor=black,linkcolor=black,urlcolor=black,filecolor=black,bookmarksopen=true]{hyperref} % links em preto
\usepackage[pdftex,plainpages=false,pdfpagelabels,pagebackref,colorlinks=true,citecolor=DarkGreen,linkcolor=NavyBlue,urlcolor=DarkRed,filecolor=green,bookmarksopen=true]{hyperref} % links coloridos
\usepackage[all]{hypcap}                % soluciona o problema com o hyperref e capitulos
\usepackage[square,sort,nonamebreak,comma]{natbib}  
\fontsize{60}{62}\usefont{OT1}{cmr}{m}{n}{\selectfont}
\usepackage{fancyhdr}
\pagestyle{fancy}
\fancyhf{}
\renewcommand{\chaptermark}[1]{\markboth{\MakeUppercase{#1}}{}}
\renewcommand{\sectionmark}[1]{\markright{\MakeUppercase{#1}}{}}
\renewcommand{\headrulewidth}{0pt}
\graphicspath{{./figuras/}}             
\frenchspacing                          
\urlstyle{same}                         
\makeindex                              
\raggedbottom                           
\fontsize{60}{62}\usefont{OT1}{cmr}{m}{n}{\selectfont}
\cleardoublepage
\normalsize
% Ref: http://en.wikibooks.org/wiki/LaTeX/Packages/Listings
\lstset{ %
language=Java,                  % choose the language of the code
basicstyle=\footnotesize,       % the size of the fonts that are used for the code
numbers=left,                   % where to put the line-numbers
numberstyle=\footnotesize,      % the size of the fonts that are used for the line-numbers
stepnumber=1,                   % the step between two line-numbers. If it's 1 each line will be numbered
numbersep=5pt,                  % how far the line-numbers are from the code
showspaces=false,               % show spaces adding particular underscores
showstringspaces=false,         % underline spaces within strings
showtabs=false,                 % show tabs within strings adding particular underscores
frame=single,	                % adds a frame around the code
framerule=0.6pt,
tabsize=2,	                    % sets default tabsize to 2 spaces
captionpos=b,                   % sets the caption-position to bottom
breaklines=true,                % sets automatic line breaking
breakatwhitespace=false,        % sets if automatic breaks should only happen at whitespace
escapeinside={\%*}{*)},         % if you want to add a comment within your code
backgroundcolor=\color[rgb]{1.0,1.0,1.0}, % choose the background color.
rulecolor=\color[rgb]{0.8,0.8,0.8},
extendedchars=true,
xleftmargin=10pt,
xrightmargin=10pt,
framexleftmargin=10pt,
framexrightmargin=10pt
}

%----------------------------------------------
%\title{Uma infraestrutura para o desenvolvimento de aplicações distribuídas baseada em minitransações}
%\author{Leandro Ferro Luzia}
%\date{2012}
%-----------------------------------------------

% Corpo do texto
\begin{document}
\frontmatter 
\fancyhead[RO]{{\footnotesize\rightmark}\hspace{2em}\thepage}
\setcounter{tocdepth}{2}
\fancyhead[LE]{\thepage\hspace{2em}\footnotesize{\leftmark}}
\fancyhead[RE,LO]{}
\fancyhead[RO]{{\footnotesize\rightmark}\hspace{2em}\thepage}

\onehalfspacing

% ---------------------------------------------------------------------------- %
% CAPA
% Nota: O título para as dissertações/teses do IME-USP devem caber em um 
% orifício de 10,7cm de largura x 6,0cm de altura que há na capa fornecida pela SPG.
\thispagestyle{empty}
\begin{center}
    \vspace*{2.3cm}
    \textbf{\Large{Uma infraestrutura para desenvolvimento de aplicações distribuídas baseada em minitransações}}\\
    
    \vspace*{1.2cm}
    \Large{Leandro Ferro Luzia}
    
    \vskip 2cm
    \textsc{
    Dissertação apresentada\\[-0.25cm] 
    ao\\[-0.25cm]
    Instituto de Matemática e Estatística\\[-0.25cm]
    da\\[-0.25cm]
    Universidade de São Paulo\\[-0.25cm]
    para\\[-0.25cm]
    obtenção do título\\[-0.25cm]
    de\\[-0.25cm]
    Mestre em Ciências}
    
    \vskip 1.5cm
    Programa: Ciências da Computação\\
    Orientador: Prof. Dr. Francisco C. R. Reverbel
    \vskip 1cm
    
    \vskip 0.5cm
    \normalsize{São Paulo, Abril de 2012}
\end{center}

% ---------------------------------------------------------------------------- %
% Página de rosto (SÓ PARA A VERSÃO DEPOSITADA - ANTES DA DEFESA)
% Resolução CoPGr 5890 (20/12/2010)
\newpage
\thispagestyle{empty}
    \begin{center}
        \vspace*{2.3 cm}
        \textbf{\Large{Uma infraestrutura para desenvolvimento de aplicações distribuídas baseada em minitransações}}\\
        \vspace*{2 cm}
    \end{center}

    \vskip 2cm

    \begin{flushright}
	Esta é a versão original da dissertação elaborada pelo\\
	candidato Leandro Ferro Luzia, tal como \\
	submetida à Comissão Julgadora.
    \end{flushright}

\pagebreak

\pagenumbering{roman}

\chapter*{Agradecimentos}
Texto texto texto texto texto texto texto texto texto texto texto texto texto
texto texto texto texto texto texto texto texto texto texto texto texto texto
texto texto texto texto texto texto texto texto texto texto texto texto texto
texto texto texto texto. Texto opcional.

\chapter*{Resumo}

\noindent LUZIA, L. F. \textbf{Uma infraestrutura para desenvolvimento de aplicações distribuídas baseada em minitransações}. 
2012. 120 f.
Dissertação (Mestrado) - Instituto de Matemática e Estatística,
Universidade de São Paulo, São Paulo, 2012.
\\

Elemento obrigatório, constituído de uma sequência de frases concisas e
objetivas, em forma de texto.  Deve apresentar os objetivos, métodos empregados,
resultados e conclusões.  O resumo deve ser redigido em parágrafo único, conter
no máximo 500 palavras e ser seguido dos termos representativos do conteúdo do
trabalho (palavras-chave). 
Texto texto texto texto texto texto texto texto texto texto texto texto texto
texto texto texto texto texto texto texto texto texto texto texto texto texto
texto texto texto texto texto texto texto texto texto texto texto texto texto
texto texto texto texto texto texto texto texto texto texto texto texto texto
texto texto texto texto texto texto texto texto texto texto texto texto texto
texto texto texto texto texto texto texto texto.
Texto texto texto texto texto texto texto texto texto texto texto texto texto
texto texto texto texto texto texto texto texto texto texto texto texto texto
texto texto texto texto texto texto texto texto texto texto texto texto texto
texto texto texto texto texto texto texto texto texto texto texto texto texto
texto texto.
\\

\noindent \textbf{Palavras-chave:} palavra-chave1, palavra-chave2, palavra-chave3.

\chapter*{Abstract}
\noindent LUZIA, L. F. \textbf{An infrastructure for developing distributed applications based in minitransactions}. 
2010. 120 f.
Dissertação (Mestrado) - Instituto de Matemática e Estatística,
Universidade de São Paulo, São Paulo, 2012.
\\


Elemento obrigatório, elaborado com as mesmas características do resumo em
língua portuguesa. De acordo com o Regimento da Pós- Graduação da USP (Artigo
99), deve ser redigido em inglês para fins de divulgação. 
Text text text text text text text text text text text text text text text text
text text text text text text text text text text text text text text text text
text text text text text text text text text text text text text text text text
text text text text text text text text text text text text.
Text text text text text text text text text text text text text text text text
text text text text text text text text text text text text text text text text
text text text.
\\

\noindent \textbf{Keywords:} keyword1, keyword2, keyword3.

\tableofcontents

\chapter{Lista de Abreviaturas}
\begin{tabular}{ll}
	ACID		& Atomicidade, Consistência, Isolamento e Durabilidade \\
			& (\emph{Atomicity, Consistency, Isolation and Durability})\\
        SGBD	& Sistema Gerenciador de Banco de Dados\\
	2PC		& Efetivação em Duas Fases (\emph{Two-Phase Commit})\\
	TCP/IP	& Conjunto de protocolos de comunicação utilizado na Internet\\
			& (\emph{Transmition Control Protocol} e \emph{Internet Protocol})\\
\end{tabular}

\listoffigures
\listoftables

\mainmatter

% cabeçalho para as páginas de todos os capítulos
\fancyhead[RE,LO]{\thesection}

\singlespacing              % espaçamento simples

\chapter{Introdução}
\label{chap:introducao}
Há diversos motivos para construir uma aplicação de forma distribuída --- compartilhamento de recursos (permitir o acesso a recursos específicos, como impressoras) (TODO coloco essa parte dos recursos??), tolerância a falhas (adicionando mais máquinas ao sistema aumenta a chance de que, a qualquer momento, haja pelo menos uma máquina capaz de responder pelo sistema) (TODO talvez colocar referência a alguma coisa antigona no lamport) e escalabilidade (particionar e distribuir a carga de processamento do sistema permite que este suporte um número crescente de usuários e informações) (TODO ver alguma referencia para escalabilidade tb) são alguns deles.

Um sistema distribuído é composto por diversas máquinas conectadas por uma rede de comunicação \cite{tanenbaum}. Cada processador tem acesso somente ao seu próprio sistema de armazenamento (memória e disco), e a única forma de compartilharem informação é através da troca de dados pela rede de comunicação. Esta troca de dados é feita através da utilização de protocolos de comunicação, como por exemplo os protocolos da família TCP/IP (TODO colocar referência).

Implementar o compartilhamento de informações sobre o estado da aplicação utilizando a troca de dados na rede não é trivial, em especial quando os dados possuem restrições semânticas que precisam ser mantidas e garantidas como válidas. Se considerarmos o exemplo clássico de um sistema bancário em que as contas dos usuários estão distribuídas entre diversas máquinas e uma solicitação de transferência entre contas que estão em duas máquinas diferentes seja feita, é esperado que esta transferência subtraia uma certa quantia da conta de origem e adicione esta quantia na conta de destino. Se a máquina em que a conta de destino estiver falhar, a quantia subtraída da conta de origem deve ser reposta.

O problema descrito acima exige que as operações efetuadas em cada máquina --- subtrair uma quantia da conta de origem e adicionar essa quantia na conta de destino --- sejam consideradas como uma operação única em que ou as duas operações são bem sucedidas, ou nenhuma das duas irá ocorrer. Uma maneira de se garantir esta execução é através da utilização do protocolo 2PC. Este protocolo permite a coordenação da execução de operações em diversas máquinas e garante que todas as operações em todas as máquinas serão efetivadas somente se todas as máquinas concordarem com a efetivação. Ele basicamente efetua uma rodada de votação entre as máquinas para verificar a possibilidade da efetivação das operações, e uma rodada de notificação, em que as máquinas são notificadas do resultado da votação. As rodadas de votação e notificação ocorrem após a execução das operações, gerando mais mensagens na rede.

As minitransações são baseadas no protocolo 2PC --- há duas rodadas de mensagens, porém as operações para serem executadas são embutidas na própria mensagem da rodada de votação. Na primeira rodada, equivalente à votação do 2PC, as mensagens possuem basicamente três tipos de operações: comparação, leitura e escrita. A operação de comparação é essencial para as minitransações, uma vez que elas determinam o voto da máquina em relação à efetivar ou não. Caso a comparação seja bem sucedida, as escritas serão efetuadas e as leituras serão retornadas como resposta, e a máquina votará para efetivar as operações. Caso contrário nenhum dado será retornado, nenhuma escrita será efetuada e a máquina votará pela não efetivação das operações, fazendo que na rodada de notificação, todas as outras máquinas não efetivem as operações.

\section{Objetivo}
\label{sec:objetivo}
A proposta deste trabalho é implementar uma infraestrutura para sistemas distribuídos que possibilite o compartilhamento de estado entre as máquinas do sistema utilizando minitransações. Ao invés de trocarem mensagens explicitamente, as máquinas verão um repositório que pode crescer de forma a acomodar grandes quantidades de dados e que permite que todas as máquinas tenham sempre acesso a dados consistentes. Assim, esperamos que o desenvolvimento da aplicação distribuída seja mais simples e ajude o desenvolvedor a focar nas necessidades reais da aplicação.

Esta infraestrutura será composta por máquinas que formam o repositório de dados e implementam o protocolo de minitransações. O acesso a essas máquinas será feito pela rede, através da utilização de um protocolo simples da camada de aplicação TCP/IP, de forma a possibilitar que qualquer sistema que implemente o protocolo TCP/IP possa utilizar a infraestrutura.

\section{Organização do texto}
\label{sec:organizacao_do_texto}
Esta introdução apresenta o contexto de utilização das minitransações e os objetivos deste trabalho. O capítulo \ref{chap:conceitos} inicia com uma revisão sobre transações e sua utilidade. A seção \ref{sec:transacoes} trata do conceito de transações. A seção \ref{sec:transacoes_distribuidas} trata do conceito de transações distribuídas e explica em detalhes o protocolo 2PC, ponto de partida para a derivação do procolo de minitransações, que é apresentado detalhadamente na seção \ref{sec:minitransacoes}. O capítulo \ref{chap:implementacao} detalha a implementação da infraestrutura --- a linguagem utilizada, os mecanismos de controle de falhas e gerenciamento de travas. O capítulo \ref{chap:conclusoes} apresenta as conclusões em relação à utilização da infraestrutura desenvolvida.

\chapter{Conceitos}
\label{chap:conceitos}
Como as minitransações são uma extensão do protocolo 2PC, este capítulo irá apresentar uma revisão dos conceitos relacionados a transações, transações distribuídas e, por fim, uma detalhada explicação sobre as minitransações.

\section{Transações}
\label{sec:transacoes}
Uma transação, no contexto da disciplina de bancos de dados, é a unidade de execução de operações em um banco de dados \cite{garcia-molina}. Ela é composta por uma sequência de comandos de leitura e escrita de dados \cite{vaca}. Através das transações os aplicativos acessam ou modificam informações em um banco de dados, e é através da execução de transações que o gerenciador permite que diversas aplicações possam interagir de forma concorrente com o banco de dados.

Há quatro propriedades das transações que o gerenciador de banco de dados precisa garantir em um cenário de acessos concorrentes e falhas de sistema:
\begin{enumerate}
\item \emph{Atomicidade}: ou todas as operações são executadas com sucesso, ou nenhuma operação é executada. Com isso, o desenvolvedor de aplicações não precisa se preocupar com o efeito de transações incompletas, como quando ocorrem falhas do sistema. Esta propriedade é obtida através do desfazimento de operações já executadas de transações que não foram efetivadas. O gerenciador do banco de dados utiliza uma técnica em que as operações são primeiro escritas para um \emph{log}, para depois serem executadas no banco de dados propriamente dito. Caso a transação não seja efetivada, o \emph{log} é utilizado para desfazer as operações já executadas.
\item \emph{Consistência}: cada transação deve levar o banco de dados de um estado consistente para outro estado consistente. Esta propriedade depende essencialmente do desenvolvedor de aplicações --- o gerenciador de banco de dados pode auxiliar através de restrições sobre os dados que podem ser configuradas mas, no final, a semântica da consistência fica sob responsabilidade do desenvolvedor. Se retomarmos ao exemplo do sistema bancário, a transferência entre as contas não deve alterar o valor total da soma dos saldos das contas individuais envolvidas na transação.
\item \emph{Isolamento}: a execução de uma transação não pode interferir na execução de outras transações, garantindo que mesmo que as operações executadas por diferentes transações possam ser intercaladas por questões de performance ou aproveitamento de recursos o resultado final da execução das transações será equivalente ao resultado de alguma execução sequencial de todas as transações.
\item \emph{Durabilidade}: uma vez que a transação tenha sido efetivada, os efeitos de sua execução devem persistir mesmo em casos de falha. A durabilidade garante que os efeitos gerados por uma transação efetivada sejam permanentes, mesmo que ocorram falhas após a efetivação da transação. Um \emph{log} também é utilizado para a garantir a durabilidade. Uma vez que ocorra uma falha e o sistema se recupere, o gerenciador irá vasculhar o \emph{log} em busca de transações que tenham sido efetivadas mas cujos efeitos não estejam refletidos no banco de dados, para executar novamente os comandos da transação.
\end{enumerate}

Estas quatro propriedades são conhecidas como propriedades \emph{ACID} das transações.

\section{Transações distribuídas}
\label{sec:transacoes_distribuidas}
Em um ambiente distribuído, em que uma transação envolva leituras e escritas de dados contidos em diversas máquinas, esta transação será composta de subtransações executando em cada máquina envolvida. A execução coordenada destas subtransações, garantindo as propriedades \emph{ACID}, fica a cargo de um coordenador. O controle de concorrência, necessário para garantir o isolamento, e a recuperação de erros, responsável por garantir a atomicidade e durabilidade precisam ser considerados com cuidado em um ambiente distribuído.

A maneira usual de efetuar controle de concorrência é através do uso de travas (\emph{locks}) nos dados acessados. Em um sistema não distribuído, o controle de alocação e liberação destas travas fica a cargo de um gerenciador de travas, um único componente que centraliza e sabe sobre todas as travas ativas no banco. Em um sistema distribuído, este gerenciamento de travas pode ser feito de três maneiras:
\begin{itemize}
\item \emph{Centralizado}: uma única máquina fica responsável por gerenciar as travas. Esta abordagem é a mais simples, porém deixa o sistema vulnerável --- se a máquina escolhida para o gerenciamento de travas falhar, o sistema ficará indisponível.
\item \emph{Cópia primária}: Em caso de dados replicados, uma das réplicas é escolhida como a cópia primária. Todas as requisições para obtenção e liberação de travas para acessar um dados devem ser enviadas para a máquina que armazena a cópia primária. Dessa forma, é elimina a dependência de um controlador central, mas as leituras de dados em geral passam a causar a comunicação entre a máquina em que a cópia esta sendo lida e a máquina em que a cópia primária de encontra.
\item \emph{Totalmente distribuído}: As requisções de trava de uma cópia são manipuladas pelo gerenciador de travas da máquina em que a cópia esta armazenada. Com esta abordagem é eliminada a necessidade de comunicação entre máquinas durante as leituras de dados mas, durante as escritas, todas as máquinas que contém uma cópia do dado sendo escrito precisarão também efetuar uma trava no dado.
\end{itemize}

A recuperação de falhas em um ambiente distribuído é mais complicado do que em um ambiente centralizado pois, além dos novos erros que podem surgir (como falhas de comunicação ou de máquinas remotas), para efetivar a transação é necessário que todas as subtransações que a compõem sejam bem sucedidas ou que, caso alguma subtransação falhe, a transação seja abortada. Este controle é efetuado através do uso de um protocolo de efetivação.

O protocolo de efetivação mais usado é chamado de protocolo de efetivação de duas fases (\emph{Two-Phase Commit} --- 2PC), e ele será explicado na seção \ref{subsec:2pc}.

\subsection{Protocolo de efetivação de duas fases}
\label{subsec:2pc}
Cada máquina no ambiente distribuído mantém um \emph{log}, e as ações de uma subtransação são escritas no \emph{log} da máquina em que estiver executando. Uma das máquinas atua como coordenadora da transação, e após a execução dos comandos de leitura/escrita da transação, o coordenador inicia o protocolo de efetivação:

\begin{enumerate}
\item O coordenador envia uma mensagem, \emph{PREPARAR}, para cada máquina envolvida na transação.
\item A máquina subordinada (que executa uma subtransação), ao receber uma mensagem \emph{PREPARAR}, precisa decidir se irá efetivar a transação ou não. A esse decisão é dado o nome de voto, podendo ser \emph{SIM} ou \emph{NÃO}. A máquina subordinada primeiro registra em seu \emph{log} o seu voto, e então envia o seu voto para o coordenador.
\item O coordenador coleta todos os votos e, caso todas as subordinadas tenham votado \emph{SIM}, ele registra em seu \emph{log} a decisão de efetivar a transação. Se alguma máquina votou \emph{NÃO} ou falhou em responder, o coordenador registra em seu \emph{log} a decisão de abortar a transação. Após o registro no \emph{log}, o coordenador envia para todas as máquinas a sua decisão, podendo ser uma mensagem do tipo \emph{EFETIVAR} ou \emph{ABORTAR}.
\item Quando a máquina subordinada recebe uma mensagem de decisão, \emph{EFETIVAR} ou \emph{ABORTAR}, ela registra essa decisão em seu \emph{log}, retorna uma mensagem \emph{RECEBIDO} para o coordenador e efetua a ação adequada --- efetiva a transação ou a aborta.
\item Após o coordenador receber todas as mensagens \emph{RECEBIDO} das máquinas subordinadas, ele registra o fim da transação no \emph{log}.
\end{enumerate}

O princípio básico do protocolo é que qualquer máquina envolvida na transação pode decidir abortá-la de forma unilateral, exigindo assim unanimidade na decisão pela efetivação da transação. As mensagens enviadas durante a execução do protocolo indicam uma decisão do remetente, e para garantir que essa decisão sobreviva a falhas na máquina que enviou a mensagem, os dados do \emph{log} são forçados para uma forma de armazenamento estável, como um disco rígido, antes da mensagem ser enviada.

A transação é considerada oficialmente efetivada (ou abortada) no momento que o registro de \emph{EFETIVAR} (ou \emph{ABORTAR}) do \emph{log} do coordenador for escrito para a área de armazenamento estável da máquina. Falhas posteriores não podem mudar o resultado da decisão do coordenador resgistrado em seu \emph{log} e salvo em disco.

*** TODO colocar imagem do fluxo de mensagens do 2PC

\section{Minitransações}
\label{sec:minitransacoes}
As minitransações podem ser vistas como uma otimização do protocolo de efetivação de duas fases descrito em \ref{subsec:2pc} em relação ao número de mensagens utilizadas. Elas constituem um mecanismo simples para ler e alterar dados em um ambiente distribuído garantindo atomicidade, consistência, isolamento e durabilidade \cite{sinfonia}. Porém, este ganho com a redução do número de mensagens utilizadas é obtido através da imposição de certas restrições em relação ao que pode ser feito com uma minitransação, diminuindo sua aplicabilidade.

Em \ref{subsec:derivando-minitransacoes} é apresentado como o protocolo 2PC pode ser usado como ponto de partida para otimizações e para a obtenção do protocolo de minitransações. \ref{subsec:estrutura-minitransacoes} ilustra a estrutura de uma minitransação, e em \ref{subsec:pros-contras-minitransacoes} são apresentados os pontos negativos e positivos da utilização de minitransações.

\subsection{Otimização do 2PC e as minitransações}
\label{subsec:derivando-minitransacoes}
A decisão pela efetivação ou cancelamento de uma transação distribuída depende tanto de aspectos operacionais quanto de aspectos semânticos específicos da aplicação. A falha na execução de uma subtransação em alguma máquina do ambiente inviabiliza a efetivação da transação como um todo, e por isso o coordenador é forçado a cancelar a transação. Este tipo de falha operacional não está ligada ao domínio da aplicação, mas sim ao ambiente em que esta aplicação está rodando e está, portanto, fora do controle do coordenador, que pode somente cancelar a transação e, opcionalmente, tentar executá-la novamente. Por outro lado, o aspecto semântico envolvido na decisão pela efetivação ou cancelamento da transação é específico de cada aplicação e depende, direta ou indiretamente, dos dados do sistema.

Considerando novamente o sistema bancário e a operação de transferência de uma determinada quantia entre uma conta de origem e de destino, a transferência só pode ocorrer se o saldo na conta de origem da transferência for maior ou igual à quantia a ser transferida. Esse checagem deve ser feita pela aplicação após a leitura da informação da máquina que armazena os dados da conta de origem, e a decisão pelo cancelamento ou não da transação fica subordinado à semântica dada aos dados do sistema. Isso exige que uma requisição de leitura seja feita e uma resposta seja enviada, para só então a aplicação decidir se vai efetivar e, então, iniciar a primeira fase do protocolo 2PC (votação).

Portanto, podemos ver que do ponto de vista semântico as operações que influenciam na decisão pela possível efetivação ou pelo cancelamento da transação são operações de leitura. As operações de escrita não influenciam nessa decisão, a não ser pelo ponto de vista operacional, ou seja, se ocorrer realmente um erro na operação de escrita. Assim, se tivermos uma transação cuja última ação não afete a decisão do coordenador sobre efetivar a transação, podemos embutir esta última ação na mensagem de votação da primeira fase do protocolo, economizando uma mensagem.

O aspecto semântico da transação em relação aos dados pode ser tratado nos participantes, e não somente no coordenador, caso o participante saiba como o coordenador irá utilizar o dado para fazer sua decisão sobre efetivar ou cancelar a transação. Se isso for possível, podemos então embutir também operações de leitura que influenciam a decisão do coordenador no protocolo de efetivação e fazer o participante adequar seu voto à maneira como o coordenador faria ao analisar o dado retornado.

As minitransações surgem no contexto em que todas as operações de uma subtransação podem ser embutidas dentro do protocolo de efetivação, utilizando somente as trocas de mensagens que ocorreriam no protocolo de efetivação, após a execução dos comandos. Para que isso possa ocorrer, as mensagens do protocolo 2PC precisam ser alteradas para incluir informações sobre os dados a serem comparados, como veremos na próxima seção.

\subsection{Estrutura e protocolo}
\label{subsec:estrutura-minitransacoes}
Uma minitransação consiste de um conjunto de itens de comparação, de leitura e de escrita. Todos os itens possuem uma referência a qual dado deve ser utilizado, e os itens de comparação e escrita incluem também dados. 

*** TODO colocar uma imagem com a estrutra da minitransação

Formalmente, uma minitransação pode ser vista como uma tupla na forma \( (T, C, L, E) \). \(T\) é o identificador da minitransação, permitindo aos participantes diferenciar e tratar minitransações simultâneas. \(C\) é o conjunto de itens de comparação, \(L\) é o conjunto de itens para leitura e \(E\) é o conjunto de itens para escrita. Os elementos de \(L\) são identificadores de dados, e o domínio de seus valores é o conjunto de identificadores armazenados na máquina participante. \(C\) e \(E\) possuem elementos que podem ser representados como tuplas no formato \((Id, Dado)\), em que \(Id\) é o identificador do dado e cujo domínio é o mesmo do identificador de leitura, e \(Dado\) é um valor, que é usado para efetuar a comparação com o identificador apresentado ou para escrever no identificador.

Para cada máquina \(P_i\) podemos definir \(T_i\) como sendo o conjunto de identificadores de dados armazenados em \(P_i\). Para executar uma transação \(I_t\) o coordenador deve primeiro identificar os participantes \(P_j\) da transação para quem as minitransações serão enviadas. Para cada \(P_j\) é construída uma minitransação \(M_j = (I_t, C_j, L_j, E_j)\), onde \(L_j, Id(C_j) \subseteq T_j\) (\(Id(X)\) indica o conjunto de identificadores \(I\) das tuplas \(X\) no formato \((I,D)\) que representam os itens de comparação e escrita da minitransação) e \(Q(E_j) \supseteq T_j \) (os dados a serem escritos são um super conjunto dos dados armazenados pois uma operação de escrita pode incluir um novo item no conjunto). A minitransação \(M_j\) é executada em \(P_j\) basicamente da seguinte maneira:

\begin{enumerate}
\item Se \(C_j \neq \emptyset\), irá comparar \(Dado(r), r \in C_j\) com \(Dado(k), k \in T_j\), onde \(Id(r) = Id(k)\).
\item Se alguma comparação acima falhar, o participante vota por cancelar a transação
\item Caso contrário, os dados referenciados por \(l \in L_j\) são retornados e os dados referenciados por \(Id(e), e \in E_j\) são trocados por \(Dado(e)\). O participante vota então por efetivar a transação.
\end{enumerate}

O coordenador aguarda a execução das minitransações por cada participante \(P_j\) e coleta seus respectivos votos \(V_j\). Se \(\exists v=ABORTAR, v \in V_j\), a transação é então cancelada, e o coordenador precisa notificar cada participante \(P_j\) que a minitransação \(M_j\) precisa ser desfeita. Caso contrário, o coordenador notifica os participantes que a minitransação \(M_j\) deve ser efetivada.

Entre a execução da minitransação e sua efetivação ou cancelamento, os dados escritos não podem ser visíveis a outras minitransações. Para garantir isso, os dados acessados pelas minitransações são travados durante a primeira fase e depois liberados na segunda fase. Para pode efetuar a recuperação de falhas é utilizado um \emph{log} no qual, durante a primeira fase, os dados escritos são escritos neste log e, na segunda fase, esses dados são passados do \emph{log} para o armazenamento real.

As operações de uma minitransação, como apresentadas aqui, incluem o mínimo possível que permite balancear utilidade e performance. Os autores originais (\cite{sinfonia}) executam as operações utilizando como referência aos dados o equivalente a um endereço de memória, e as operações trabalham sobre intervalos de endereços. No referido trabalho, as minitransações são utilizadas como base para a construção de um sistema chamado \emph{Sinfonia} que, assim como o trabalho desenvolvido neste texto, visa facilitar o desenvolvimento de sistemas distribuídos ao oferecer ao desenvolvedor uma alternativa à implementação de protocolos de troca de mensagens na rede. Este sistema \emph{Sinfonia} é composto por um conjunto de máquinas, chamadas nós de memória (\emph{memory nodes}), que armazenam os dados e exportam um intervalo linear de endereços de memória. 

O foco de \emph{Sinfonia} é prover a base para o desenvolvimento de sistemas distribuídos de baixo nível, como sistemas de arquivos distribuídos, gerenciadores de travas ou serviços de comunicação de grupos de computadores, enquanto que o objetivo deste trabalho é utilizar as minitransações como base para a construção de uma infraestrutura que facilite o desenvolvimento de aplicações distribuídas de alto nível, como sistemas de comércio eletrônico ou redes sociais. Os detalhes da implementação da infraestrutura e as semelhanças e diferenças relevantes em relação ao \emph{Sinfonia} estão descritos no capítulo \ref{chap:implementacao}.

\chapter{Implementação}
\label{chap:implementacao}

A infraestrutura será desenvolvida em \emph{Scala} \cite{scala}, uma linguagem híbrida que combina orientação a objetos com programação funcional. O código \emph{Scala} é compilado para \emph{bytecodes} \emph{Java} e pode ser executado por uma máquina virtual \emph{Java} qualquer. Dessa forma, o código pode interagir com qualquer código já disponível em \emph{Java} e pode rodar em qualquer plataforma que tenha uma máquina virtual compatível, permitindo que a infraestrutura possa ser executada em uma grande quantidade de plataformas.

Na primeira seção (\ref{sec:algoritmos}) são descritos as estruturas de dados e algoritmos utilizados para executar as minitransações e operações relacionadas, como recuperação de falhas. A seção \ref{sec:aplicacoes} irá apresentar alguns exemplos de aplicações utilizando a infraestrutura desenvolvida e a última seção, \ref{sec:testes}, irá descrever o ambiente de testes, os testes realizados e os resultados obtidos.

\section{Algoritmos e estruturas de dados}
\label{sec:algoritmos}
Nesta seção serão descritos os algoritmos e as estruturas de dados principais para a execução das minitransações, para o controle de concorrência entre minitransações e para a recuperação de falhas do sistema. Os mecanismos aqui apresentados são baseados em métodos tradicionais de bancos de dados: travas para o controle de concorrência, como em bancos de dados com abordagem \emph{pessimista}, e uso de uma estrutura de escrita intermediária (\emph{log}) para controle de falhas e atomicidade.

Supondo a execução de uma minitransação com identificador \(I_t\), há três estruturas de dados principais utilizadas pelo sistema:
\begin{itemize}
\item Tabela de dados: Para cada máquina \(P_i\) participante do sistema, o conjunto \(D_i\) representa a partição dos dados \(D\) do sistema armazenados em \(P_i\). Este conjunto \(D_i\) é representado por uma tabela associativa entre um identificador e um valor, representados por \(Id(X)\) e \(Dado(X)\), onde \(X \in D_i\). Esta tabela suporta as operações \(Leitura(X)\), que retorna \(Dado(X)\) ou um valor especial (\(NULO\)) caso \(X \notin D_i\), e \(Escrita(X, V)\), que atribui a \(Dado(X)\) o valor \(V\). 
\item Tabela de travas: Para controlar o acesso concorrente aos dados de \(D_i\), é utilizada também uma tabela associativa entre um identificador e um valor do conjunto \(\{LEITURA, ESCRITA, LIVRE\}\). Assim, para \(Id(X), X \in D_i, Trava(X) \rightarrow Y, Y \in \{LEITURA, SCRITA, LIVRE\}\). Se \(Y\) for \(LIVRE\), isso indica que o identificador não possui nenhuma trava associada, e pode ser lido ou escrito sem problemas. Se \(Y\) for \(LEITURA\), isso quer dizer que somente leituras podem ocorrer no identificador associado e escritas estão proibidas. Se \(Y\) for \(ESCRITA\) então nem leituras nem escritas podem ocorrer no identificador associado. Esta tabela suporta as operações \(TentarTravar(I_t, X, T), T \in \{LEITURA, ESCRITA\}\), que verifica se trava \(T\) pode ser associada ao identificador \(X\) pela transação \(I_t\), e \(Liberar(I_t, X)\), que retira a trava que \(I_t\) atribuiu a \(X\). \(TentarTravar\) nunca falha, e retorna um valor em \(\{TRAVOU, NAO\_TRAVOU\}\). O algoritmo para essa operação será mostrada adiante.
\item Tabela de escrita temporária: Esta tabela é estruturalmente idêntica à tabela de dados, mas seu objetivo é diferente. As escritas de um minitransação são efetuadas nesta tabela durante a execução da minitransação e, somente após o recebimento da efetivação da minitransação é que o participante irá transferir os dados escritos desta tabela de escrita temporária para a tabela de dados. Como foi descrito, esta estrutura suporta as mesmas operações que a tabela de dados.
\end{itemize}

\section{Aplicações desenvolvidas utilizando a infraestrutura}
\label{sec:aplicacoes}

\section{Execução dos testes}
\label{sec:testes}

\chapter{Conclusões}
\label{chap:conclusoes}

% cabeçalho para os apêndices
\renewcommand{\chaptermark}[1]{\markboth{\MakeUppercase{\appendixname\ \thechapter}} {\MakeUppercase{#1}} }
\fancyhead[RE,LO]{}
\appendix

%\include{apendice} 

% ---------------------------------------------------------------------------- %
\backmatter \singlespacing   % espaçamento simples
\bibliographystyle{alpha-ime}% citação bibliográfica alpha
\bibliography{bibliografia}  % associado ao arquivo: 'bibliografia.bib'

% ---------------------------------------------------------------------------- %
% Índice remissivo
%\index{TBP|see{periodicidade região codificante}}
%\index{DSP|see{processamento digital de sinais}}
%\index{STFT|see{transformada de Fourier de tempo reduzido}}
%\index{DFT|see{transformada discreta de Fourier}}
%\index{Fourier!transformada|see{transformada de Fourier}}
%\printindex   % imprime o índice remissivo no documento 

\end{document}
