\documentclass[11pt,twoside,a4paper]{book}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{latexsym}

\usepackage[brazil,brazilian]{babel}
\usepackage[pdftex]{graphicx}           
\usepackage{setspace}                   
\usepackage{indentfirst}                
\usepackage{makeidx}                  
\usepackage[nottoc]{tocbibind}     
\usepackage{courier}                    
\usepackage{type1cm}              
\usepackage{listings}                   
\usepackage{titletoc}
\usepackage{amsmath}
\usepackage[fixlanguage]{babelbib}
\usepackage[font=small,format=plain,labelfont=bf,up,textfont=it,up]{caption}
\usepackage[usenames,svgnames,dvipsnames]{xcolor}
\usepackage[a4paper,top=2.54cm,bottom=2.0cm,left=2.0cm,right=2.54cm]{geometry} % margens
\usepackage[pdftex,plainpages=false,pdfpagelabels,pagebackref,colorlinks=true,citecolor=DarkGreen,linkcolor=NavyBlue,urlcolor=DarkRed,filecolor=green,bookmarksopen=true]{hyperref} % links coloridos
\usepackage[all]{hypcap}                % soluciona o problema com o hyperref e capitulos
\usepackage[square,sort,nonamebreak,comma]{natbib}  
% \usepackage[chapter]{algorithm}
% \usepackage{algpseudocode}
\usepackage[algochapter,boxruled,linesnumbered,portuguese]{algorithm2e}
\fontsize{60}{62}\usefont{OT1}{cmr}{m}{n}{\selectfont}
\usepackage{fancyhdr}
\usepackage{multirow}
\usepackage{siunitx}
\pagestyle{fancy}
\fancyhf{}
\renewcommand{\chaptermark}[1]{\markboth{\MakeUppercase{#1}}{}}
\renewcommand{\sectionmark}[1]{\markright{\MakeUppercase{#1}}{}}
\renewcommand{\headrulewidth}{0pt}
\renewcommand*{\lstlistingname}{Listagem}
%\renewcommand*{\lstlistoflistingname}{Lista de Listagens}
\graphicspath{{imagens/}}             
\frenchspacing                          
\urlstyle{same}                         
\makeindex                              
\raggedbottom                           
\fontsize{60}{62}\usefont{OT1}{cmr}{m}{n}{\selectfont}
\cleardoublepage
\normalsize
% Ref: http://en.wikibooks.org/wiki/LaTeX/Packages/Listings
\lstset{ %
language=Java,                  % choose the language of the code
basicstyle=\footnotesize,       % the size of the fonts that are used for the code
numbers=left,                   % where to put the line-numbers
numberstyle=\footnotesize,      % the size of the fonts that are used for the line-numbers
stepnumber=1,                   % the step between two line-numbers. If it's 1 each line will be numbered
numbersep=5pt,                  % how far the line-numbers are from the code
showspaces=false,               % show spaces adding particular underscores
showstringspaces=false,         % underline spaces within strings
showtabs=false,                 % show tabs within strings adding particular underscores
frame=single,	                % adds a frame around the code
framerule=0.6pt,
tabsize=2,	                    % sets default tabsize to 2 spaces
captionpos=b,                   % sets the caption-position to bottom
breaklines=true,                % sets automatic line breaking
breakatwhitespace=false,        % sets if automatic breaks should only happen at whitespace
escapeinside={\%*}{*)},         % if you want to add a comment within your code
backgroundcolor=\color[rgb]{1.0,1.0,1.0}, % choose the background color.
rulecolor=\color[rgb]{0.8,0.8,0.8},
extendedchars=true,
xleftmargin=10pt,
xrightmargin=10pt,
framexleftmargin=10pt,
framexrightmargin=10pt
}

% Corpo do texto
\begin{document}
\frontmatter 
\fancyhead[RO]{{\footnotesize\rightmark}\hspace{2em}\thepage}
\setcounter{tocdepth}{2}
\fancyhead[LE]{\thepage\hspace{2em}\footnotesize{\leftmark}}
\fancyhead[RE,LO]{}
\fancyhead[RO]{{\footnotesize\rightmark}\hspace{2em}\thepage}

\onehalfspacing

% ---------------------------------------------------------------------------- %
% CAPA
% Nota: O título para as dissertações/teses do IME-USP devem caber em um 
% orifício de 10,7cm de largura x 6,0cm de altura que há na capa fornecida pela SPG.
\thispagestyle{empty}
\begin{center}
    \vspace*{2.3cm}
    \textbf{\Large{Uma infraestrutura para desenvolvimento de aplicações distribuídas baseada em minitransações}}\\
    
    \vspace*{1.2cm}
    \Large{Leandro Ferro Luzia}
    
    \vskip 2cm
    \textsc{
    Dissertação apresentada\\[-0.25cm] 
    ao\\[-0.25cm]
    Instituto de Matemática e Estatística\\[-0.25cm]
    da\\[-0.25cm]
    Universidade de São Paulo\\[-0.25cm]
    para\\[-0.25cm]
    obtenção do título\\[-0.25cm]
    de\\[-0.25cm]
    Mestre em Ciências}
    
    \vskip 1.5cm
    Programa: Ciências da Computação\\
    Orientador: Prof. Dr. Francisco C. R. Reverbel
    \vskip 1cm
    
    \vskip 0.5cm
    \normalsize{São Paulo, Junho de 2013}
\end{center}

% ---------------------------------------------------------------------------- %
% Página de rosto (SÓ PARA A VERSÃO DEPOSITADA - ANTES DA DEFESA)
% Resolução CoPGr 5890 (20/12/2010)
\newpage
\thispagestyle{empty}
    \begin{center}
        \vspace*{2.3 cm}
        \textbf{\Large{Uma infraestrutura para desenvolvimento de aplicações distribuídas baseada em minitransações}}\\
        \vspace*{2 cm}
    \end{center}

    \vskip 2cm

    \begin{flushright}
	Esta é a versão original da dissertação elaborada pelo\\
	candidato Leandro Ferro Luzia, tal como \\
	submetida à Comissão Julgadora.
    \end{flushright}

\pagebreak

\pagenumbering{roman}

%\chapter*{Agradecimentos}
%Texto texto texto texto texto texto texto texto texto texto texto texto texto
%texto texto texto texto texto texto texto texto texto texto texto texto texto
%texto texto texto texto texto texto texto texto texto texto texto texto texto
%texto texto texto texto. Texto opcional.

\chapter*{Resumo}

\noindent LUZIA, L. F. \textbf{Uma infraestrutura para desenvolvimento de aplicações distribuídas baseada em minitransações}. 
2012. 120 f.
Dissertação (Mestrado) - Instituto de Matemática e Estatística,
Universidade de São Paulo, São Paulo, 2013.
\\

Resumo...
%Este trabalho apresenta uma infraestrutura para sistemas distribuídos que oferece uma abstração de estado compartilhado entre as máquinas na forma de um repositório de dados utilizando minitransações para garantir a atomicidade na execução de grupos de operações sobre esse repositório. As minitransações são uma modificação do protocolo de efetivação em duas fases em que todas as operações que compõem a transação são enviadas de uma só vez, diminuindo o custo de comunicação entre as máquinas do sistema. Com o uso da primitiva de minitransação os desenvolvedores podem projetar sistemas distribuídos baseando o compartilhamento de estado entre as máquinas em estruturas de dados, e não na troca explícita de mensagens. As máquinas terão à disposição um repositório de dados que pode crescer de forma a acomodar grandes quantidades de dados e que permite que aplicações tenham sempre acesso a dados consistentes. Assim, esperamos que o desenvolvimento da aplicação distribuída seja mais simples e ajude o desenvolvedor a focar nas necessidades reais da aplicação.
\\

\noindent \textbf{Palavras-chave:} minitransação, transação, banco de dado, sistemas distribuídos.

\chapter*{Abstract}
\noindent LUZIA, L. F. \textbf{An infrastructure for developing distributed applications based in minitransactions}. 
2010. 120 f.
Dissertação (Mestrado) - Instituto de Matemática e Estatística,
Universidade de São Paulo, São Paulo, 2013.
\\
TODO reescrever por que alterei o resumo em português

In this work, we propose an infrastructure for distributed systems that allows
state sharing abstraction among machines as a data repository using minitransactions to ensure atomicity when executing groups of operations over 
this repository. Minitransactions are a modification in the two phase 
commit protocol such that all transaction operations are sent in one network round trip, reducing the overhead of communication. By using the 
minitransaction primitive developers can design distributed systems in which the state sharing is based in the usage of data structures and not 
explicit message exchange. The machines will have access to a data repository that can grow to serve large amounts of data and allow applications 
to access consistent data. This way, we expect to facilitate the development of
distributed applications and to help developers to focus in the real needs of
the applications.
\\

\noindent \textbf{Keywords:} minitransaction, transaction, database, distributed systems.

\tableofcontents

% \chapter{Lista de Abreviaturas}
% \begin{tabular}{ll}
% 	ACID    & Atomicidade, Consistência, Isolamento e Durabilidade \\
%             & (\emph{Atomicity, Consistency, Isolation and Durability})\\
%     SGBD	& Sistema Gerenciador de Banco de Dados\\
% 	2PC		& Efetivação em Duas Fases (\emph{Two-Phase Commit})\\
% 	TCP/IP	& Conjunto de protocolos de comunicação utilizado na Internet\\
% 			& (\emph{Transmition Control Protocol} e \emph{Internet Protocol})\\
% \end{tabular}

\listoffigures
\listoftables
\listofalgorithms
\lstlistoflistings
\mainmatter

% cabeçalho para as páginas de todos os capítulos
\fancyhead[RE,LO]{\thesection}

\singlespacing              % espaçamento simples

\chapter{Introdução}
\label{chap:introducao}
Um sistema distribuído é uma coleção de dispositivos computacionais individuais que podem se comunicar uns com os outros \cite{tanenbaum, distributed_computing}. Essa definição engloba uma gama de sistemas computacionais atuais, desde placas de circuitos integrados contendo diversos processadores até a \emph{Internet}. 

Os sistemas distribuídos aos quais este trabalho se refere são compostos por diversos computadores interligados por uma rede de comunicação. Cada computador nesses sistemas possui acesso somente ao seu próprio sistema de armazenamento e a única forma de compartilhar informação é por meio da troca de dados pela rede de comunicação.

Como exemplos podemos citar desde sistemas clássicos como o serviço de nomes de domínio da internet (\emph{DNS}, ou \emph{Domain Name Service}, que mapeia nomes de domínios para endereços de rede \cite{dns}), o correio eletrônico (\emph{email} \cite{email}) e a rede de alcance global (\emph{WWW}, ou \emph{World Wide Web} \cite{www}); passando por sistemas de compartilhamento de dados e de comunicação diretamente entre usuários, os chamados sistemas ponto-a-ponto, como \emph{Skype}, \emph{BitTorrent} e \emph{Gnutella}, sistemas de busca como \emph{Google} ou \emph{Bing} e redes sociais como \emph{Facebook} ou \emph{Twitter}; até jogos online com número maciço de jogadores(\emph{MMOG}, ou \emph{Massive Multiplayer Online Game}) e dinheiro eletrônico (\emph{BitCoin} \cite{bitcoin}).

A implementação de sistemas distribuídos em larga escala é complexa, pois esses sistemas precisam lidar e se recuperar de falhas, controlar e gerenciar o acesso e modificação concorrente do estado do sistema, detectar e corrigir possíveis conflitos que esse acesso concorrente possa causar, tudo isso evitando que o sistema fique indisponível ou que o estado do sistema seja perdido.

Diversas técnicas e mecanismos são utilizados para atingir os objetivos descritos acima, de forma que os usuários possam utilizar esses sistemas de maneira consistente. Aos usuários é exposto um conceito ao mesmo tempo simples e poderoso: transação. Uma transação permite que operações no sistema sejam consideradas como uma única operação lógica, e encapsulam toda a complexidade envolvendo as ações que precisam ser executadas para que essa operação lógica seja bem sucedida.   

Neste trabalho propomos a utilização de minitransações como uma abordagem viável e semanticamente mais coerente para o desenvolvimento de aplicações distribuídas. Os aspectos semânticos de uma transação ficam claramente especificados em uma minitransação, o que leva a uma maior clareza e coerência do código. Uma infraestrutura com suporte à minitransações foi desenvolvida para demonstrar a praticidade e efetividade do uso dessas minitransações no desenvolvimento de sistemas distribuídos.

\section{Objetivo}
\label{sec:objetivo}
O objetivo deste trabalho é apresentar e explicar o conceito de minitransação, seu escopo de utilização e suas vantagens e desvantagens em relação a uma transação convencional. A minitransação é utilizada como uma primitiva de programação disponibilizada para o uso no desenvolvimento de aplicações distribuídas. 

Com o uso de minitransações, há uma separação mais clara entre os aspectos operacionais e semânticos de uma transação. Os aspectos operacionais são encapsulados e tratados diretamente pelo ambiente de execução da minitransação, enquanto os aspectos semânticos ficam explícitos na definição da minitransação, expondo claramente a intenção da transação.

Essa clareza é obtida ao custo de uma redução do escopo em que as minitransações podem ser executadas. Toda minitransação pode ser expressa como uma transação convencional, mas nem toda transação convencional pode ser mapeada para uma minitransação. Os cenários em que as minitransações podem ser utilizadas e as situações às quais elas não são aplicáveis são abordadas também.

Este trabalho abrangeu também o desenvolvimento de uma infraestrutura com suporte à execução de minitransações e a criação e avaliação de algumas aplicações de teste, para validar e demonstrar o uso das minitransações. O desenvolvimento dessa infraestrutura é documentado e explicado também neste texto, assim como as avaliações e o resultado dos testes efetuados.

\section{Organização do texto}
\label{sec:organizacao_do_texto}
Este texto está organizado em sete capítulos, cuja ordem segue um desenvolvimento linear de conceitos e apresentações. A leitura sequencial do texto é recomendada, mas alguns trechos podem ser suprimidos, caso haja familiaridade com o assunto apresentado em determinada seção.

Este primeiro capítulo resume sucinta e brevemente o assunto principal do trabalho. Ele também oferece uma ambientação na qual será baseada o desenvolvimento do restante do texto, e aborda rapidamente termos essenciais utilizados em toda esta dissertação. Também são apresentados outros trabalhos que podem ser relacionados de alguma forma a este.

O segundo capítulo descreve a evolução histórica dos sistemas computacionais, relatando superficialmente os diferentes tipos de abordagens para o desenvolvimento de sistemas e culminando no foco deste trabalho, os sistemas distribuídos. As diversas formas em que se apresentam e os variados problemas que devem tratar levam ao assunto do capítulo seguinte.

No terceiro capítulo detalhada e aprofunda a noção de uma transação e o paradigma de programação que ela impõem para aplicações que a utilizam. Somente alguns aspectos de uma transação, os mais relevantes às minitransações, são abordados, devido à abrangência do tema.

O quarto capítulo apresenta as minitransações e é, portanto, o capítulo principal deste trabalho. Uma definição é formalizada para uma minitransação, seu escopo de utilização é delimitado e as vantagens e desvantagens são abordadas.

O quinto capítulo é o mais técnico deste texto, descrevendo a infraestrutura desenvolvida e detalhando os pontos principais, relacionados à execução de minitransações.

O sexto capítulo é composto pela avaliação e resultados obtidos de testes e validações efetuadas em aplicações desenvolvidas utilizando a infraestrutura apresentada no capítulo cinco.

O sétimo e último capítulo conclui este trabalho. Ele aborda os problemas encontrados, as soluções utilizadas, as lições aprendidas e possíveis melhorias e continuações deste trabalho.

\section{Trabalhos relacionados}
\label{sec:trabalhos_relacionados}
O conceito de minitransação é introduzido como base para a construção de \emph{Sinfonia} \cite{sinfonia}, um sistema cujo foco é prover a base para o desenvolvimento de sistemas distribuídos de baixo nível, como sistemas de arquivos distribuídos, gerenciadores de travas ou serviços de comunicação de grupos de computadores, enquanto que o objetivo deste trabalho é utilizar as minitransações como base para a construção de uma infraestrutura que facilite o desenvolvimento de aplicações distribuídas de alto nível, como sistemas de comércio eletrônico ou redes sociais.

\cite{padilha} apresenta um sistema de armazenamento baseado em minitransações tolerante a falhas bizantinas. Em sistemas que toleram somente componentes com falhas simples (\emph{fail-stop components}), é assumido que um componente pode estar em dois estados: ativo e inativo. Se estiver em um estado ativo, o componente se comportará de acordo com a especificação do sistema. Se estiver inativo, o componente simplesmente para de interagir com o sistema. Essa é uma maneira simples e um tanto simplificada de lidar com falhas no sistema, mas é a forma utilizada por diversos sistemas, entre eles \emph{Sinfonia} e a nossa infraestrutura. A maneira mais geral de lidar com falhas é através da modelagem de falhas bizantinas \cite{byzantine}. Em sistemas que lidam com esse tipo de falha, um componente ativo pode se comportar de forma incorreta, enviando mensagens com conteúdo aleatório (correto ou incorreto), ou não enviando mensagem nenhuma. O tratamento de falhas bizantinas não será discutido neste trabalho.

O uso mais difundido de transações é no contexto dos gerenciadores de bancos de dados relacionais \cite{vaca}, como \emph{Oracle} \cite{oracle}, \emph{MySQL} \cite{mysql}, \emph{SQL Server} \cite{sqlserver}, entre diversos outros. Essas transações podem ser usadas em cenários nos quais não conseguimos utilizar as minitransações, sendo portanto muito mais gerais. Porém, devido às propriedades que devem garantir, o uso dessas transações não permite escalar o banco de dados para um grande número de máquinas, algo que as minitransações permitem.

Existem diversos sistemas que visam o armazenamento escalável de informações e a disponibilização de serviços para facilitar o  desenvolvimento de sistemas distribuídos, visando em geral a utilização em aplicações de internet de larga escala. Entre eles, podemos citar \emph{Bigtable} \cite{bigtable}, \emph{Dynamo} \cite{dynamo}, \emph{ZooKeeper} \cite{zookeeper}, e \emph{PNUTS} \cite{pnuts}.

\emph{Bigtable} é o sistema de armazenamento distribuído do \emph{Google} que oferece uma abstração de um mapa ordenado, multidimensional, esparso e distribuído. \emph{Dynamo}, da \emph{Amazon}, é um sistema de armazenamento chave-valor que visa oferecer alta disponibilidade às aplicações. Esses dois sistemas permitem que dados sejam particionados e replicados para obter melhor desempenho e disponibilidade, mas
permitem que diferentes máquinas possam ter versões diferentes de uma mesma informação.

\emph{ZooKeeper} é um sistema que provê serviços de coordenação e sincronização para a construção de sistemas distribuídos que utiliza o algoritmo \emph{Paxos} \cite{paxos} para garantir consistência entre as operações. Como o objetivo do \emph{ZooKeeper} é permitir a coordenação entre componentes de um sistema distribuído, sua capacidade de armazenamento é limitada (em um \emph{megabyte}), e portanto não é utilizável como um repositório de dados geral.

\emph{PNUTS} é o serviço de armazenamento de dados do \emph{Yahoo!} que garante que todas as réplicas de um determinado dado armazenado executam as mesmas alterações, na mesma ordem. PNUTS permite a existência de várias versões de um dado, e oferece uma primitiva \emph{test-and-set-write}, que efetua uma escrita de dados somente se uma determinada versão do dado for encontrada, semelhante ao mecanismo de comparação das minitransações.

Por último, \emph{Hazelcast} \cite{hazelcast} e \emph{Akka} \cite{akka} são ferramentas para o desenvolvimento de sistemas distribuídos que visam eliminar a necessidade de comunicação explícita entre os participantes do sistema, oferecendo abstrações como estruturas de dados
distribuídas ou memória transacional. \emph{Hazelcast} oferece a programas rodando na \emph{JVM Java} implementações distribuídas das coleções da biblioteca padrão (\emph{Collection, Set, List e Map}). \emph{Akka} permite a utilização de memória transacional por \emph{software} (\emph{software transactional memory} ou \emph{STM} \cite{stm}), uma abordagem que emprega o conceito de transação discutido 
neste trabalho em operações de leitura e escrita na memória principal do computador.

\chapter{Paradigma transacional}
\label{chap:transacao}
Este capítulo apresenta o paradigma transacional como uma alternativa para o desenvolvimento de software. Esse paradigma utiliza o conceito de transação para definir unidades de execução de grupos de operações sobre o estado do sistema.

A seção \ref{sec:tolerancia_a_falhas} apresenta uma idéia da necessidade e da origem da utilização de transações.

Na seção \ref{sec:transacao} veremos as propriedades que essas transações devem possui para oferecer uma ferramenta de desenvolvimento efetiva ao desenvolvedor.

Por último, a seção \ref{sec:extensoes} apresenta algumas extensões do modelo de transações descrito neste capítulo.

\section{Evolução dos sistemas computacionais}
\label{chap:evolucao}
Este capítulo apresenta uma breve descrição da evolução dos sistemas computacionais e da maneira como foram e são construídos. O tamanho e a complexidade desses sistemas evoluiram acompanhando, e muitas vezes incentivando, a evolução das plataformas de \emph{hardware} em que executam. Essa descrição não é completa e nem exaustiva, uma vez que o intuito é apresentar os tipos mais representativos de sistemas e as técnicas e arquiteturas utilizadas em seu desenvolvimento.

Os primeiros computadores foram criados com o intuito de resolver mais rapidamente cálculos matemáticos. Essas máquinas ocupavam salas inteiras e eram programadas por meio de alterações diretas nas ligações entre os componentes físicos da máquina. 

*** TODO colocar foto do eniac - fonte: http://ds.haverford.edu/bitbybit/bit-by-bit-contents/chapter-four/4-8-project-px-and-the-eniac/

A maneira de representar e armazenar os programas evoluíram, as linguagens montadoras (\emph{assembly}) foram criadas, mas ainda assim a programação era totalmente dependente do tipo da máquina sendo utilizada (chamada de programação de baixo-nível). Essas linguagens eram formadas por muitos comandos que correspondiam a um ou alguns poucos comandos interpretados diretamente pelo processador. 

Portanto, o programador precisava se preocupar com o número de registradores disponíveis, a quantidade de memória livre, a movimentação de dados entre registradores e memória, controlar o uso e o endereçamento de dados na memória e no disco e lidar com chamadas e interrupções de sistema, por exemplo. Havia uma grande diferença entre a intenção final de um programa e o seu texto codificado na linguagem de programação utilizada (a chamada impedância semântica, ou \emph{gap} semântico).

*** TODO colocar um exemplo de soma em assembly

*** TODO colocar um exemplo de if simples em assembly

A tecnologia dos transistores permitiu uma diminuição no tamanho dos computadores e, por consequência, um aumento na escala de fabricação. Esses computadores passaram a ser utilizados por empresas para gerenciar e manipular informações referentes aos seus negócios. Isso passou a representar vantagens competitivas para as empresas e culminou hoje na importância inegável que os sistemas informatizados tem na condução e no desempenho de corporações.

Surgiram linguagens de alto-nível, que permitiam ao programador abstrair detalhes do hardware e da plataforma utilizada, podendo um mesmo código criar programas que rodassem em plataformas diferentes. Na verdade, como descreve Wirth em \cite{alg_ds}, o que essas linguagens passam a oferecer é o conceito de um "computador artificial" que compreende os comandos e as construções que a linguagem possui. Essas linguagens tentam diminuir a impedância semântica entre o domínio do problema a ser resolvido e a codificação da sua solução na forma de uma programa de computador.

Assim, ao invés de programar utilizando comandos que instruíam o computador a mover o conteúdo do endereço de memória A para o registrador R, adicionar 1 ao valor contido no registrador R e armazenar esse resultado no registrador S e depois mover o conteúdo do registrador S de volta para o endereço de memória A, o programador podia simplesmente dizer $A = A + 1$.

Enquanto um computador físico compreende instruções simples e específicas que operam em unidades como um registrador ou endereço de memória, esse computador artificial que as linguagens de alto-nível representam são capazes de entender e executar construções e expressões mais complexas e semanticalmente mais próximas de uma linguagem natural. Controles e desvios de fluxo eram feitos com instruções que diziam ao computador para continuar a execução do programa a partir de um determinado endereço de memória na linguagens de baixo-nível, enquanto que em linguagens de alto-nível, é possui utilizar construções com expressões do tipo $if$, $for$ ou $while$.

*** TODO colocar um exemplo de soma em Java

*** TODO colocar um exemplo de if simples em Java

As plataformas evoluíram para oferecer novos comandos e modos de execução, permitindo a execução de diversos programas ao mesmo tempo, oferecendo espaços de endereçamento de memória maiores e mesmo a criação de computadores virtuais dentro de uma mesma máquina física, emulando outros modelos e sistemas. Com a criação dos circuitos integrados os computadores diminuíram ainda mais seu tamanho, consumo de energia e custo. O surgimento do computador pessoal aumentou a popularidade dessas máquinas, que começaram a ser utilizadas e programadas para os mais diversos fins. Novos ambientes e sistemas visuais aumentaram a qualidade da experiência do usuário.

Os sistemas operacionais funcionam também como uma camada de abstração das funcionalidades presentes no hardware das máquinas, facilitando tarefas como gerenciamento e uso de memória virtual, utilização de dispositivos conectados e compartilhamento de recursos por dois ou mais programas ao mesmo tempo \cite{so}. Ao esconder detalhes específicos do hardware utilizado e apresenta uma camada coesa e unificada aos programas, os sistemas operacionais também permitem que um programa escrito em uma certa linguagem para um determinado sistema operacional execute em qualquer plataforma de hardware em que esse sistema esteja disponível. 

Novos paradigmas de programação surgiram, entre eles a abordagem orientada a objetos, em que o programa desenvolvido é visto como uma coleção de objetos, entidades que encapsulam dados e comportamentos, interagindo e trocando informações para cumprir os requisitos do sistema. O intuito desse paradigma é permitir uma melhor tradução do problema real sendo resolvido para o computador tentando diminuir, novamente, a impedância semântica.

As redes de computadores permitiram a exploração de novas fronteiras no desenvolvimento, possibilitando o surgimento de sistemas executando de forma cooperativa em diferentes máquinas, compartilhando e gerenciando informações. A popularização da \emph{Internet} permitiu novas formas de publicação e consumo de informação, oferecendo novas maneiras de integrar sistemas, e disponibilizando novas aplicações. 

Novos mecanismos surgiram para viabilizar o desenvolvimento desses sistemas distribuídos, fazendo uso de chamadas remotas de procedimento (\emph{RPC}, ou \emph{Remote Procedure Call} \cite{rpc}), invocação remota de métodos (\emph{RMI}, ou \emph{Remote Procedure Call} \cite{rmi}), filas de mensagens (\emph{Message Queues}), \emph{web services}, entre outros. Coletivamente, esses mecanismos são chamados de \emph{Middleware} \cite{alonso} e atuam como uma camada que esconde os detalhes de comunicação envolvidos em sua execução, oferecendo para a aplicação uma interface simples e direta.

Os sistemas desenvolvidos passaram a rodar em outros tipos de dispositivos, e esses passaram a incorporar características dos computadores. O processamento, utilização e compartilhamento da informação passou a permear muitos aspectos da vida cotidiana, mesmo que alguém estivesse longe de um computador convencional. 

A disseminação das redes sem fio, sua ampla disponibilidade e crescente melhoria permitiram que aparelhos de telefone celular, televisão e até eletrodomésticos passassem a acessar, produzir e compartilhar dados de qualquer lugar a qualquer momento - um movimento irreversível que tem sido chamado de computação ubíqüa \cite{ubiquitous}. 

O uso desses dispositivos, integrados em geral a aplicações disponíveis na \emph{Internet}, tem gerado um volume de dados sem precedentes que exige recursos computacionais que excedem a capacidade de máquinas individuais para armazenamento, processamento e análise. A essa enorme quantidades de dados e as novas técnicas, algortimos e ferramentas utilizados para lidar com elas foi dado o nome de \emph{Big Data} \cite{big_data}.

Essa crescente demanda de aplicações espalhadas pela \emph{Internet} e dispositivos móveis por capacidade e disponibilidade de recursos computacionais trouxe à tona um termo que tem dominado o vocabulário das empresas de tecnologia: computação em nuvem (\emph{cloud computing}, \cite{cloud}). Embora seja usado em diferentes contextos e ganhe diferentes significados em alguns momentos, esse termo se refere em geral a uma série de conceitos e tecnologias utilizadas para prover recursos computacionais sob demanda e de maneira flexível, permitindo executar um sistema em diferentes escalas para atender flutuações na demanda de utilização. 

Como máquinas podem ser adicionadas ou removidas durante a execução do sistema, esse deve estar preparado para lidar e tratar requisiçoes duplicadas, tentativas de reconexão e redistribuição de carga. O sistema deve ser capaz de manter seu estado global consistente e válido, e fazer isso face a mudanças bruscas na configuração do sistema não é uma tarefa trivial. Como veremos no capítulo seguinte, transações são uma ferramenta de grande utilidade para realizar essa tarefa de manter o estado do sistema consistente. 

*** TODO ver se dá pra pegar aquela parte do booch que ele explica a evolução das linguagens...

\section{Tolerância a Falhas}
\label{sec:tolerancia_a_falhas}
O estado de uma aplicação é definido como um conjunto de dados relacionados de alguma maneira. Esses relacionamentos podem ser vistos como invariantes em relação aos dados e em relação a como esses dados são alterados. Quando todas essas invariantes definidas estiverem satisfeitas, o estado da aplicação é dito consistente.

A execução de uma aplicação, por mais simples que seja, está sujeita a diversos tipos de falhas. Ao passo em que evoluem, passando a ser geograficamente distribuídas, executando em diferentes equipamentos e plataformas e aumentando seus requisitos de disponibilidade e tempo de resposta, as chances de falha aumentam consideravelmente. Manter o estado da aplicação consistente em cenários de ocorrência de falhas não é uma tarefa trivial.

Falhas de hardware já foram muito comuns no passado, mas o desenvolvimento da tecnologia e de mecanismos de detecção e correção tornaram esse tipo de falha cada vez mais rara. Falhas de software são um problema bem mais frequente e difícil de resolver, a despeito do uso de processos de desenvolvimento e técnicas de teste e avaliação.

A interpretação errônea dos requisitos do sistema, um projeto de sistema que traduz de maneira inexata os requisitos, ou uma implementação incorreta desse projeto são exemplos do que pode causar problemas no sistema. Além disso, o caráter dinâmico do software, com constantes adições de funcionalidades e correções de problemas, pode introduzir mais falhas nos mais bem testados sistemas. Situações pontuais como sobrecarga da máquina e atrasos em subsistemas como entrada e saída ou rede podem ocasionar falhas difíceis de reproduzir e corrigir.

Uma das formas de tornar o software tolerante a falhas é utilizar uma técnica chamada de programação \textbf{multi-versão} (\emph{multiversion programming} ou \emph{n-version programming} \cite{n_version}), em que um programa é escrito de $n$ maneiras diferentes, gerando $n$ versões do mesmo programa. A execução do sistema vai consistir da execução em paralelo dessas versões e a resposta do sistema será tomada como o consenso entre as resposta de todas as versões. A impossibilidade de atingir um consenso implica em falha do sistema.

Embora efetiva, essa abordagem possui um custo de implementação elevado e é de difícil manutenção, pois a reparação em caso de erro não é trivial, uma vez que cada versão terá um estado interno diferente. Além disso, mesmo sendo criteriosamente testadas, as versões conterão problemas, o que pode levar à falta de consenso ou a um consenso em torno de uma resposta incorreta.

Uma outra maneira de tornar o software tolerante a falhas é por meio do uso de \textbf{transações}, descritas na seção seguinte.

\section{Transação}
\label{sec:transacao}
Uma transação é uma coleção de operações sobre o estado de um sistema. Ela pode ser vista como uma operação lógica composta por operações mais simples, que acessam e modificam o estado do sistema de maneira a mantê-lo sempre consistente. Uma falha em alguma das operações faz com que a transação como um todo seja abortada e o estado do sistema seja restaurado como era no início da transação \cite{garcia-molina, vaca, gray}.

Transação é o bloco básico de construção no paradigma transacional que oferece uma abstração de desenvolvimento que facilita a organizar uma aplicação em transações compostas por um conjunto de operações que, do ponto de vista da aplicação, são executadas de forma atômica. 

Ao longo do tempo foram identificadas quatro propriedades que definem uma transação. Essas propriedades acabaram por se tornar sinônimo de transação, e a sua sigla, \emph{ACID}, está usualmente associada à transações. Essas propriedades estão descritas na seção \ref{subsec:acid}.

A descrição de transação apresentada neste capítulo pode ser considerada como convencional. Hoje em dia existem diversas extensões desse modelo convencional, criadas para adequar ou otimizar a execução das transações a um determinado cenário. Essas extensões são apresentadas resumidamente na seção \ref{subsec:extensoes}.

\subsection{Outros modelos de execução atômica}
\label{subsec:outros_modelos_execucao_atomica}

Falar sobre semáforo, mutex, etc...

\subsection{ACID}
\label{subsec:acid}
Transações apresentam um conjunto de propriedades que as tornam uma base simples e sólida na qual se pode basear o desenvolvimento de aplicações. Essas propriedades são chamadas conjuntamente de \emph{ACID} (\emph{Atomicity, Consistency, Isolation e Durability}, ou Atomicidade, Consistência, Isolamento e Durabilidade). 

\textbf{Atomicidade} se refere ao fato que a execução da transação é atômica, ou seja, a execução da transação significa que todas as operações que a compõem foram executadas com sucesso. A atomicidade diz respeito a qualquer observador externo, que não deve ser capaz de acessar nenhum estado intermediário criado pela transação durante sua execução. Os únicos dois estados que um observador externo pode acessar é o estado final, após a transação ser finalizada, ou o estado inicial, após a transação ser cancelada.

\textbf{Consistência} é a propriedade que diz que o resultado da execução de uma transação é um estado consistente. Seja esse novo estado o resultado de transformações aplicadas ao estado inicial, ou o próprio estado inicial no caso de cancelamento, o ponto principal sobre essa propriedade é que o novo estado é consistente.

\textbf{Isolamento} significa que o resultado das operações de uma transação $A$ não devem interferir na execução de uma outra transação $B$, enquanto $A$ não for finalizada.

\textbf{Durabilidade} impõem que uma vez que a transação tenha sido executada com sucesso, o estado resultante do sistema será mantido. Nenhuma falha posterior, seja ela causada pelo usuário, pelo ambiente ou por componentes de hardware, poderá alterar esse estado. A única maneira de faze-lo é com a execução de uma nova transação.

Embora separadas e nomeadas de forma a gerar um acrônimo com sonoridade atraente, essas propriedades não são totalmente independentes umas das outras, e suas definições em geral fazem referência às outras, como veremos nas seções a seguir.

Garantir a atomicidade e durabilidade na execução de múltiplas transações concorrentes em situações de erro é uma tarefa complexa. Fazê-la atendendo a requisitos de performance e economia de recursos torna-a mais complicada. 

\emph{ARIES} (\emph{Algorithm for Recovery and Isolation Exploiting Semantics}, \cite{aries}) é o método mais utilizado para efetuar implementar os mecanismos que asseguram ao um ambiente de execução transacional as propriedades \emph{ACID}. Esse método utiliza o conceito de registros de atividades e de travas como base para a implementação dos mecanismos, e sua idéia geral está distribuída nas seções seguintes.

\begin{figure}
  \centering
  \includegraphics[width=\textwidth]{transicao_estado} 
  \caption{Transição de estados de uma transação}
  \label{fig:transicao_estado} 
\end{figure}

*** TODO explicar a transição de estados ou colocar em uma outra seção melhor...

\subsubsection*{Consistência}
A propriedade mais básica é a consistência, que é também a mais abstrata das quatro propriedades. Ela está relacionada à validação do estado da aplicação, que por sua vez diz respeito às invariantes impostas sobre os dados que compõem esse estado. Sua importância reside no fato que uma aplicação, para atender de maneira efetiva seus requisitos, não pode utilizar dados inconsistentes por um período indefinido de tempo. Ela é abstrata no sentido que muitas das invariantes não podem ser diretamente expressas ou validadas, o que confere a ela um caráter menos determinístico.

Um ponto importante a destacar é que a propriedade de consistência declara que o resultado da transação deve ser um estado de sistema consistente, obedecendo às invariantes impostas. Porém, a execução das operações da transação pode deixar o estado temporariamente inconsistente, até que todas as operações sejam executadas. Ao término de todas as operações e, por consequência, da transação

Por exemplo, vamos supor que o estado de um sistema seja composto por duas variáveis, $X$ e $Y$, que representam os saldos de duas contas bancárias. O sistema em questão permite a transferência de valores entre essas duas contas. As invariantes nesse sistema declaram que o valor de todas as contas precisa ser no mínimo zero e que ao efetuar uma transferência o valor do agregado das contas não pode mudar, ou seja, se $X_{t_1} + Y_{t_1} = Z$ então $X_{t_2} + Y_{t_2} = Z$, onde $t_1$ é o momento em que a transação inicia e $t_2$ é o momento seguinte ao qual ela é finalizada.

\begin{algorithm}
\caption{Transferência de valores}
\label{alg:transferencia_transacao_1}
\Inicio{
	$IniciarTransacao$\;
	$V \gets \text{Valor a transferir}$\;
	$X \gets X - V$\;
	$Y \gets Y + S$\;
	$EfetivarTransacao$\;
}
\end{algorithm}

Como podemos ver no Algoritmo \ref{alg:transferencia_transacao_1}, durante a execução da transação o estado do sistema fica inconsistente. A modificação efetuada pela operação da quarta linha leva o estado do sistema à uma situação inconsistente com a invariante declarada. Essa inconsistência é corrigida na quinta linha, ao adicionar o valor removido de $X$ à variável $Y$.

Apesar da simplicidade, a transação do Algoritmo \ref{alg:transferencia_transacao_1} nos mostra que mesmo as funcionalidades mais elementares irão deixar o estado do sistema temporariamente inconsistente. O que deve ser respeitado é o fato de que, ao término da transação, o estado do sistema esteja novamente consistente.

Como o estado do sistema pode ficar inconsistente durante a execução da transação, uma transação $T_1$ não pode ter acesso ao resultado das transformações efetuadas por uma outra transação $T_2$ que ainda não tenha sido finalizada. Se isso ocorrer, $T_1$ efetuará  suas próprias transformações a partir de um estado inicial inconsistente, quebrando a regra de consistência.

Assim, a propriedade de isolamento toma forma para impedir que transações em curso que efetuaram transformações que deixaram o sistema inconsistente afetem a outras transações em execução. 

\subsubsection*{Isolamento}
Retomando o exemplo anterior sobre transferência de valores, vamos supor agora que existam duas transações $T_1$ e $T_2$ sendo executadas ao mesmo tempo.

$T_1$ precisa transferir $10$ e $T_2$ precisa transferir $15$. Como visto no capítulo \ref{chap:evolucao}, uma operação simples como $X \gets X - V$, declarada em apenas uma linha em linguagens de programação de alto-nível, abstrai uma série de micro-operações efetuadas pelo processador para efetuar uma conta e armazenar o seu resultado em uma variável (na verdade, essa atribuição em conjunto com a subtração podem ser vistos como uma transação, que retorna somente se a subtração for bem sucedida e o seu resultado for armazenado no espaço de memória identificado por $X$). 

O Algoritmo \ref{alg:assembly_subtracao} descreve de forma simplificada os passos efetuados pelo hardware para executar a quarta linha do Algoritmo \ref{alg:transferencia_transacao_1}, $X = X - V$. Como podemos ver, um conjunto de operações de baixo-nível precisam ser efetuadas para que a subtração ocorra.

\begin{algorithm}
\caption{Descrição simplificada da execução em nível de hardware}
\label{alg:assembly_subtracao}
\Inicio{
	Carregar no registrador $A$ o conteúdo do endereço de memória identificado por $X$\;
	Carregar no registrador $B$ o conteúdo do endereço de memória identificado por $V$\;
	Somar os valores dos registradores $A$ e $B$ e armazenar o resultado no registrador $C$\; 
	Copiar o conteúdo do registrador $C$ para o endereço de memória identificado por $X$;
}
\end{algorithm}

Levando em conta os Algoritmos \ref{alg:transferencia_transacao_1} e \ref{alg:assembly_subtracao} e que os valores iniciais de $X$ seja 30 e $Y$ seja 0, se a execução das transações não fosse isolada poderíamos ter um cenário em que as escolhas do escalonador do sistema operacional levassem a um fluxo de execução como o seguinte (considerando que cada transação esteja rodando em um processo distinto):

\begin{enumerate}
	\item $P_1$ inicia a transação $T_1$.
	\item $P_1$ recebe o valor 10 e o armazena em $V$.
	\item $P_1$ armazena o valor de $X$ no registrador $A$.
	\item O escalonador troca a execução para o processo $P_2$, efetuando todo o chaveamento de contexto.
	\item $P_2$ inicia a transação $T_2$.
	\item $P_2$ recebe o valor 15 e o armazena em $V$.
	\item $P_2$ armazena o valor de $X$ no registrador $A$.
	\item O escalonador é executado novamente e reativa o processo $P_1$.
	\item $P_1$ termina a execução do algoritmo \ref{alg:assembly_transacao}, armazenando 20 em $X$.
	\item $P_1$ armazenando 10 em $Y$.
	\item $P_1$ termina a execução do algoritmo \ref{alg:transferencia_transacao_1} efetivando a transação.
	\item O escalonador reativa $P_2$.
	\item $P_2$ não tem conhecimento do novo valor de $X$ armazenado por $P_1$, pois sua cópia em $A$ está desatualizada.
	\item $P_2$ armazena em $X$ o valor 15.
	\item $P_2$ armazena em $Y$ o valor 25.
	\item $P_2$ efetiva a transação e termina.
\end{enumerate}

Antes do início da transação tínhamos um total de 30 somando os valores das duas contas. Após o término da transação esse total é de 40, violando a invariante declarada. Portanto, o estado desse sistema está inconsistente.

O mecanismo mais comum para a implementação do isolamento são as travas (\emph{locks}), que a mecanismos de controle de concorrência oferecidos nos sistemas operacionais, como semáforos. A implementação mais simples de travas associa a cada dado que compõem o estado do sistema uma trava. Quando uma transação precisa acessar um determinado dado, o ambiente de execução automaticamente tenta atribuir a trava associada a esse dado à transação. Se a trava não estiver associada a nenhuma outra transação no momento, ela será atribuída à transação solicitante, e essa atribuição irá perdurar até o final da transação. Se essa trava já estiver associada a uma outra transação, a primeira transação irá esperar até que a trava esteja liberada para poder continuar.

Diversas variações e otimizações desse mecanismo de travas foram criadas, visando aumentar o grau de concorrência e a performance das transações, mas o conceito básico é o descrito acima.

O isolamento na execução de transações concorrentes permite ao desenvolvedor ignorar questões ligadas ao controle de concorrência nas aplicações, pois essas são gerenciadas pelo ambiente de execução. Assim, o software resultante fica menos complexo e mais claro.

\subsubsection*{Atomicidade}
Atomicidade é a propriedade que confere às transações o seu caráter \textbf{tudo-ou-nada} de execução. Esse caráter facilita o modelo de desenvolvimento ao apresentar um protocolo simples ao desenvolvedor: a transação é efetivada e as possíveis alterações de estado são aplicadas ao sistema ou a transação é cancelada e nenhuma alteração de estado é notada pela aplicação. 

A efetivação é o caminho natural e é atingida somente se todas as operações que compõem a transação forem executadas sem nenhuma erro. O estado do sistema é alterado para refletir quaisquer alterações que a transação possa ter produzido. A consistência desse novo estado é assumido como válido pelo ambiente de execução, uma vez que a transação não foi cancelada explicitamente. Assim fica a cargo do desenvolvedor compor a transação de maneira correta, utilizando as operações de tal forma que o resultado final seja consistente.

O cancelamento da transação é um caso de exceção e pode ocorrer por dois motivos: por solicitação da aplicação ou devido a algum problema durante a execução da transação. 

A aplicação pode solicitar explicitamente que a transação seja cancelada, descartando quaisquer alterações efetuadas e retornando o estado para o apresentado no início da transação. Esse cancelamento explícito faz parte do controle de consistência que a aplicação efetua. Se a aplicação identificar que suas ações irão deixar o estado inconsistente, ou que o fluxo de execução não pode continuar por algum motivo, a solicitação de cancelamento é a ferramenta à disposição da aplicação para manter o estado consistente.

O Algoritmo \ref{alg:transferencia_transacao_2} ilustra essa situação de cancelamento explícito da transação. A aplicação verifica se o valor da conta $X$ continua válido (maior do que zero) após o débito do valor. Se esse valor for negativo, a transação é cancelada.

\begin{algorithm}
\caption{Transferência de valores com cancelamento explícito}
\label{alg:transferencia_transacao_2}
\Inicio{
	$IniciarTransacao$\;
	$V \gets \text{Valor a transferir}$\;
	$X \gets X - V$\;
	\eSe{$X < 0$}
	{
		$CancelarTransacao$\;
	}
	{
		$Y \gets Y + V$\;
		$EfetivarTransacao$\;
	}
}
\end{algorithm}

Em alguns ambientes de execução, como SGBD's, essa restrição de que o valor da conta não pode ser negativo pode ser expressa diretamente no ambiente de execução, de forma que ele possa efetuar a validação e cancelar a transação caso a validação falhe. Aqui, essa validação é feita explicitamente pela aplicação.

O cancelamento devido a algum problema durante a execução da transação é solicitado automaticamente pelo ambiente de execução. Falhas de hardware, software ou rede, como trilhas de discos danificadas, erros de programação ou perda na ligação entre duas sub-redes são exemplos de problemas que fazem com que o ambiente de execução cancele automaticamente uma transação.

A atomicidade é implementada com o auxílio de um registro de atividades (\emph{log}) das transações. Nesse registro são armazenadas estruturas que representam informações sobre a execução das transações. O registro serve a duas funções principais: permitir a restauração do estado da aplicação no caso do cancelamento da transação (atomicidade) e garantir que um novo estado gerado pela execução bem sucedida de uma transação não seja perdido (durabilidade, que será descrita na próxima seção). Essa estrutura pode variar para incluir diversos tipos de informação, de acordo com o ambiente de execução utilizado, mas as informações principais estão descritas a seguir.

Todas as atividades da transação são armazenadas nesse registro. Uma pseudo-atividade é criada para indicar o início da transação, quando $IniciarTransacao$ é executada no algoritmo \ref{alg:transferencia_transacao_2}. Cada operação efetuada pela transação que modifica o estado do sistema é incluída nesse registro, em conjunto com informações adicionais como os valores do subconjunto do estado da aplicação modificado (tanto os valores antigos quanto os novos), a transação da qual a operação faz parte, o momento da execução da operação e um identificador único desse registro. 

Para finalizar, $CancelarTransacao$ e $EfetivarTransacao$ geram também pseudo-atividades que são armazenadas no registro, indicando como a transação deve ser finalizada, revertendo ou armazenando as modificações. 

Para efetuar o cancelamento de uma transação, o registro de atividades é lido do fim para o início, ou seja, a leitura começa na atividade mais recente da transação sendo cancelada, e continua nesse sentido até chegar à primeira operação registrada da transação. A cada operação lida, os valores alterados são substituídos pelo valor correspondente ao apresentado pelo sistema antes do início dessa operação. Dessa forma, ao final desse procedimento os valores iniciais do subconjunto do estado do sistema alterado pela transação terá sido totalmente recuperado.

A efetivação de uma transação consiste em aplicar todas as modificações efetuadas por essa transação ao estado do sistema. Como uma consequência da propriedade de isolamento, a efetivação de uma transação não pode interferir na execução de outras transações que estiverem executando concorrentemente e ainda não tenham sido efetivadas.

A aplicação das modificações efetuadas pela transação é feita por meio da leitura do registro de atividades. Esse leitura é feita em ordem crescente de tempo, ou seja, da operação mais antiga para a mais nova da transação. A cada operação lida, a modificação é aplicada, alterando o estado do sistema. Ao fim desse procedimento, os dados estarão atualizados, refletindo as modificações executadas pela transação.

\subsubsection*{Durabilidade}
Durabilidade é a propriedade que diz que uma vez finalizada a transação, o resultado de sua execução não pode ser desfeito arbitrariamente pelo ambiente de execução. Ou seja, o novo estado gerado pela execução da transação deve ser mantido a despeito de falhas ou problemas que possam ocorrer em um momento posterior à finalização da transação.

Isso não quer dizer que esse novo estado não possa ser modificado. O que essa propriedade assegura é que a única forma de modificar o resultado de uma transação finalizada é por meio da execução de uma nova transação, que efetua operações que revertem ou alteram os dados modificados pela primeira transação.

A implementação da durabilidade é feita também com o auxílio do registro de atividades, sendo utilizado quando o ambiente de execução é reiniciado, em geral após alguma falha. Nesses casos, o registro é analisado e o estado do sistema é analisado, em busca de transações que tenham sido registradas como efetivadas mas cujas alterações não estão refletidas no estado do sistema.

Transações nessa situação são reexecutadas automaticamente, efetuando novamente as operações da transação. Um controle especial precisa ser feito pois pode acontecer de somente algumas operações não estarem refletidas no estado do sistema, e portanto a implementação não pode reexecutar essas transações.

Esse procedimento acaba por assegurar também a atomicidade, pois pode ocorrer da transação estar registrada como cancelada mas o estado do sistema não estar refletindo a situação inicial, antes do início da transação. Nesse caso, as alterações são desfeitas.

%*** TODO colocar a imagem da página 168 do gray aqui...

%Podemos mostrar as vantagens de utilizar transações com um exemplo simples e clássico: transferência de valores. O Algoritmo \ref{alg:transferencia_valores_sem_transacao}, que implementa a transferência de valores entre duas contas, origem e destino, sem fazer nenhum controle ou verificação de falhas. Digamos que as funções $Ler$ e $Escrever$ implementam as operações de leitura e escrita em um gerenciador de recursos que armazene os dados das contas. Essas operações são executadas imediatamente e abortam a execução do programa caso algum erro ocorra.

%O algoritmo irá obter uma referência às contas, verificar se o saldo da conta de origem é suficiente, subtrair o valor da conta de origem, somar esse mesmo valor na conta de destino e escrever os novos valores nos recursos correspondentes. Se um erro ocorrer ao executar a escrita do novo valor na conta de destino os dados ficarão inconsistentes, pois o valor terá sido retirado da conta de origem ($Escrever(O, V_O - V)$ já aconteceu), mas não terá sido adicionado à conta de destino ($Escrever(D, V_D + V)$ falhou).

%\begin{algorithm}
%\caption{Transferência de valores}
%\label{alg:transferencia_valores_sem_transacao}
%\Inicio{
%    $O \gets \text{Recurso referente à conta de origem}$\;
%    $D \gets \text{Recurso referente à conta de destino}$\;
%    $V \gets \text{Valor a ser transferido}$\;
%    $V_O \gets Ler(O)$\;
%    \eSe{$V_O >= V$}
%    {
%        $V_D \gets Ler(D)$\;
%        $Escrever(O, V_O - V)$\;
%        $Escrever(D, V_D + V)$\;
%    }
%    {
%        $Imprimir(\text{Saldo insuficiente})$\;
%    }
%}
%\end{algorithm}

%O algoritmo \ref{alg:transferencia_valores_checar_erro} refina nossa primeiro algoritmo fazendo uso de duas novas funções, $Ler_M$ e $Escrever_M$. Essas funções implementam as mesmas operações das originais $Ler$ e $Escrever$, mas não abortam o programa caso ocorra uma falha. Ao invés disso, elas colocam o programa em um estado de erro que pode ser verificado com a função $HouveErro$, que indica se a última operação $Ler_M$ ou $Escrever_M$ falhou. Com essas novas funções, podemos criar um novo algoritmo, efetuando operações para desfazer alterações no estado do sistema em caso de falha.

%\begin{algorithm}
%\caption{Transferência de valores - tratamento de erros}
%\label{alg:transferencia_valores_checar_erro}
%\Inicio{
%    $O \gets \text{Recurso referente à conta de origem}$\;
%    $D \gets \text{Recurso referente à conta de destino}$\;
%    $V \gets \text{Valor a ser transferido}$\;
%    $V_O \gets Ler_M(O)$\;
%    \eSe{$V_O >= V$}
%    {
%        $V_D \gets Ler_M(D)$\;
%        $Escrever_M(O, V_O - V)$\;
%        \eSe{$HouveErro()$}
%        {
%            $Imprimir(\text{ERRO - não foi possível debitar valor})$\;
%        }
%        {
%            $Escrever_M(D, V_D + V)$\;
%            \Se{$HouveErro()$}
%            {   
%                $Escrever_M(O, V_O + V)$\;
%                \Se{$HouveErro()$}
%                {
%                    $Imprimir(\text{ERRO - dados ficarão inconsistentes!})$\;
%                }
%            }
%        }
%    }
%    {
%        $Imprimir(\text{Saldo insuficiente})$\;
%    }
%}
%\end{algorithm}

%Como podemos observar no Algoritmo \ref{alg:transferencia_valores_checar_erro}, o tratamento manual é tedioso e suscetível a erros. O número de casos a serem tratados pode aumentar rapidamente conforme a combinação entre as operações. Além disso, em alguns cenários pode não ser possível desfazer algumas alterações, o que envolveria um mecanismo de retentativas mais complexo.

%Uma abordagem transacional permite uma abordagem clara e uma linha de raciocínio mais direta, como podemos ver no algoritmo \ref{alg:transferencia_valores_transacao}. Nesse algoritmo, $IniciarTransacao$ é utilizada para criar uma nova transação, retornando um identificador para a transação criada; $Efetivar(T)$ comunica ao ambiente de execução que a transação $T$ foi bem sucedida e que as alterações efetuadas por ela podem ser realmente executadas; e $Abortar(T)$ sinaliza que algum erro semântico ocorreu e portanto as alterações efetuadas pela transação $T$ não podem ser efetivadas. As funções $Ler_T$ e $Escrever_T$, baseadas respectivamente em $Ler$ e $Escrever$, associam a leitura ou escrita do valor de uma determinada conta com a transação $T$.

%\begin{algorithm}
%\caption{Transferência de valores - uso de transações}
%\label{alg:transferencia_valores_transacao}
%\Inicio{
%    $O \gets \text{Recurso referente à conta de origem}$\;
%    $D \gets \text{Recurso referente à conta de destino}$\;
%    $V \gets \text{Valor a ser transferido}$\;
%    $T \gets IniciarTransacao()$\;
%    $V_O \gets Ler_T(T, O)$\;
%    \eSe{$V_O >= V$}
%    {    
%        $V_D \gets Ler_T(T, D)$\;
%        $Escrever_T(T, O, V_O - V)$\;
%        $Escrever_T(T, D, V_D + V)$\;
%        $Efetivar(T)$\;
%    }
%    {
%        $Imprimir(\text{Saldo insuficiente})$\;
%        $Abortar(T)$\;
%    }
%}
%\end{algorithm}

%Nesse algoritmo o comportamento das funções $Ler_T$ e $Escrever_T$ é parecido com o comportamento apresentado no Algoritmo \ref{alg:transferencia_valores_sem_transacao}: se ocorrer um erro, o programa é terminado. Agora, porém, antes de terminar o programa, as funções irão abortar a transação, utilizando $Abortar(T)$, mantendo os dados inalterados.

%O uso da transação permitiu que o formato do Algoritmo \ref{alg:transferencia_valores_transacao} ficasse muito parecido com o do Algoritmo \ref{alg:transferencia_valores_sem_transacao}. As únicas diferenças são relacionadas à criação da transação, para demarcar o início das operações que devem ser executadas de forma atômica, e os momentos da efetivação ou cancelamento. No caso de efetivação, nenhum erro ocorreu e o gerenciador de recursos irá efetivar as alterações efetuadas pelas operações da transação. Caso a conta de origem não possua saldo suficiente, a transação será cancelada.

%As falhas de caráter operacional estão sendo tratadas implicitamente pelo ambiente de execução. Se o recurso $D$ falhar ao efetuar a escrita de dados da linha 9 por algum motivo, a escrita efetuada em $O$ na linha 8 não surtirá efeito. Isso deixa o código mais limpo e claro, exprimindo melhor a intenção do programa.

%Os aspectos semânticos da transação precisam ser validados explicitamente pelo programa. Nesse caso, o valor a ser transferido não pode ser maior do que o valor da conta de origem. Assim, a linha 6 efetua essa comparação e cancela a transação na linha 13 caso não haja saldo suficiente.

\subsection{Extensões}
\label{subsec:extensoes}
A característica tudo-ou-nada das transações convencionais apresenta uma semântica de tratamento de falhas muito simples: se algum erro ocorrer, todas as operações serão canceladas. Essa semântica facilita drasticamente o tratamento de erros pela aplicação, mas pode não ser a melhor forma de lidar com falhas, dependendo da situação.

Algumas aplicações precisam efetuar um controle maior sobre a efetivação ou o cancelamento de transações. Nesse contexto, uma série de extensões e variações do modelo convencional foram criadas ao longo do tempo.

Essas extensões estão descritas sucintamente e de forma não exaustiva nesta seção.

\subsubsection*{Pontos de salvamento}
Esse tipo de transação permite a especificação de pontos de salvamento (\emph{savepoint}) para demarcar momentos no tempo ao longo da execução da transação.

Esses pontos de salvamento são unicamente identificados e é possível solicitar o cancelamento da transação até um desses pontos. Dessa forma é possível cancelar apenas uma parte das operações e continuar a execução a partir do ponto especificado.

Isso fornece maior flexibilidade na composição e no desenvolvimento da transação, mas a semântica de tratamento de erros passa ser uma pouco mais complexa do que em uma transação convencional.

Os pontos de salvamento são voláteis, e qualquer falha durante a execução da transação irá causar a perda deles. O cancelamento será feito em toda a transação e ela precisará ser reinciada do início.

\subsubsection*{Transações encadeadas}
Esse tipo de transação estende a idéia de pontos de salvamento, trocando os pontos por efetivações. A idéia é permitir efetivar a transação aos poucos, evitando a perda que pode ocorrer com a utilização dos pontos de salvamento, mas mantendo o contexto transacional.

Isso forma um encadeamento de transações que representa passos em uma transação maior. Por fim, o que ocorre é similar a uma transação de transações.

Por outro lado, como é efetuada uma efetivação, a única possibilidade de cancelamento é da transação atual no fim da cadeia. No caso de pontos de salvamento, é possível voltar para qualquer um dos pontos salvos. Novamente, essa flexibilidade pode ocasionar perda de operações.

\subsubsection*{Transações aninhadas}
Transações aninhadas são uma generalização da idéia de pontos de salvamento. Enquanto nesse tipo de transação permitem organizar uma transação como uma sequência de ações que podem ser canceladas individualmente, as transações aninhadas formam uma hierarquia de unidades de trabalho.

Cada subtransação nesse hierarquia é uma nova transação, com as propriedades de atomicidade, consistência e isolamento, que pode ser completamente efetivada ou cancelada. 

A efetivação de uma subtransação torna as modificações efetuadas por ela visíveis apenas para a transação imediatamente superior na hierarquia. A efetivação total é efetuada quando a transação no nível mais alto da hierarquia for efetivada.

Da mesma forma, o cancelamento de uma transação irá ser propagado e, por consequência, cancelará todas as transações hierarquicamente subordinadas a ela.

\subsubsection*{Transações distribuídas}
Uma transação distribuída é uma transação convencional que executa em um ambiente distribuído e por isso visita vários nós.

Enquanto nas transações aninhadas as transações são decompostas de forma funcional, uma transação distribuída é decomposta de acordo com a distribuição dos dados na rede.

Essa decomposição em subtransações não reflete a hierarquia estrutural dos programas a serem executados, mas sim a localização dos dados dentro da rede. Essas subtransações representam mais fatias em que a transação principal foi cortada do que uma subdivisão funcional da transação principal.

A efetivação ou o cancelamento das subtransações não pode ser feito de forma individual. Todas as substranções precisam chegar a um consenso sobre qual deve ser a ação a ser executada na finalização da transação.

\subsubsection*{Transações multinível}
Esse tipo de transação é uma forma mais liberal e genérica de transação aninhada.

Com as transações multinível é possível pré-efetivar uma subtransação, excluíndo a possibilidade de um cancelamento unilateral de atualizações.

Aqui, é assumida a existência de transações compensatórias, que são capazes de reverter semanticamente as alterações efetuadas por uma subtransação/transação no caso de a transação pai ser cancelada. 

\chapter{Minitransação}
\label{chap:minitransacao}
%Este capítulo apresenta o conceito de minitransação como uma forma de tornar explícitos os aspectos semânticos de uma transação. 

Embora originalmente proposta como uma otimização do protocolo de efetivação em duas fases (\emph{2PC}, \emph{Two-Phase Commit}), nosso trabalho aborda o conceito de minitransação como uma forma de representar uma transação de maneira a explicitar os seus aspectos semânticos.

A seção \ref{sec:aspectos_operacionais_e_semanticos} aborda os aspectos sob os quais podemos analisar uma transação e apresenta a diferença entre os aspectos operacionais e semânticos de uma transação.

A seção \ref{sec:minitransacao_original} fala sobre a definição original de minitransação e sua origem a partir de otimizações no \emph{2PC}.

A seção \ref{sec:formalizacao} apresenta a formalização da definição de minitransações com uma abor as vantagens dessa forma de utilizá-las e restrições 

%Na seção \ref{sec:minitransacao} o conceito de minitransação é definido formalmente

%Uma minitransação permite expressar de maneira explícita os aspectos semânticos de uma transação. A seção \ref{sec:formalizacao} apresenta uma conceitação mais formal de uma minitransação.


%Este capítulo apresenta a motivação para o uso de transações em aplicações (Seção \ref{sec:transacoes}), ilustrando os exemplos com alguns algoritmos simples. Naturalmente estendemos o conceito de transação para envolver mais de uma máquina, o que nos leva às transações distribuídas e ao problema de efetivar uma transação desse tipo (Seção \ref{sec:transacoes_distribuidas}), onde descrevemos também o protocolo de efetivação em duas fases, de ampla utilização. Por fim é apresentado o conceito de minitransação (Seção \ref{sec:minitransacoes}), uma extensão do protocolo de efetivação em duas fases que oferece melhor desempenho e escalabilidade ao mesmo tempo que garante atomicidade de operações em transações distribuídas.

\section{Aspectos operacionais e semânticos de uma transação}
\label{sec:aspectos_operacionais_e_semanticos}
%Uma transação agrupa operações que atuam sobre o estado do sistema. Esse agrupamento

Nós podemos dividir as operações de uma transação em dois grupos: modificação e consulta. Operações de modificação alteram o estado do sistema, seja introduzindo novos dados ou modificando dados já existentes. Operações de consulta permitem que a aplicação observe o estado do sistema (na verdade, o que a aplicação ve é uma fotografia do estado no momento em que a transação iniciou).

Esse agrupamento das operações é importante pois os dois grupos resultantes possuem objetivos diferentes e, por consequência, possuem influências diferenciadas sobre a execução da transação. A possibilidade de misturar esses dois tipos de operações em um só transação influencia também a maneira como os ambientes de execução implementam a execução dessas transações.

Operações com caráter de modificação são as responsáveis por introduzir no estado do sistema os resultados da transação. O efeito produzido por essas operações é que deve ser isolado de transações concorrentes até o momento da efetivação da transação, e as modificações produzidas por essas operações é que devem ser descartadas no caso do cancelamento da transação. 

As operações de consulta permitem à aplicação obter acesso ao estado do sistema, utilizando os dados obtidos para efetuadas verificações sobre o estado do sistema. Esses dados podem ser utilizados também como base para modificar o estado do sistema.

Não há nenhuma regra que obrigue limitar ou ordenar o número ou a sequência em que esses dois tipos de operações podem ser utilizadas em uma transação. Como essas operações são agrupadas e ordenadas fica totalmente a cargo desenvolvedor da aplicação. Essa generalidade, aliada à simplicidade no tratamento de erros, oferecida pela transação é o que a torna uma ferramenta de grande utilidade para o desenvolvimento de aplicações.

Ao utilizar uma transação, só há três possíveis cenários de finalização: efetivação, cancelamento explícito ou cancelamento automático. Esse número enxuto facilita projetar as aplicações, pois oferecem uma maneira simplificada e ao mesmo tempo completa de agrupar as operações em unidades lógicas.

Esses três cenários estão ilustrados na figura \ref{fig:cenarios_finalizacao}. A aplicação pode solicitar tanto a efetivação quanto o cancelamento (casos \textbf{a} e \textbf{b} da figura). Em qualquer um desses casos, essa solicitação indica também o final da transação. O caso \textbf{c} da figura acontece quando ocorre um erro durante a execução da transação, implicando em seu cancelamento automático.

\begin{figure}
  \centering
  \includegraphics[width=\textwidth]{cenarios_finalizacao} 
  \caption{Cenários de finalização de uma transação}
  \label{fig:cenarios_finalizacao} 
\end{figure}

A efetivação é o caminho natural a ser seguido. A maneira como as operações são utilizadas e como os dados são tratados é sempre planejada de forma a resultar em naturalmente na efetivação da transação.

A atomicidade gera a necessidade do cancelamento automático, evitando que erros ocorridos durante a execução de uma transação faz o estado do sistema refletir parcialmente os resultados de uma transação.

O cancelamento explícito da transação representa um caso de exceção. O intuito inicial de qualquer transação é ser efetivada, e o seu cancelamento por parte da aplicação significa que alguma situação não esperada foi encontrada durante a execução dessa transação.

\begin{algorithm}
\caption{Transferência de valores com cancelamento explícito (reprodução)}
\label{alg:transferencia_transacao_3}
\Inicio{
	$IniciarTransacao$\;
	$V \gets \text{Valor a transferir}$\;
	$X \gets X - V$\;
	\eSe{$X < 0$}
	{
		$CancelarTransacao$\;
	}
	{
		$Y \gets Y + V$\;
		$EfetivarTransacao$\;
	}
}
\end{algorithm}

Por exemplo, o algoritmo \ref{alg:transferencia_transacao_3} (que reproduz o algoritmo \ref{alg:transferencia_transacao_2} aqui por questões de clareza) apresenta um exemplo de cancelamento explícito. Como podemos ver, esse cancelamento ocorre por que o valor de $X$ ficou negativo, ou seja, a decisão sobre o cancelamento da transação foi feita com base na verificação do estado do sistema.

Os cancelamentos explícitos apresentam a característica descrita acima: são baseados em verificações a respeito do estado da aplicação. Assim, no caso do algoritmo \ref{alg:transferencia_transacao_3}, a operação de consulta $X < 0$ é que determina o cancelamento ou efetivação da transação.

Portanto, além de classificar as operações como sendo de modificação ou consulta, podemos diferenciá-las em relação ao seu caráter operacional ou semântico na transação.

Uma operação com caráter operacional é aquela que não participa na decisão sobre o cancelamento explícito de uma transação. Note que a operação pode ainda sim ocasionar um cancelamento automático, caso a sua execução gere um erro no ambiente. Porém, a classificação é em relação ao cancelamento explícito da transação. Tanto operações de modificação quanto de consulta podem ser classificadas como operacionais.

Operações de caratér semântico são aquelas que influciam a decisão sobre um cancelamento explícito da transação. Somente operações de consulta podem ser consideradas de caráter semântico.

Ao analisar o algoritmo \ref{alg:transferencia_transacao_3}, poderíamos considerar que a operação $X \gets X - V$ é de caráter semântico. Afinal de contas, é essa a única operação que pode levar a condição $X < 0$ a ser verdadeira. Embora isso seja verdade, a influência dessa operação sobre a decisão não é absoluta. Considere por exemplo o algoritmo \ref{alg:transferencia_transacao_4}.

\begin{algorithm}
\caption{Transferência de valores com cancelamento explícito modificado}
\label{alg:transferencia_transacao_4}
\Inicio{
	$IniciarTransacao$\;
	$V \gets \text{Valor a transferir}$\;
	\eSe{$X < V$}
	{
		$CancelarTransacao$\;
	}
	{
		$X \gets X - V$\;
		$Y \gets Y + V$\;
		$EfetivarTransacao$\;
	}
}
\end{algorithm}

Como podemos ver no algoritmo \ref{alg:transferencia_transacao_4}, a operação de modificação $X \gets X - V$ deixou de influenciar a decisão sobre o cancelamento. Essa modificação deixa claro que a operação de modificação não possui caráter semântico.

\begin{algorithm}
\caption{Transferência de valores com saldo negativo}
\label{alg:transferencia_transacao_5}
\Inicio{
	$IniciarTransacao$\;
	$V \gets \text{Valor a transferir}$\;
	\eSe{$X < V$}
	{
		$X_n \gets X_n + (V - X)$\;
		\Se{$X_n > L_X$}
		{
			$CancelarTransacao$\;
		}
		$X \gets 0$\;
	}
	{
		$X \gets X - V$\;
		$Y \gets Y + V$\;
	}
	$EfetivarTransacao$\;
}
\end{algorithm}

Da mesma forma, nem toda operação de consulta possui caráter semântico. Por exemplo, o algoritmo \ref{alg:transferencia_transacao_5} apresenta uma outra variação do algoritmo de transferência, que permite controlar o saldo negativo de uma conta. Agora, $X_n$ representa o saldo negativo da conta $X$, e esse saldo pode ser no máximo um limite definido previamente $L_X$. A comparação $X < V$ deixou de ter caráter semântico, pois não participa na decisão sobre o cancelamento da transação diretamente.

A classificação em relação ao caráter operacional ou semântico envolve uma análise da intenção e da composição da transação.
Embora a relação entre a operação e o cancelamento exista, esse relação se dá no nível da intenção do desenvolvedor, e não está explícita na transação.

Uma \textbf{minitransação} é uma maneira de representar uma transação de forma a separar explicitamente os aspectos semânticos e operacionais de uma transação. Essa separação permite analisar e entender melhor o objetivo da transação, podendo ser utilizada para otimizações.

%Falhas de aspecto operacional estão relacionadas a problemas, permanentes ou transitórios, encontrados nos sistemas de base utilizados pelo ambiente de execução, como sistema operacional, redes ou hardware. Trilhas danificadas no disco rígido, perda de comunicação entre máquinas, quedas no fornecimento de energia são alguns exemplos, assim como danos físicos no cabeamento de rede ou o extravio de uma máquina.

%Essas falhas de aspecto operacional estão fora do controle do desenvolvedor, mas podem ser manipuladas diretamente pelo ambiente de execução. Em geral, o cancelamento da transação e uma nova execução em um momento futuro podem corrigir o problema, como no caso de falhas transitórias. Falhas permanentes exigem a manutenção dos elementos afetados, mas uma vez corrigidas, uma nova execução da transação será bem-sucedida.

%Falhas de aspecto semântico são dependentes do domínio da aplicação e precisam ser garantidas pelo desenvolvedor. Elas estão relacionadas a violações das invariantes definidas sobre o estado da aplicação e não podem ser diretamente tratadas pelo ambiente de execução. O desenvolvedor deve verificar essas invariantes e efetuar o cancelamento da transação caso necessário.

%\section{Representação dos aspectos semânticos em uma transação}
%\label{sec:representacao_aspectos}

\section{Definição original}
\label{sec:minitransacao_original}
A definição original de minitransação é apresentada em um trabalho de Aguilera et al. \cite{sinfonia}. Nesse trabalho, os autores efetuam algumas observações sobre o protocolo \emph{2PC}, de forma a obter uma otimização desse protocolo. 

Essa otimização visa a diminuição na quantidade de mensagens utilizadas para efetuar o \emph{2PC}, com o intuito de criar um ambiente de execução transacional para aplicações com requisitos de performance rígidos, como gerenciadores de sistemas de arquivos distribuídos, por exemplo. 

Na subseção \ref{subsec:transacoes_distribuidas} nós apresentamos uma descrição mais detalhada das transações distribuídas do que a apresentada em \ref{subsec:extensoes}.

A subseção \ref{subsec:2pc} descreve os detalhes do protocolo de efetivação em duas fases, utilizado para coordenar a efetivação de transações distruídas.

Em \ref{subsec:modificacao_2pc} é explicado de que maneira os autores originais modificaram o \emph{2PC}, criando o protocolo de minitransações.

\subsection{Transações distribuídas}
\label{subsec:transacoes_distribuidas}
Uma transação distribuída é uma transação convencional que é executada em um ambiente de execução distribuído, envolvendo diversas máquinas (nós) que coletivamente gerenciam o estado da aplicação. Em cada um desses nós é encontrado um gerenciador de recursos, responsável por gerenciar o subconjunto do estado da aplicação naquele nó, executando os comandos da transação distribuída que acessam ou modificam esse subconjunto.

\begin{figure}
  \centering
  \includegraphics[width=0.4\textwidth]{transferencia_valores_distribuido} 
  \caption{Transferência de valores em um ambiente de execução distribuído}
  \label{fig:transferencia_valores_distribuido} 
\end{figure}

Na figura \ref{fig:transferencia_valores_distribuido} apresentamos uma visualização da execução do algoritmo \ref{alg:transferencia_transacao_4} em um ambiente distribuído. O valor da conta $X$ está armazenado no nó A, e o valor da conta $Y$ está armazenado no nó B.

Uma transação distribuída é composta por subtransações que executam em cada um dos nós envolvidos na transação. Como podemos ver na figura \ref{fig:transferencia_valores_distribuido}, a transação \textbf{T} criada para efetuar a transferência cria duas subtransações, \textbf{SA} e \textbf{SB}, nos nós \textbf{A} e \textbf{B}, respectivamente.

Essas subtransações são como transações convencionais executando nos nós envolvidos. Elas representam trechos da transação original, só fazem sentido no contexto dessa transação. A efetivação ou o cancelamento da transação original \textbf{T} implica na mesma finalização em cada uma das subtransações. Da mesma forma, não é possível que uma subtransação seja cancelada sem que a transação original seja cancelada também.

Como as subtransações são transações convencionais executando nos nós participantes, não existe diferença nos mecanismos utilizados na execução da transação descritos no capítulo anterior. A diferença se apresenta no momento da finalização da transação.

Para efetuar a efetivação da transação é preciso que todos os nós participantes concordem com tal finalização. Se algum deles não puder efetuar a efetivação, seja por qualquer problema, a transação, e nenhuma das suas subtransações, poderá ser efetivada. 

A decisão pela efetivação deve ser unânime, para preservar as propriedades \emph{ACID} da transação. Na subseção \ref{subsec:2pc} será descrito um protocolo para garantir a efetivação em um ambiente de execução distribuído.

\subsection{O protocolo de efetivação em duas fases}
\label{subsec:2pc}
O protocolo de efetivação em duas fases, ou 2PC (\emph{two-phase commit}, \cite{2pc}), é o protocolo padrão utilizado para coordenar a finalização de transações distribuídas.

Quando a aplicação termina de executar todos os comandos da transação, ela solicita ao ambiente de execução que essa transação seja efetivada. Nesse momento é executado o 2PC para verificar se todos os participantes estão aptos a efetivar suas respectivas subtransações.

Caso todos os participantes respondam confirmando a efetivação, todos os outros serão notificados e a transação termina. Se algum dos participantes não responder, ou responder negativamente, indicando que não pode efetivar a subtransação, todos os nós participantes são notificados e a transação e suas subtransações são canceladas.

Assim, esse protocolo é executado em duas rodadas, ou fases, para verificar a ação a ser tomada na finalização da transação. A primera rodada é a votação, que questiona os participantes se a subtransação pode ser efetivada. A segunda rodada, de notificação, é utilizada para comunicar aos participantes a decisão tomada por todos.

\begin{figure}
  \centering
  \includegraphics[width=.50\textwidth]{fase_votacao_2pc} 
  \caption{Fase de votação do 2PC - o coordenador verifica se cada participante pode efetivar}
  \label{fig:fase_votacao_2pc} 
\end{figure}

A figura \ref{fig:fase_votacao_2pc} ilustra a primeira fase do protocolo. Como pode ser visto, o 2PC estabelece o papel de um \textbf{coordenador}, um elemento do ambiente de execução que irá coordenar a execução do protocolo e decidirá qual deve ser o tipo de finalização da transação. Na figura o coordenador está logicamente separado da aplicação e dos nós participantes, mas fisicamente ele pode estar rodando em qualquer nó do ambiente, inclusive em algum participante ou na própria aplicação.

Cada nó participante irá verificar se a subtransação associada à transação T pode ser efetivada. Alguns ambientes de execução podem postergar para o momento da efetivação checagens de invariantes. Por exemplo, SGBD's podem optar por efetuar a validação de restrições (\emph{constraints}) sobre os dados alterados para o momento da efetivação, por questões de performance. Se as invariantes forem válidas, e nenhum outro tipo de problema ocorrer, o participante responderá votando pela efetivação da transação. Se alguma variante for violada, ou se algum erro ocorrer, o participante responderá votando pelo cancelamento da transação.

\begin{figure}
  \centering
  \includegraphics[width=\textwidth]{fase_votacao_2pc_respostas} 
  \caption{Fase de votação do 2PC - resposta dos participantes}
  \label{fig:fase_votacao_2pc_respostas} 
\end{figure}

Na figura \ref{fig:fase_votacao_2pc_respostas} estão ilustradas as quatro combinações possíveis de resposta que os participantes podem enviar para o coordenador. No item \textbf{a} da figura todos os participante confirmam a efetivação de suas subtransações. O coordenador recolhe todas as respostas e verifica que, como todas foram positivas, a transação pode ser efetivada.

Os items \textbf{b} e \textbf{c} ilustram os casos em que um dos participantes não podem efetivar a sua respectiva subtransação (devido a violações das invariantes ou outra falha ocorrida), e o item \textbf{d} mostra o caso em que nenhum participante pode efetuar a efetivação. O coordenador recebe as respostas e, como uma delas (ou todas) foram negativas, ele não pode efetivar a transação. Portanto, a única ação a ser tomada é o cancelamento.

Finalizada a fase de votação e decidida a ação a ser efetuada para finalizar a transação, o coordenador inicia a segunda fase do protocolo, de notificação. O cordenador registra a ação escolhida em seu \emph{log}, e garante que esse registro seja gravado em algum meio de armazenamento não volátil. Isso ocorre por que o coordenador é a autoridade final para dizer se a transação foi efetivada ou cancelada. 

Uma vez que o coordenador tenha registrado em seu \emph{log} que a transação foi efetivada ou cancelada, qualquer falha posterior, tanto no coordenador quanto nos participantes, não pode mudar essa decisão. Após a informação sobre o cancelamento ou efetivação da transação ser armazenada definitivamente, o coordenador notifica os participantes do resultado da votação, e retorna à aplicação esse resultado.

\begin{figure}
  \centering
  \includegraphics[width=\textwidth]{fase_notificacao_2pc} 
  \caption{Fase de notificação do 2PC}
  \label{fig:fase_notificacao_2pc} 
\end{figure}

A figura \ref{fig:fase_notificacao_2pc} apresenta uma ilustração da execução da segunda fase do protocolo no caso de efetivação (o procedimento é análogo para o cancelamento). O item \textbf{a} da figura mostra o registro da efetivação da transação no \emph{log} do coordenador. O coordenador precisa garantir que essa informação foi salva permanentemente antes de prosseguir para a notificação dos participantes, no item \textbf{b}. Após notificar os participantes, o coordenador retorna para a aplicação, informando que a transação foi efetivada (item \textbf{c}). 

%A idéia desse protocolo é simples e utilizada a bastante tempo \cite{2pc}: verificar se todos os gerenciadores de recurso envolvidos em uma transação estão aptos a efetivar suas respectivas sub-transações. Se estiverem, a transação será efetivada. Se algum gerenciador não puder efetivar, por qualquer motivo, a transação será abortada. O \emph{2PC} necessita de um gerenciador que atue como o \textbf{coordenador} da transação, responsável por gerenciar a execução do protocolo e tomar a decisão sobre efetivar ou abortar a transação comunicando-se com os outros \textbf{participantes}, que executam as sub-transações associadas à transação. O coordenador pode ser um participante da transação também.

%O protocolo é dividido em duas fases. Na primeira fase o coordenador solicita que os participantes enviem seus votos, indicando se estão aptos a efetivar a sub-transação executada. Os votos são coletados e o coordenador decide se a transação pode ser efetivada (caso todos os participantes tenham votado de acordo) ou se deve ser abortada (caso algum participante tenha votado para não efetivar a transação). Decidido o resultado da votação, o coordenador efetua a segunda fase, em que os participantes são notificados do resultado da votação. 

%De forma mais detalhada, o \emph{2PC} pode ser descrito pelos algoritmos \ref{alg:2pc_coordenador}, \ref{alg:2pc_participante1} e  \ref{alg:2pc_participante2}. O Algoritmo \ref{alg:2pc_coordenador} descreve as ações do coordenador ao ser notificado que o protocolo deve  iniciar. Os algoritmos \ref{alg:2pc_participante1} e \ref{alg:2pc_participante2} descrevem as ações executadas pelos participantes ao receberem uma solicitação de votação (primeira fase) e o resultado da votação (segunda fase), respectivamente. 

%Uma estrutura de dados essencial na execução do \emph{2PC} é o registro de operações, ou \emph{log}. Ele é responsável por registrar as decisões do coordenador e dos participantes, e é gravado localmente em cada gerenciador de recursos envolvido na transação para evitar que essas informações sejam perdidas caso ocorra alguma falha. No Algoritmo \ref{alg:2pc_coordenador} $log_c$ representa o \emph{log} do coordenador e nos algoritmos \ref{alg:2pc_participante1} e \ref{alg:2pc_participante2} $log_i$ é o \emph{log} do participante $p_i$ executando o algoritmo em questão.

%A função $Adicionar$ representa a operação de adicionar um elemento ao final do \emph{log}. A função $Enviar(d, m)$ representa o envio de uma mensagem $m$ para um destinatário $d$ pela rede de comunicação, e a função $Receber(r)$ representa o recebimento de uma mensagem de um remetente $r$. Uma simulação da execução do algoritmo pode ser vista nas figuras \ref{fig:2PC_1fase} e \ref{fig:2PC_2fase}.

%\begin{algorithm}
%\caption{Coordenador 2PC}
%\label{alg:2pc_coordenador}
%\Inicio{
%    $Adicionar(log_c, (PREPARAR, T))$\;
%    \ParaTodo{$p_i \in Participantes$}
%    {
%    	$Enviar(p_i, (PREPARAR, T))$\;
%    }
%    $d \gets EFETIVAR$\;
%    \ParaTodo{$p_i \in Participantes$}
%    {    
%        $v \gets Receber(p_i)$\;
%        \Se{$v = ABORTAR$}
%        {
%            $d \gets ABORTAR$\;
%        }
%    }
%    $Adicionar(log_c, (d, T))$\;
%    \ParaTodo{$p_i \in Participantes$}
%    {
%    	$Enviar(p_i, (d, T))$\;
%    }
%}
%\end{algorithm}

%\begin{algorithm}
%\caption{Votação 2PC - $p_i$ recebe $(PREPARAR, T)$ de $c$}
%\label{alg:2pc_participante1}
%\Inicio{
%    $v \gets Decidir(T)$\;
%    $Adicionar(log_i, (v, T))$\;
%    $Enviar(c, v)$\;
%}
%\end{algorithm}

%\begin{algorithm}
%\caption{Notificação 2PC - $p_i$ recebe $(d, T)$ de $c$}
%\label{alg:2pc_participante2}
%\Inicio{
%    \eSe{$d = EFETIVAR$}
%    {
%        $Efetivar(T)$\;
%        $Adicionar(log_i, (EFETIVAR, T))$\;
%    }
%    {
%    	$Abortar(T)$\;
%    	$Adicionar(log_i, (ABORTAR, T))$\;
%    }
%}
%\end{algorithm}

%A premissa que norteia o protocolo é que qualquer gerenciador envolvido na transação pode decidir abortá-la de forma unilateral, ou falhar em executar uma sub-transação, exigindo assim unanimidade na decisão pela efetivação da transação. As mensagens enviadas durante a execução do protocolo indicam uma decisão do remetente, e para garantir que essa decisão sobreviva a falhas no gerenciador que enviou a mensagem, os dados do \emph{log} são gravados em um meio de armazenamento estável, como um disco rígido, antes da  mensagem ser enviada. A transação $T$ é considerada oficialmente efetivada (ou abortada) no momento que o registro de $(EFETIVAR, T)$ (ou $(ABORTAR, T)$) do \emph{log} do coordenador for escrito para a área de armazenamento estável da máquina. Falhas posteriores não podem mudar a decisão do coordenador registrada em seu \emph{log} e gravada em disco.

%\begin{figure}
%  \centering
%  \includegraphics[width=.40\textwidth]{2PC_1fase} 
%  \caption{Primeira fase 2PC - O coordenador inicia a votação e os participantes respondem com seus votos $V_i$}
%  \label{fig:2PC_1fase} 
%\end{figure}

%\begin{figure}
%  \centering
%  \includegraphics[width=.40\textwidth]{2PC_2fase} 
%  \caption{Segunda fase 2PC- O coordenador apura os votos e notifica os participantes. Em (a) os participantes são notificados de uma efetivação. Em (b), a transação foi abortada.}
%  \label{fig:2PC_2fase} 
%\end{figure}

%É importante notar que esse protocolo não define como as operações da transação devem ser executadas nas máquinas participantes, mas sim como a efetivação da transação deve proceder. As sub-transações ocorrem em cada participante antes que o protocolo de efetivação inicie. Portanto, a utilização desse protocolo aumenta o número de mensagens e consequentemente o tempo e o esforço necessários para que uma transação seja executada. Algumas otimizações podem ocorrer, como no caso de transações que efetuam somente operações de leitura ou de transações que envolvam dados em somente uma máquina do sistema mas, de forma geral, a execução do \emph{2PC} é custosa \cite{gray-lamport}.

%*** TODO página 562 e 643 do gray 

\subsection{Modificação do 2PC}
\label{subsec:modificacao_2pc}
O trabalho descrito em \cite{sinfonia} altera a maneira como a transação e o protocolo 2PC são executados, utilizando a primeira fase do 2PC para executar as operações da transação. Embora esse trabalho não faça referência explícita aos aspectos operacionais e semânticos de uma transação, a modificação efetuada por eles acaba por utilizar o conceito desses aspectos para obter um mecanismo de execução que tire vantagem do aspecto semântico das transações.

Em primeiro lugar, Aguilera et al. notaram que o cancelamento explícito de uma transação depende somente de operações de consulta, como foi detalhado em \ref{sec:aspectos_operacionais_e_semanticos}. Dessa forma, se uma transação fosse composta somente por operações de modificação, essas operações poderiam ser enviadas aos nós participantes dessa transação na primeira fase do 2PC, em uma só mensagem pela rede. Qualquer erro que ocorresse na execução dessas operações faria com que o participante respondesse negativamente à votação, cancelando a transação.

No caso de transações que contém somente operações de modificação, a intenção explícita da aplicação é efetivar a transação. Como nenhum dado foi lido, entende-se que a intenção da aplicação é simplesmente alterar o estado do sistema, sem nenhum condicionamento. Assim, a efetivação é o resultado natural dessas transações, e o participante da transação sabe que essa transação será efetivada.

A intenção dos autores era empacotar todas as operações da transação na mensagem enviada na primeira fase do 2PC pelo coordenador para os participantes. No entanto, as operações de consulta não poderiam sempre ser enviadas dessa maneira, pois devido ao caráter semântico que podem assumir, o resultado de sua execução pode ser necessário para a aplicação decidir se a transação precisa ser cancelada explicitamente. Isso faz com que um participante da transação tenha que aguardar a aplicação utilizar a informação lida e decidir se vai efetivar a transação ou não.

Porém, se o participante da transação souber como esses dados serão utilizados pela aplicação, ele mesmo poderá efetuar a comparação e verificar, durante a própria execução da operação, se a aplicação iria solicitar um cancelamento ou não da transação.

%Por exemplo, considerando novamente um programa executando o algoritmo descrito em \ref{alg:transferencia_transacao_4}, se o Nó \textbf{A}, que armazena o valor $X$, pudesse efetuar a comparação $X < V$, ele poderia de antemão saber que a transação seria cancelada.

O que o trabalho descrito em \cite{sinfonia} fez foi dotar os nós participantes da transação com a capacidade de efetuar comparações que a aplicação efetuaria com o resultado de uma operação de consulta. Com isso, eles foram capazes de enviar tanto os comandos com caráter operacional quanto os comandos com caráter semântico na mensagem da primeira fase do 2PC.

Essa maneira de executar as operações de uma transação de uma só vez na primeira fase do protocolo 2PC foi chamada de \textbf{minitransação}. O protocolo resultante dessa modificação do 2PC foi utilizado para implementar o \emph{Sinfonia}, explicado brevemente em seguida.

Como veremos também, as minitransações oferecidas pelo Sinfonia possuem um escopo de utilização limitado devido ao tipo de comparação que conseguem efetuar. O escopo dessas comparações atende ao requisitos do Sinfonia mas, como veremos, ele é muito limitante. A definição e a implementação apresentadas neste trabalho aumentam esse escopo e, portanto, a abrangência do uso de minitransações.

\subsection{Sinfonia}
Sinfonia é um serviço distribuído que permite o armazenamento de dados em um ambiente tolerante a falhas, escalável e consistente. O foco do sinfonia é prover a execução transacional de operações sobre esses dados para o que os autores chamam de aplicações de infraestrutura de centrais de dados (\emph{data center infrastructure applications}) como sistemas de arquivos distribuídos, gerenciadores de travas e serviços de comunicação de grupos de aplicações. Essas aplicações precisam ser tolerantes a falha e escaláveis, além de quase sempre precisarem oferecer consistência aos seus usuários e performance em um nível razoável.

Esse serviço procura oferecer um balanceamento entre funcionalidade e escalabilidade. A chave para alcançar escalabilidade é separar operações executadas por diferentes nós o máximo possível, de tal forma que essas operações possam ser executadas de maneira independente. Para oferecer essa escalabilidade, o Sinfonia oferece um espaço de endereçamento bem granularizado para acessar os dados armazenados, sem impor nenhum tipo de estrutura, ficando a cargo da aplicação organizar os dados da maneira mais conveniente.

O Sinfonia oferece uma primitiva de minitransação que as aplicações podem utilizar para acessar e modificar os dados, de maneira atômica e condicional, em diversos \textbf{nós de memória}. Além disso, as aplicações utilizam uma biblioteca de interface para efetuar a execução das minitransações. Essa biblioteca é responsável por coordenar a execução da minitransação entre os diversos nós de memória participantes, e assume assim o papel de coordenador descrito no 2PC.

\begin{figure}
  \centering
  \includegraphics[width=\textwidth]{sinfonia} 
  \caption{Estrutura do Sinfonia}
  \label{fig:sinfonia} 
\end{figure}

A figura \ref{fig:sinfonia} ilustra a divisão entre a aplicação e a biblioteca de interface e os nós de memória, que compõem o Sinfonia. A aplicação utiliza somente as funcionalidades disponibilizadas pela biblioteca de interface. Essa fica responsável por encapsular o ambiente distribuído do Sinfonia e gerenciar a execução do protocolo que executa e finaliza as minitransações.

Os nós de memória armazenam os dados e são responsáveis pela execução das operações que compõem a minitransação. Cada nó de memória mantém uma sequência opaca de palavras de memória com algum comprimento padrão (a implementação descrita utiliza 1 \emph{byte} como comprimento). 

Esses bytes são organizados como um espaço de endereçamento linear sem nenhuma estrutura. Cada nó de memória possui um espaço de endereçamento separado. Portanto, qualquer dado no Sinfonia é referenciado por meio de um par contendo o identificador do nó de memória e o endereço do byte a ser acessado.

O formato das minitransações utilizadas para acessar e modificar os dados e a maneira como elas são executadas no Sinfonia estão descritos a seguir.

\subsection{Minitransações no sinfonia}
\label{subsec:minitransacoes_sinfonia}
As minitransações oferecidas pelo Sinfonia possuem uma estrutura composta por três tipos de operações, como ilustrado na figura \ref{fig:minitransacao_sinfonia}.

\begin{figure}
  \centering
  \includegraphics[width=0.4\textwidth]{minitransacao_sinfonia} 
  \caption{Estrutura das minitransações do Sinfonia}
  \label{fig:minitransacao_sinfonia} 
\end{figure}

Os campos do comando de comparação estão descritos a seguir:

\begin{itemize}
	\item \textbf{Id-Nó}: identificador do nó de memória
	\item \textbf{Endereço}: número do byte no espaço de endereçamento do nó identificado por \textbf{Id-Nó}
	\item \textbf{Tamanho}: especifica quantos bytes, a partir de \textbf{Endereço}, devem ser comparados
	\item \textbf{Dados}: é uma sequência de \textbf{Tamanho} bytes com a qual o conteúdo do nó será comparado
\end{itemize}

Nos campos do comando de escrita e leitura os campos \textbf{Id-Nó} e \textbf{Endereço} possuem a mesmo significado que os do comando de comparação. O significado de \textbf{Tamanho} e \textbf{Dados} nos comandos de leitura e escrita está apresentado a seguir:

\begin{itemize}
	\item \textbf{Tamanho} identifica quantos bytes devem ser lidos, no caso de leitura, ou modificados, no caso de escrita
	\item \textbf{Dados} é uma sequência de \textbf{Tamanho} bytes que deve ser gravado a partir do byte identificado por \textbf{Endereço}. Esse campo é sempre vazio nos comandos de leitura
\end{itemize}

A comparação efetuada pelo Sinfonia e da igualdade byte a byte, ou seja, o conteúdo armazenado no nó será comparado byte a byte com o valor especificado em \textbf{Dados}. O comando de leitura especifica um bloco de dados a ser retornado e o comando de escrita especifica um bloco de dados a ser modificado.

A execução de uma minitransação segue os seguintes passos:

\begin{enumerate}
	\item As comparações são efetuadas, uma a uma.
	\item Se alguma comparação falhar, o nó de memória irá cancelar a subtransação e responder para o coordenador indicando que a minitransação precisa ser cancelada.
	\item Se todas as comparações forem bem sucedidas, o nó de memória irá ler todos os blocos especificados pelas operações de leitura e modificar todos blocos especificados pelas operações de escrita.
	\item O nó de memória irá responder para o coordenador indicando que a minitransação pode ser efetivada. Nessa resposta são retornados também todos os blocos lidos.
\end{enumerate}

Essa é a primeira fase do protocolo, que nesse caso é chamada de fase de execução. A fase de notificação é análoga à do 2PC, em que o coordenador recebe todas as respostas dos nós participantes e calcula qual será a finalização da minitransação.

Todos os mecanismos descritos anteriormente são utilizados, como o \emph{log} para registrar as atividades da transação e as travas para garantir o isolamento entre as minitransações.

%Sendo uma extensão do \emph{2PC}, o protocolo de minitransações possui também um coordenador responsável por iniciar e gerenciar a execução do protocolo entre os participantes da transação. O protocolo de minitransações é composto também por duas fases, mas agora a primeira fase passa a ser uma fase de execução, em que as minitransações são executadas em cada participante e seus votos são enviados para o coordenador. O coordenador coleta os votos de todos os participantes e, como no protocolo original, irá decidir por efetivar a transação somente se os votos forem unânimes. Na segunda fase os participantes são notificados da decisão do coordenador e devem atuar de acordo, efetivando as operações da minitransação ou desfazendo suas ações.

%Um operador especial, $Id[X]$, representa o conjunto formado pelo elemento $Id$ de todas as tuplas no formato $(Id, Dado)$ do conjunto $X$. Esse operador permite obter o conjunto $D$ de todos os identificadores utilizados pela minitransação: $D \gets L \cup Id[C] \cup Id[E]$. Cada elemento de $D$ fica sob responsabilidade de um participante $p$ específico da minitransação, e $\forall d \in D$ o participante responsável pelo identificador $d$ é definido por $Participante(d)$, uma função que indica que $p$ é a possível localização de $d$ entre os participantes, uma vez que o identificador $d$ pode ainda não ter sido inserido em $p$.

%O conjunto $Participantes$ é formado por todos os participantes da minitransação. Cada participante $P_j \in Participantes$ possui um conjunto $K_j$ de identificadores sob sua responsabilidade, e para cada participante o coordenador constrói uma nova minitransação \(M_j = (I_t, C_j, L_j, E_j)\) tal que:

%\begin{itemize}
%    \item $I_t \gets IdentificadorUnico(I)$
%    \item $\forall i_l \in L_j, i_l \in K_j$;
%    \item $\forall i_c \in Id[C_j], i_c \in K_j$; e
%    \item $Id[E_j] \supseteq K_j$
%\end{itemize}

%O identificador $I_t$ é unicamente definido e associado ao identificador $I$ por meio da função $IdentificadorUnico$. Como o identificador $I$ é fornecido pela aplicação cliente, nada garante que ele seja único, e por isso utilizamos $IdentificadorUnico$ para criar um novo identificador globalmente único associado à $I$. Os identificadores de $E_j$ são tratados como um superconjunto de $K_j$ pois a operação de escrita pode inserir novos dados no sistema, e não somente alterar dados que já existem.

%Cada $M_j$ é enviada ao respectivo $P_j$ pelo coordenador, que irá esperar pela execução e resposta de cada participante. Ao receber uma minitransação, cada participante irá tentar ler os dados identificados por $Id[C_j]$ e compará-los (comparação de igualdade) com os respectivos $Dado[C_j]$. Caso a comparação não seja bem sucedida, esse participante nem tentará ler ou modificar os dados em $L_j$ e $E_j$, e responderá para o coordenador com um voto $ABORTAR$. A Figura \ref{fig:minitransacao_1fase} ilustra essa primeira fase, que combina a primeira fase do \emph{2PC} com a execução das operações da transação.

%\begin{figure}
%  \centering
%  \includegraphics[width=.65\textwidth]{minitransacao_1fase} 
%  \caption{Fase de execução de uma minitransação}
%  \label{fig:minitransacao_1fase} 
%\end{figure}

%Se a comparação for bem sucedida para todos os elementos de $Id[C_j]$, então o participante irá ler os dados identificados por $L_J$ e agrupá-los no conjunto de resposta $R_j$. Os dados $Dado[E_j]$ identificados por $Id[E_j]$ serão inseridos no conjunto de dados ou irão alterar algum dado já existente. Na verdade, a operação de inserir ou alterar um dado é registrada no \emph{log} do participante. O participante envia então um voto $EFETIVAR$ para o coordenador, junto com o conjunto $R_j$. 

%Ao coletar todas as respostas, o coordenador irá apurar os votos de cada participante. Para cada resposta $EFETIVAR$ o coordenador agrega os respectivos $R_j$ em um conjunto de respostas $R$. Se uma das respostas for $ABORTAR$, a transação precisa ser abortada, notificando os participantes do cancelamento, e a aplicação cliente precisa ser notificada desse erro, como podemos ver na Figura \ref{fig:minitransacao_2fase} \textbf{b}. Se não houve nenhum voto $ABORTAR$, o coordenador decide então por efetivar a transação, enviando o conjunto $R$ para a aplicação cliente e notificando os participantes da efetivação, como ilustrado na Figura \ref{fig:minitransacao_2fase} \textbf{a}.

%\begin{figure}
%  \centering
%  \includegraphics[width=.65\textwidth]{minitransacao_2fase} 
%  \caption{Fase de notificação de uma minitransação}
%  \label{fig:minitransacao_2fase} 
%\end{figure}

%Quando os participantes são notificados do cancelamento da minitransação, as operações de escrita da minitransação presentes no \emph{log} do participante não serão efetuadas, deixando os dados inalterados, e será registrado no \emph{log} que a minitransação foi abortada. Se a notificação for de efetivação, as operações de escrita do \emph{log} serão efetuadas, alterando dados existentes ou inserindo novos dados no participante, e será registrado no \emph{log} que a minitransação foi efetivada. O \emph{log} será gravado em disco e a minitransação será considerada oficialmente efetivada ou abortada no momento que esse registro do \emph{log} estiver gravado em disco.


%Embora não utilizem esses termos, os autores originais efetuam a separação entre o caráter operacional e o caráter semântico das operações de uma transação. Conforme eles notaram, operações de escrita não influenciam na decisão sobre o cancelamento explícito 

%Essa separação os leva a uma estrutura como a descrita na figura \ref{fig:estrutura_minitransacao}.

%\begin{figure}
%  \centering
%  \includegraphics[width=.40\textwidth]{estrutura_original_minitransacao} 
%  \caption{Estrutura original de uma minitransação}
%  \label{fig:estrutura_original_minitransacao} 
%\end{figure}

%O intuito dessa otimização era 

\section{Formalização}
\label{sec:formalizacao}
A definição de minitransação encontrada em \cite{sinfonia} é específica para a implementação no ambiente oferecido pelo Sinfonia, onde uma minitransação é exposta como uma primitva implementada pelo Sinfonia para executar operações atomicamente.

%Essa definição original, apresentada na seção \ref{subsec:minitransacoes_sinfonia}, está intimamente relacionada com o protocolo de execução, de maneira que a separação entre a minitransação e esse protocolo de confundem.

Na seção \ref{subsec:definicao} formalizamos e generalizamos esse conceito de forma que possa ser implementado e utilizado em outros ambientes, independente do protocolo de execução e efetivação.

A seção \ref{subsec:vantagens_e_desvantagens} apresenta uma comparação com o modelo convencional de transação e as vantagens e desvantagens da minitransação, assim como cenários em que podem ser utilizadas.

\subsection{Definição}
\label{subsec:definicao}
Um minitransação é um modelo de representação de uma transação em que os componentes semânticos dessa transação são indicados explicitamente. Esse modelo expõe diretamente os componentes semânticos, que definem condições sob as quais uma transação deve ser cancelada.

Assim, uma minitransação $M$ é um par formado por:

\begin{itemize}
	\item $S$: conjunto de componentes semânticos da transação
	\item $O$: conjunto de componentes operacionais da transação
\end{itemize}

\begin{figure}
  \centering
  \includegraphics[width=0.7\textwidth]{mapeamento_minitransacao} 
  \caption{Modelo de uma minitransação e seu mapeamento para a implementação do Sinfonia}
  \label{fig:mapeamento_minitransacao} 
\end{figure}

A figura \ref{fig:mapeamento_minitransacao} ilustra o modelo de uma minitransação e como esse modelo é mapeado para a implementação de minitransações oferecida pelo Sinfonia. Os componentes operacionais são todos aqueles que não influenciam na decisão da aplicação em efetivar ou não a transação. No caso do Sinfonia, os comandos de leitura e escrita possuem essa característica.

Os componentes semânticos são aqueles que influenciam a aplicação em relação a efetivar ou cancelar a transação. Os comandos de comparação são portanto semânticos, pois é por meio deles que o Sinfonia decide se a transação pode ser efetivada ou não.

\subsection{Vantagens e Desvantagens}
\label{subsec:vantagens_e_desvantagens}
A principal vantagem na utilização de uma minitransação é a separação clara entre os aspectos semânticos e operacionais de uma transação. Essa separação deixa explícita na estrutura da transação quais os componentes que influenciam o resultado de sua execução.

Isso aumenta o grau de manutenibilidade do código da aplicação, uma vez que os componentes semânticos estão agrupados e organizados, e não espalhados pelo código em estruturas condicionais, por exemplo.

Essa separação também permite análises estáticas da aplicação em relação à transação, pois é simples identificar as condições sob as quais a transação será cancelada. Ferramentas de análise de código fonte podem ser utilizadas para obter estatísticas e até mesmo ajudar a otimizar a construção das transações.

Otimizações também são possíveis ao efetuar essa separação, como ocorre com o protocolo 2PC modificado utilizado pelo Sinfonia. 

As desvantagens do modelo de minitransações estão relacionadas ao poder de expressão dos componentes semânticos. Por exemplo, no Sinfonia, o único componente semântico permitido é a operação de comparação de igualdade.

A expressividade desses componentes está relacionada à implementação utilizada. A infraestrutura descrita no capítulo \ref{chap:implementacao}, por exemplo, permite que outras comparações sejam feita, como maior, menor, etc. Mesmo assim, o poder de expressão dessas construções não pode ser igualado ao de uma expressão que pode ser construída por uma linguagem de programação de alto-nível.

Por esse motivo, condições de cancelamento que precisem analisar dados e informações externas ao ambiente de execução não podem ser utilizadas. Assim, o modelo de minitransações não pode ser aplicado a esses cenários.

%Uma minitransação é composta por três conjuntos: itens de comparação, itens de leitura e itens de escrita, como pode ser visto na figura \ref{fig:estrutura_minitransacao}. Todos os itens possuem uma referência a qual dado deve ser utilizado ($ID_{A...D}$), e os itens de comparação e escrita incluem também os dados ($DADO_{1...4}$) que serão comparados com ou substituirão os dados armazenados \cite{sinfonia}. 


%Formalmente, uma minitransação pode ser vista como uma tupla na forma $(I, C, L, E)$. $I$ é o identificador da minitransação, gerado pelo criador da minitransação. \(C\) é o conjunto de itens de comparação, \(L\) é o conjunto de itens para leitura e \(E\) é o conjunto de itens para escrita. Os elementos de \(L\) são identificadores de dados, e o domínio de seus valores é o conjunto de identificadores armazenados na máquina participante. \(C\) e \(E\) possuem elementos que podem ser representados como tuplas no formato \((Id, Dado)\), em que \(Id\) é o identificador do dado e \(Dado\) é o valor para se comparar com o valor identificado por $Id$ ou para substituí-lo.




%Uma transação distribuída é uma transação que engloba operações que executam em diversos gerenciadores de recursos na forma de sub-transações, subordinadas à transação, e que é finalizada por uma requisição para efetivar ou abortar a transação \cite{gray-lamport}. Por exemplo, vamos considerar novamente o problema da transferência entre contas, como descrito na Seção \ref{sec:transacoes}, porém agora as contas estão em dois gerenciadores de recursos transacionais distintos ($G_O$ e $G_D$), como na Figura \ref{fig:transacao_distribuida}.

%A efetivação das sub-transações geradas em $G_O$ e $G_D$ precisa ser efetuada atomicamente e precisa levar em conta que mais problemas podem ocorrer em comparação com o caso não distribuído, como por exemplo: as conexões de rede podem falhar, fazendo com que a aplicação consiga se comunicar somente com um dos gerenciadores; mensagens na rede podem ser duplicadas ou perdidas, exigindo um tratamento especial para esses casos.

%Para lidar com esses problemas e garantir que a efetivação seja atômica, é necessário o uso de um protocolo que irá coordenar a efetivação da transação distribuída e garantir que essa só será considerada efetivada se todas as sub-transações forem efetivadas. O mais conhecido desses protocolos é o protocolo de efetivação em duas fases (\emph{two-phase commit protocol} ou \emph{2PC}).

%\begin{figure}
%  \centering
%  \includegraphics[width=.40\textwidth]{transacao_distribuida} 
%  \caption{Esquematização de uma transação distribuída}
%  \label{fig:transacao_distribuida} 
%\end{figure}

%\section{Minitransações}
%\label{sec:minitransacoes}
%Minitransação é uma primitiva que permite que as operações de uma transação sejam executadas durante o protocolo de efetivação. Esse protocolo de efetivação é uma modificação do \emph{2PC}, e oferece um mecanismo simples para ler e alterar dados de forma condicional em um ambiente distribuído garantindo atomicidade na execução das operações \cite{sinfonia}. Dessa forma, o número de mensagens e o tempo de execução da transação são reduzidos. 

%Porém, o uso das minitransações impõe certas restrições em relação ao que pode ser feito, diminuindo sua aplicabilidade. Por exemplo, o condicionamento das operações de leitura e escrita é baseado somente em comparações de igualdade, e a única forma da aplicação cliente abortar a minitransação é se essa comparação falhar, como será detalhado. Com as minitransações originais não é possível efetuar a transferência entre contas distribuídas como no Algoritmo \ref{alg:transferencia_valores_transacao}, pois a comparação de maior ou igual ($>=$) não pode ser feita. A nossa infraestrutura irá permitir que essa e outras comparações sejam feitas.

%Na subseção \ref{subsec:derivando-minitransacoes} é apresentado como o \emph{2PC} pode ser usado como ponto de partida para otimizações e para a obtenção do protocolo de minitransações. Na subseção \ref{subsec:estrutura-minitransacoes} definimos formalmente o conceito de minitransação.

%\subsection{Otimização do \emph{2PC}}
%\label{subsec:derivando-minitransacoes}
%A decisão pela efetivação ou cancelamento de uma transação distribuída depende tanto de aspectos operacionais, relacionados ao ambiente de execução, quanto de aspectos semânticos, específicos do domínio da aplicação. A falha na execução de uma subtransação em alguma máquina do ambiente inviabiliza a efetivação da transação como um todo, e por isso o coordenador é forçado a cancelar a transação. Esse tipo de falha operacional não está ligada ao domínio da aplicação, mas sim ao ambiente em que essa aplicação está rodando e está, portanto, fora do controle do coordenador, que pode somente cancelar a transação e, opcionalmente, tentar executá-la novamente. Por outro lado, o aspecto semântico envolvido na decisão pela efetivação ou cancelamento da transação é específico de cada aplicação e depende, direta ou indiretamente, dos dados do sistema.

%Considerando novamente o sistema bancário e a operação de transferência de uma determinada quantia entre uma conta de origem e de destino, a transferência só pode ocorrer se o saldo na conta de origem da transferência for maior ou igual à quantia a ser transferida. Essa checagem deve ser feita pela aplicação após a leitura da informação da máquina que armazena os dados da conta de origem, e a decisão pelo cancelamento ou não da transação fica subordinada à semântica dada aos dados do sistema. Isso exige que uma requisição de leitura seja feita e uma resposta seja enviada, para só então a aplicação decidir se vai efetivar e então, após a execução do restante da transação, iniciar a primeira fase do protocolo \emph{2PC} (votação).

%Podemos ver que, do ponto de vista semântico, as operações que influenciam na decisão pela possível efetivação ou pelo cancelamento da transação são operações de leitura. As operações de escrita não influenciam nessa decisão, a não ser pelo ponto de vista operacional, ou seja, se ocorrer realmente um erro na operação de escrita. Assim, se tivermos uma transação cuja última ação não afete a decisão do coordenador sobre efetivar a transação, podemos embutir essa última ação na mensagem de votação da primeira fase do protocolo de efetivação.

%O aspecto semântico da transação em relação aos dados pode ser tratado nos participantes também, e não somente no coordenador, caso o participante saiba como o coordenador irá utilizar o dado para fazer sua decisão sobre efetivar ou cancelar a transação. Se isso for possível, podemos então embutir também operações de leitura que influenciam a decisão do coordenador no protocolo de efetivação e fazer o participante adequar seu voto à maneira como o coordenador faria ao analisar o dado retornado.

%As minitransações surgem no contexto em que todas as operações de uma sub-transação podem ser embutidas dentro do protocolo de efetivação, utilizando somente as trocas de mensagens que ocorreriam no protocolo de efetivação, após a execução dos comandos. Para que isso possa ocorrer, o protocolo \emph{2PC} precisa ser alterado.

%\subsection{Definição}
%\label{subsec:estrutura-minitransacoes}
%Uma minitransação é composta por três conjuntos: itens de comparação, itens de leitura e itens de escrita, como pode ser visto na figura \ref{fig:estrutura_minitransacao}. Todos os itens possuem uma referência a qual dado deve ser utilizado ($ID_{A...D}$), e os itens de comparação e escrita incluem também os dados ($DADO_{1...4}$) que serão comparados com ou substituirão os dados armazenados \cite{sinfonia}. 

%\begin{figure}
%  \centering
%  \includegraphics[width=.40\textwidth]{estrutura_minitransacao} 
%  \caption{Estrutura de uma minitransação}
%  \label{fig:estrutura_minitransacao} 
%\end{figure}

%Formalmente, uma minitransação pode ser vista como uma tupla na forma $(I, C, L, E)$. $I$ é o identificador da minitransação, gerado pelo criador da minitransação. \(C\) é o conjunto de itens de comparação, \(L\) é o conjunto de itens para leitura e \(E\) é o conjunto de itens para escrita. Os elementos de \(L\) são identificadores de dados, e o domínio de seus valores é o conjunto de identificadores armazenados na máquina participante. \(C\) e \(E\) possuem elementos que podem ser representados como tuplas no formato \((Id, Dado)\), em que \(Id\) é o identificador do dado e \(Dado\) é o valor para se comparar com o valor identificado por $Id$ ou para substituí-lo.

\chapter{Implementação}
\label{chap:implementacao}
Na seção \ref{sec:infinispan} apresenta o Infinispan, detalhando os pontos importantes de sua arquitetura e parte central de sua implementação. 

A seção \ref{sec:mt_infinispan} descreve como as minitransações se encaixam na estrutura de transações do Infinispan e as alterações que foram necessárias nessa estrutura para disponibilizar as minitransações.

\section{Infinispan}
\label{sec:infinispan}
O Infinispan foi escolhido como base para o desenvolvimento de nossa infraestrutura por ser uma plataforma e repositório de dados distribuído. Além disso, ele é um sistema de código aberto, escrito em \emph{Java} \cite{java}, projetado para expor uma estrutura de dados altamente concorrente e para obter o melhor desempenho das modernas arquiteturas de múltiplos processadores e múltiplos núcleos, ao mesmo tempo em que oferece funcionalidades de \emph{cache} distribuído.

Na seção \ref{sec:arquitetura_infinispan} descrevemos a arquitetura do Infinispan, e os principais conceitos sobre os quais essa arquitetura se baseia. A seção \ref{sec:implementacao_infinispan} detalha o núcleo de código que habilita os pontos centrais dessa arquitetura.

\subsection{Arquitetura}
\label{sec:arquitetura_infinispan}
As máquinas rodando Infinispan podem formar um ou mais agrupamentos (\emph{cluster}), caso sejam configuradas de tal forma. Esses agrupamentos permitem que os dados sejam espalhados por diferentes máquinas, permitindo assim uma melhor distribuição de carga entre as máquinas e aumento na disponibilidade dos dados.

O componente principal do Infinispan é a interface \emph{org.infinispan.Cache}, uma extensão da interface \emph{java.util.Map} da biblioteca padrão de coleções do \emph{Java}. O acesso aos dados segue então a mesma abordagem, armazenando entradas, em que um valor é associado a uma chave arbitrária definida pela aplicação. \emph{Cache} permite abstrair os diversos modos de execução em que o Infinispan pode rodar, oferecendo uma interface simples e de ampla utilização para acessar os dados.

Os quatro modos de execução oferecidos pelo Infinispan são:

\begin{description}
	\item[Local] Todas as entradas são armazenadas na máquina local, mesmo que um agrupamento tenha sido formado.
	\item[Replicado] Todas as entradas são copiadas para todas as outras máquinas do agrupamento.
	\item[Distribuído] Cada entrada é replicada para um subconjunto das máquinas do agrupamento.
\end{description}

No modo \textbf{Local} todas as entradas ficam armazenadas na mesma máquina em que o cache está configurado, não permitindo que aplicações compartilhem os dados. O modo \textbf{Replicado} garante alta disponibilidade dos dados, uma vez que cada entrada está copiada em todas as máquinas do agrupamento. Assim, um dado só ficará indisponível no caso em que todas as máquinas do agrupamento em que ele esteja armazenado fiquem indisponíveis. No modo \textbf{Distribuído} o Infinispan armazena uma determinada entrada em um subconjunto do agrupamento. Dessa forma, se esse subconjunto de máquinas ficar indisponível, essa determinada entrada ficará indisponível também. 

O modo \textbf{Distribuído} permite um certo grau de disponibilidade ao mesmo tempo em que oferece um espaço de armazenamento expandido compartilhado entre o agrupamento. Esse grau de disponibilidade é controlado pelo tamanho do subconjunto em que uma entrada será replicada, podendo variar de 1 (não havendo nenhuma replicação, cada entrada é armazenada em somente uma máquina) até o total de máquinas no agrupamento (o que fará esse modo idêntico ao \textbf{Replicado}). O grau de expansão do espaço de armazenamento é inversamente proporcional à disponibilidade, ou seja, quanto maior a disponibilidade, menor a expansão, pois menos espaço ficará disponível devido ao maior número de cópias de uma entrada.

O Infinispan oferece também duas modalidades de acesso:

\begin{description}
	\item[Embarcado]
	\item[Cliente-Servidor] 
\end{description}

Na modalidade de acesso \textbf{embarcado}, o espaço de armazenamento do Infinispan compartilha a mesma máquina virtual \emph{Java} (e portanto, a mesma memória) que a aplicação. No modo \textbf{cliente-servidor}, uma máquina virtual fica dedicada ao espaço de armazenamento do Infinispan, e a aplicação pode acessar esse espaço por meio de alguns protocolos disponíveis: HTTP, Memcached ou HotRod \cite{infinispan}.

As máquinas que compõem o agrupamento (os nós) formam uma rede \textbf{P2P} (\emph{Peer-to-Peer} ou ponto-a-ponto \cite{p2p}). Em uma rede P2P, cada participante (cada nó rodando o Infinispan) compartilha uma parcela de seus próprios recursos (processador, memória, 
etc...) para oferecer um serviço em conjunto com todos os outros participantes (nesse caso, oferecer uma abstração de cache distribuído).
O ponto central dessa rede P2P é que não há distinção entre os nós. Cada nó pode atuar tanto como um provedor quanto como um solicitante de recursos. Qualquer nó pode receber uma solicitação para armazenar ou recuperar um dado associado a qualquer chave, e essa solicitação será atendida de forma transparente por meio da cooperação entre os nós que compõem a rede.

O que permite essa transparência no acesso e independência de localização é uma abstração conhecida como \textbf{DHT} (\emph{distributed hash table}, ou tabela de espalhamento distribuída \cite{dht}). Em uma DHT, existe um conjunto finito de localizadores, e a cada nó que compõe a rede é atribuída a tutela sobre um determinado subconjunto desses localizadores. A DHT permite então encontrar ou armazenar um par de chave e valor por meio do mapeamento da chave para um determinado localizador, que por sua vez está sob a tutela de um nó da rede.

A associação entre localizadores e um nó é feito por uma função de espalhamento consistente (\emph{consistent hashing} \cite{consistent_hashing}), que é um tipo especial de função de espalhamento (\emph{hash function} \cite{taocp_3}). Como toda função de espalhamento, ela mapeia um conjunto de valores para um índice em um espaço de endereçamento (um localizador) de uma forma que a cada localizador desse espaço sejam mapeados subconjuntos com aproximadamente o mesmo tamanho. A propriedade essencial da função de espalhamento consistente que a torna de grande utilidade em um ambiente distribuído é que, ao contrário dos outros tipos de funções de espalhamento, um pequena alteração no espaço de endereçamento resulta em um número pequeno e limitado de remapeamento, mantendo a maioria dos valores mapeados para os mesmos localizadores.

\subsection{Implementação do Infinispan}
\label{sec:implementacao_infinispan}
Infinispan é implementado integralmente na plataforma java, versão padrão (\emph{SE} ou \emph{Standard Edition}). Dessa forma é possível executar o Infinispan em qualquer sistema operacional e plataforma de máquina que ofereça suporte à essa versão do java. Seu código é aberto e público, o que permitiu sua utilização como base para o desenvolvimento de nossa infraestrutura.

A natureza distribuída do Infinispan exige que os nós se comuniquem por meio da rede, e o Infinispan utiliza o JGroups \cite{jgroups} para isso. JGroups oferece uma camada de abstração sobre a rede permitindo um mecanismo de troca de mensagens confiável entre um ou mais nós de uma só vez, que o Infinispan utiliza para a formação dos agrupamentos e comunicação entre os nós.

A interface Cache é uma extensão da interface \emph{java.util.concurrent.ConcurrentMap}, que por sua vez extende \emph{java.util.Map}. \emph{Map} permite armazenar e recuperar entradas compostas por uma chave e um valor, além de possuir alguns outros comandos úteis, como para verificar se uma determinada chave foi armazenada, ou consultar o número de entradas armazenadas. A interface \emph{ConcurrentMap} introduz alguns comandos úteis para a utilização de um mapa em um ambiente de código concorrente, como um comando para armazenar uma entrada somente se a chave associada não tiver sido mapeada (\emph{putIfAbsent}) ou para trocar o valor de uma entrada baseado em um valor já existente (\emph{replace}). A interface Cache acrescenta as funcionalidades para a representação de um cache distribuído e outras funcionalidades específicas para a manutenção e utilização dos agrupamentos formados no Infinispan.

Infinispan começou a ser desenvolvido em paralelo à especificação da JSR-107 \cite{jsr107}, uma padronização ao acesso de mecanismos de cache em java. Essa especificação define uma interface \emph{javax.cache.Cache} que é muito parecida com a interface Cache do infinispan, mas que não disponibiliza acesso a todos os recursos presentes no infinispan. Assim, para poder adequar e permitir que o infinispan possa ser usado por aplicações acessando caches por meio da JSR-107, foi criado o AdvancedCache, uma interface que estende Cache e permite acessar detalhes específicos do infinispan como adicionar e remover interceptadores, gerenciadores de travas e etc. A interface Cache é compatível com a interface de mesmo nome da JSR-107, enquanto que AdvancedCache acrescenta o que é específico do infinispan.

\emph{CacheImpl} é a classe que implementa AdvancedCache (e portanto, Cache). Ela converte as chamadas das funções da interface em comandos representando as ações a serem executadas, contendo referências e informações necessárias para essa execução. Esses comandos são executados por diferentes tipos de processadores de comandos, cada um responsável por diferentes aspectos que um comando apresenta (como distribuição na rede ou persistência de dados em disco). Os processadores são dispostos em uma sequência configurada, e a execução do comando é composta então pela atuação de cada um desses processadores, um após o outro, seguindo a sequência estabelecida. Esse esquema de execução é baseado em alguns padrões (\emph{design patterns}) bem estabelecidos e de ampla utilização, como \emph{Command}, \emph{Visitor}, \emph{Chain of Responsibility} e \emph{Interceptor} (\cite{design_patterns}, \cite{posa}).

Por exemplo, a operação \emph{Cache.get(Object k)}, que permite recuperar a entrada associada à chave \emph{k}, é transformada no comando \emph{GetKeyValueCommand}. De acordo com a configuração e detalhes específicos de cada cache, a sequência de processadores pode ser ligeiramente diferente, mas os tipos mais representativos de processadores são:

\begin{description} 
	\item[DistributionInterceptor] - Provê funcionalidades básicas para que o cache opere de forma distribuída. Processadores mais específicos como \textbf{TxDistributionInterceptor} e \textbf{NonTxDistributionInterceptor} estendem a classe base e são usados de acordo com a configuração para obter melhor desempenho.
	\item[LockingInterceptor] - Gerencia a aquisição e liberação de travas em chaves ou grupos de chaves. Conforme a configuração, são utilizadas classes mais especializadas como \textbf{OptimisticLockingInterceptor} ou \textbf{PessimisticLockingInterceptor}.
	\item[TxInterceptor] - Responsável por tratar de aspectos transacionais, como registrar o cache como um participante em uma transação distribuída.
	\item[CallInterceptor] - Sempre posicionado como o último processador na sequência, é responsável por invocar a operação específica de cada comando.
\end{description}

Um componente muito importante na execução de um comando é InvocationContext, a interface principal da hierarquia ilustrada na figura \ref{fig:invocation_context}, e a escolha de uma ou outra implementação é determinada em tempo de execução de acordo com a configuração. InvocationContext contém informações como o endereço de origem da execução e as chaves sobre as quais a execução obteve travas. AbstractInvocationContext provê a base necessária para a implementação dos contextos, implementando os métodos definidos em InvocationContext de maneira direta. NonTxInvocationContext é utilizado quando o cache não está configurado para utilizar transações, e SingleKeyNonTxInvocationContext é uma otimização para quando a operação envolve somente uma chave. TxInvocationContext permite acessar a transação associada à execução pode ser de dois tipos: LocalTxInvocationContext ou RemoteTxInvocationContext. A implementação Local é utilizada para operações transacionais que foram iniciadas no mesmo nó que estiver executando a operação, e Remote é utilizada quando a operação tiver sido iniciada em um outro nó. 

\begin{figure}
  \centering
  \includegraphics[width=\textwidth]{invocation_context} 
  \caption{Hierarquia de InvocationContext}
  \label{fig:invocation_context} 
\end{figure}

\section{Minitransações no Infinispan}
\label{sec:mt_infinispan}
O subsistema de transações do Infinispan permite agrupar operações em unidades lógicas de execução, oferecendo uma opção transacional para quem utiliza o cache. A seção \ref{sec:tx_infinispan} detalha o subsistema que gerencia e executa transações dentro do Infinispan. A seção seguinte, \ref{sec:suporte_mt_infinispan}, apresenta as modificações necessárias nesse subsistema para que o Infinispan permita a execução de minitransações.

\subsection{O subsistema de transações do Infinispan}
\label{sec:tx_infinispan}
O Infinispan pode ser configurado para agrupar ou não as operações em transações. Quando configurado para não agrupar, cada operação efetuada no cache é considerada isolada, sem relação com as outras operações. Nessa configuração, cada operação pertence a uma transação distinta, que é iniciada antes da operação ser executada e finalizada após o término da execução da operação.

Quando configurado para agrupar as operações, o Infinispan permite que o usuário defina as operações que formam uma transação, explicitamente iniciando e finalizando uma transação de modo a englobar as operações que precisam ser executadas como uma única operação lógica.

A abstração central do subsistema de transações é CacheTransaction, uma \emph{interface Java} \cite{java} que define os detalhes de uma transação no Infinispan. CacheTransaction é o topo de uma complexa estrutura projetada para atender a diferentes demandas transacionais e permitir a integração com \emph{JTA} (\emph{Java Transaction API} \cite{jta}) e \emph{X/Open XA} (\emph{Extended Architecture} \cite{xa}). Um resumo dessa estrutura é apresentado na figura \ref{fig:subsistema_transacoes}.

\begin{figure}
  \centering
  \includegraphics[width=\textwidth]{subsistema_transacoes} 
  \caption{Resumo do subsistema de transações}
  \label{fig:subsistema_transacoes} 
\end{figure}

LocalTransaction é utilizada na execução de transações iniciadas localmente e RemoteTransaction representa uma transação em execução em um nó A que foi iniciada em um outro nó B do agrupamento e que altera informações sob a responsabilidade de A. A classe LocalTransaction referencia uma Transaction do JTA. SyncLocalTransaction é utilizada por SynchronizationAdapter, que implementa a interface Synchronization definida pela JTA. LocalXATransaction é utilizada pelo TransactionXAAdapter, que implementa XAResource para integração com gerenciadores compatíveis com XOpen/XA. Tanto SynchronizationAdapter quando TransactionXAAdapter mapeiam chamadas do JTA e XOpen/XA, respectivamente, para operações de TransactionCoordinator, que centraliza a lógica para o controle de estado e execução das transações. O relacionamento entre essas classes pode ser visto na figura \ref{fig:transaction_coordinator}

\begin{figure}
  \centering
  \includegraphics[width=\textwidth]{transaction_coordinator} 
  \caption{TransactionCoordinator e seus adaptadores}
  \label{fig:transaction_coordinator} 
\end{figure}

GlobalTransaction representa um identificador de transação único em todo o agrupamento, para distinguir uma transação, independente do nó em que foi originada. Ela também é uma representação de alto-nível, sendo especializada por outras classes dependendendo da configuração do Infinispan. A figura \ref{fig:global_transaction} nos mostra de maneira simplificada essas classes. A DldGlobalTransaction implementa algoritmos para detecção de impasses (\emph{deadlocks}) na obtenção de travas para a execução das transações. Xid é uma interface que identifica uma transação no XOpen/XA.

\begin{figure}
  \centering
  \includegraphics[width=\textwidth]{global_transaction} 
  \caption{GlobalTransaction}
  \label{fig:global_transaction} 
\end{figure}

Os comandos que encapsulam operações diretamente relacionadas a uma transação são PrepareCommand, CommitCommand e RollbackCommand. PrepareCommand registra a transação relacionada na estrutura de dados do Infinispan que controla as transações (TransactionTable). CommitCommand e RollbackCommand marcam nessa mesma tabela que a transação relacionada foi finalizada. Outros compartamentos relacionados à esses comandos são implementados nos interceptadores TxInterceptor e TxDistributionInterceptor. TxInterceptor gerencia os comandos transacionais recebidos de outros nós, e TxDistributionInterceptor distribui comandos dentro da transação (como escrita, leitura, etc) para os nós responsáveis pelas chaves especificadas.

Na Listagem \ref{lst:exemplo_transaction} há um trecho de código que ilustra uma transação que utilizaremos para demonstrar como o Infinispan processa transações. Esse código está incompleto e simplificado por questões de clareza.

\begin{lstlisting}[caption={Transação convencional}, label=lst:exemplo_transaction]
cache.getAdvancedCache().getTransactionManager().begin();
cache.put("CHAVE 1", "VALOR 1");
cache.getAdvancedCache().getTransactionManager().commit();
\end{lstlisting}

A primeira linha instrui o gerenciador de transações (\emph{Transaction Manager}) do JTA a criar uma nova transação (\emph{javax.transaction.Transaction} \cite{jta}) e associá-la com a \emph{thread} de execução atual (\cite{ipc}). 

A segunda linha instrui o cache a inserir um novo elemento. Internamente, a classe CacheImpl irá criar os dois objetos necessários para a execução da operação. Um deles é PutKeyValueCommand, responsável por armazenar na chave especificada o valor fornecido. O outro objeto é LocalTxInvocationContext, que vai representar uma execução transacional iniciada no mesmo nó que executa o comando. 

Após criar o comando e o contexto de execução, o infinispan inicia o processamento do comando, oferecendo a cada interceptador configurado a oportunidade de aplicar sua lógica específica à execução do comando em questão. Os interceptadores mais relevantes na execução do comando de escrita são TxInterceptor, LockingInterceptor e EntryWrappingInterceptor.

TxInterceptor vai criar uma implementação de CacheTransaction e mapeá-la para a Transaction criada pela TransactionManager (associada à thread de execução). Dessa forma, a transação pode ser propagada para outro nós (uma vez que a Transaction do JTA não é propagada) e permite que vários nós executem operações em uma mesma transação. O tipo mais comum de CacheTransaction utilizado é o SyncLocalTransaction, que irá permitir que o TransactionManager notifique o infinispan que uma transação foi finalizada.

LockingInterceptor é responsável por efetuar a trava das chaves relacionadas ao comando. Existem duas implementações desse interceptador: OptimisticLockingInterceptor e PessimisticLockingInterceptor. Optimistic utiliza uma abordagem otimista no processo de travamento, postergando a obtenção da trava para o momento da efetivação da transação. Pessimistic tenta obter as travas no momento da execução do comando.

EntryWrappingInterceptor é responsável por obter as entradas do cache referentes às chaves especificadas no comando e disponibilizá-las no contexto de execução. Essas entradas são encapsuladas por uma classe, MVCCEntry, que permite o multiversionamento dos valores e garante as propriedades ACID da transação.

Por último, CallInterceptor irá executar o método \emph{perform} de PutKeyValueCommand, que por sua vez irá alterar o valor da entrada armazenada no contexto de execução disponibilizado por EntryWrappingInterceptor.

A terceira linha faz com que TransactionManager inicie o processo de efetivação da transação. O infinispan faz uso do mecanismo de notificação de eventos do JTA para ser avisado que a transação foi finalizada. Quando isso acontece, é criado um novo contexto de execução e um novo comando do tipo PrepareCommand. Esse comando representa a primera fase do 2PC, e é responsável por notificar os nós participantes da transação que a transação foi finalizada. 

Esse comando será processado pela mesma cadeia de interceptadores configurada, e os interceptadores mais relevantes para esse execução são TxInterceptor e TxDistributionInterceptor. TxInterceptor fica responsável por registrar como \textbf{preparada} a transação em questão, e TxDistributionInterceptor é o responsável por replicar o comando para os outros nós envolvidos na transação.

O próximo passo dependerá do resultado da execução de PrepareCommand. Se nenhum erro ocorrer, TransactionManager irá então solicitar a efetivação da transação. Caso contrário, a transação será cancelada. No caso de efetivação é criado um CommitCommand e no caso de cancelamento, um RollbackCommand. Os dois comandos resultam em marcar a transação como finalizada, mas CommitCommand faz com que EntryWrappingInterceptor efetive as alterações efetuadas nas entradas, disponibilizando-as para outras transações.

\subsection{Suporte a minitransações}
\label{sec:suporte_mt_infinispan}

O objetivo deste trabalho é implementar uma infraestrutura para o desenvolvimento de sistemas distribuídos baseada em minitransações. Para isso, foram necessárias alterações no código do Infinispan para que esse pudesse suportar a execução de minitransações.

\begin{figure}
  \centering
  \includegraphics[width=\textwidth]{transaction_operations} 
  \caption{Estrutura de classes das minitransações}
  \label{fig:transaction_operations} 
\end{figure}

A primeira alteração foi a criação de uma estrutura para representar uma minitransação, ilustrada na figura \ref{fig:transaction_operations}. Minitransaction é a classe que agrupa as operações que podem ser efetuadas no contexto de uma minitransação. A interface MinitransactionOperation é a base que deve ser implementada por qualquer operação que faça parte de uma minitransação.

A operação mais simples é ReadOperation, que especifica a chave cujo valor associado deve ser retornado. ComparisonOperation vai efetuar uma comparação, designada por ComparisonType, entre um valor especificado pelo usuário e o valor associado à chave no cache. WriteOperation irá armazenar no cache o valor especificado e associá-lo à chave especificada. TransformationOperation é a operação mais flexível, pois permite que o usuário aplique uma função de transformação no valor associado à chave especificada. Essa função de transformação é uma implementação de TransformationCallback.

A listagem \ref{lst:exemplo_minitransaction} contém código utilizando minitransações com funcionalidade equivalente ao código da listagem \ref{lst:exemplo_transaction}, e apresenta os principais elementos presentes ao codificarmos utilizando minitransações.

\begin{lstlisting}[caption={Minitransação}, label=lst:exemplo_minitransaction]
Minitransaction minitransaction = new Minitransaction();
minitransaction.addWrite(new WriteOperation("CHAVE 1", "VALOR 1"));
MinitransactionExecution execution = cache.getAdvancedCache().execute(minitransaction);
\end{lstlisting}

O método \textbf{execute} de AdvancedCache inicia criando uma transação em TransactionManager. Esse passo é necessário pois a execução de minitransações é baseada no subsistema de transações do infinispan, e esse vai exigir a presença de uma transação no contexto de execução.

Como segundo passo, \textbf{execute} cria uma PrepareMinitransactionCommand, referenciando o objeto Minitransaction recebido como parâmetro. Esse comando percorre então a cadeia de interceptadores, sendo tratado em quase todos eles da mesma maneira que um PrepareCommand, com exceção de TxInterceptor.

O papel de TxInterceptor ao interceptar PrepareMinitransactionCommand é popular a tabela de transações com uma nova CacheTransaction associada à Transaction atual, e associar ao comando a GlobalTransaction que vai permitir que a transação seja identificada dentro do agrupamento, quando o comando for replicado para os outros nós envolvidos.

A lógica de execução da minitransação, descrita na seção \ref{subsec:estrutura-minitransacoes}, é implementada no método \textbf{perform} de PrepareMinitransactionCommand. O nó para o qual a minitransação foi submetida - aquele em que o método \textbf{execute} foi executado - será chamado aqui de coordenador, e os demais nós envolvidos - aqueles responsáveis por chaves envolvidas na minitransação - são chamados de participantes. Devido ao caráter não-centralizado do infinispan, qualquer minitransação pode ser submetida a qualquer nó do agrupamento, inclusive um nó que não seja responsável por nenhuma chave envolvida na minitransação. Uma chave está envolvida na minitransação se ela for referenciada por qualquer operação dessa minitransação.

O objeto Minitransaction que originou a execução é repassado para todos os nós envolvidos, mas cada nó executa somente as operações relacionadas às chaves sob sua responsabilidade. A replicação de dados que não serão usados não acarreta grandes problemas de performance, mas é um ajuste que pode ser feito facilmente no futuro.

A arquitetura do infinispan permite que tanto o código do coordenador quanto dos participantes seja centralizado no método \textbf{perform} do comando. Quando esse comando é executado como resultado da submissão da minitransação para o coordenador, o fluxo é simplesmente um encadeamento de chamadas de métodos dentro da mesma JVM, que culminam na execução de \textbf{perform} (o código completo dessa função foi disponibilizado na listagem \ref{lst:perform}) e na obtenção do resultado dessa execução, um MinitransactionExecution. Quando replicado para os participantes, esse comando é transmitido pela rede, reconstruído em cada participante e inserido no fluxo de execução de comandos, como uma chamada de método comum. O objeto retornado pelo método como resultado de sua execução percorre o caminho inverso, sendo enviado de cada participante de volta para o coordenador.

\begin{lstlisting}[caption={Função PrepareMinitransactionCommand.perform}, label=lst:perform]
@Override
public Object perform(InvocationContext ctx) throws Throwable {

  if( ctx == null ) {
    RemoteTransaction transaction = txTable.getRemoteTransaction(globalTx);

    if (transaction == null) {
      transaction = txTable.createRemoteTransaction(globalTx, null);
    }
         
    ctx = icc.createRemoteTxInvocationContext(transaction, getOrigin());
  }
  
  boolean originLocal = ctx.isOriginLocal();
      
  MinitransactionExecution execution = new MinitransactionExecution();
      
  boolean comparisonResult = true;

  processKeys();
      
  if(!localKeys.isEmpty()) {
    LockControlCommand lockControlCommand = cf.buildLockControlCommand(localKeys, flags, globalTx);
    lockControlCommand.setOrigin(getOrigin());
    invoker.invoke(ctx, lockControlCommand);

    for (ComparisonOperation comparison : minitransaction.getComparisons()) {
      if( localKeys.contains(comparison.getKey()) ) {
        KeyValueComparisonCommand comparisonCommand = cf.buildKeyValueComparisonCommand(comparison, EnumSet.noneOf(Flag.class));
        Object invoke = invoker.invoke(ctx, comparisonCommand);
        if (invoke != null && invoke instanceof Boolean) {
          if (!(comparisonResult = (Boolean) invoke)) {
            break;
          }
        }
      }
    }
  }

  if (!comparisonResult) {
    execution.markAsAborted();
  } else {
    for (ReadOperation read : minitransaction.getReads()) {
      if( localKeys.contains(read.getKey()) ) {
        GetKeyValueCommand getKeyValueCommand = cf.buildGetKeyValueCommand(read.getKey(),
        EnumSet.noneOf(Flag.class));

        Object invoke = invoker.invoke(ctx, getKeyValueCommand);
        execution.addReadKeyValue(read.getKey(), invoke);
      }
    }

    List<WriteCommand> modifications = new ArrayList<WriteCommand>();
    for (WriteOperation write : minitransaction.getWrites()) {
      if( localKeys.contains(write.getKey()) ) {
        PutKeyValueCommand putKeyValueCommand = cf.buildPutKeyValueCommand(write.getKey(), write.getValue(), -1,
               -1, EnumSet.noneOf(Flag.class));
        if(originLocal) {
          invoker.invoke(ctx, putKeyValueCommand);
        }
        else {
          modifications.add(putKeyValueCommand);
        }
      }
    }

    for (TransformationOperation transformation : minitransaction.getTransformations()) {
      if( localKeys.contains(transformation.getKey()) ) {
        TransformCommand transformCommand = cf.buildTransformCommand(transformation.getKey(), transformation.getCallback(), -1,
                -1, EnumSet.noneOf(Flag.class));
        if(originLocal) {
          invoker.invoke(ctx, transformCommand);
        }
        else {
          modifications.add(transformCommand);
        }
      }
    }
         
    if( originLocal ) {
      PrepareMinitransactionCommand remote = new PrepareMinitransactionCommand(cacheName, minitransaction, globalTx);
      remote.setOrigin(rm.getAddress());
      Collection<Address> affectedNodes = new HashSet<Address>(dm.getAffectedNodes(minitransaction.getAllKeys()));
      affectedNodes.remove(rm.getAddress());
      Map<Address, Response> responses = rm.invokeRemotely(affectedNodes, remote, true);
      for( Response response : responses.values() ) {
        if(response.isSuccessful()) {
          SuccessfulResponse sr = (SuccessfulResponse) response;
          MinitransactionExecution remoteExecution = (MinitransactionExecution) sr.getResponseValue();
          execution.mergeWith( remoteExecution );
        }
        else {
          execution.markAsAborted();
        }
        if(execution.isAborted()){
          break;
        }
      }
    }
    else {
      PrepareCommand prepareCommand = cf.buildPrepareCommand(globalTx, modifications, true);
      invoker.invoke(ctx, prepareCommand);
    }
  }

  return execution;
}
\end{lstlisting}

O primeiro passo na execução é obter acesso exclusivo às chaves envolvidas na transação utilizando o mecanismo de travas do infinispan. Um LockControlCommand é criado e executado na cadeia de interceptadores. Se não for possível travar uma ou mais chaves, ocorrerá um erro e a minitransação será cancelada.

Com as entradas referentes às chaves da minitransação travadas, são executadas todas as comparações referentes ao nó atual. Se alguma delas falhar, a minitransação como um todo deve ser cancelada. Para indicar isso, é utilizado o método \textbf{markAsAborted} de MinitransactionExecution. Se todas as comparações forem bem-sucedidas, ou se não houver nenhuma comparação para o nó atual, o fluxo de execução segue.

As operações de leitura são efetuadas em seguida. Para isso, são criados e executados comandos do tipo GetKeyValueCommand, um para cada chave especificada. O valor retornado pela execução de cada um desses comandos é registrado em MinitransactionExecution, com o método \textbf{addReadKeyValue}.

Após as leituras é a vez das operações de escrita, efetuadas com o comando PutKeyValueCommand. Esses comandos são enviados para a cadeia de interceptadores e segue o mesmo fluxo de execução descrito na seção \ref{sec:tx_infinispan}.

O último tipo de operação a ser efetuado é a transformação, que é representada por TransformCommand e por sua implementação de TransformationCallback. Esse comando é semanticalmente muito semelhante à PutKeyValueCommand no sentido em que ele atribui um valor a uma entrada. A diferença é que esse valor é uma função aplicada sobre o valor já existente na entrada. Essa função é representada pela interface TransformCallback e é implementada de acordo com a necessidade do usuário.

Para o nó participante, \textbf{perform} termina nesse ponto, retornando um MinitransactionExecution que será transmitido pela rede para o coordenador. O nó coordenador precisa agrupar todos os resultados obtidos dos participantes e combiná-los por meio do método \textbf{mergeWith} de MinitransactionExecution. Esse método vai agrupar em um só conjunto os resultados das leituras efetuadas e irá marcar esse resultado combinado como sendo cancelado caso algum dos resultados obtidos tenha sido cancelado.

Esse resultado combinado é retornado pelo coordenador e é utilizado pelo método \textbf{execute} para determinar se a minitransação deve ser efetivada ou não. Se \textbf{isAborted} for verdadeiro, a minitransação deve ser abortada e suas alterações devem ser desfeitas. Caso contrário, as alterações devem ser efetivadas e disponibilizadas para futuras transações. Esse processo de efetivação e cancelamento segue o fluxo normal de efetivação e cancelamento do infinispan, sem passar porém pela fazer de preparação do 2PC.

\chapter{Avaliação e resultados}
\label{cap:resultados}

Inicialmente foi pretendido executar os testes baseado na comparação de referências (\emph{benchmarks}), em que os sistemas são executados em um ambiente controlado e os resultados são comparados com valores de referência. O benchmark candidato foi o TPC-E \cite{tpce}, que simula a carga de trabalho em um sistema de processamento de transações de uma correta de valores. A escolha desse benchmark foi a princípio natural, pois ele foi criado pelo TPC (\emph{Transaction Processing Performance Council}, ou conselho de performance de processamento de transações), mas por fim não foi possível utilizá-lo. 

Um dos motivos é que os indicadores de performance desse benchmark são em sua maioria voltados para utilização dos do disco rígido, e nossa infraestrutura mantém todos os dados em memória. O segundo motivo foi a indisponibilidade de versões livres do TPC-E implementados em java. Foi feita uma tentativa de execução da implementação em C++, mas o tempo e o esforço de adequação para conseguir conectar à infraestrutura seria muito grande. Por fim, o TPC é um benchmark bem "pesado", exigindo muita infraestrutura de hardware.

Foram encontrados alguns outros benchmarks, mas nenhum com o peso e critérios do TPC, o que não conferiam a esses um caráter muito confiável. Por fim, foi encontrado o Radargun \cite{radargun}, um arcabouço para o desenvolvimento de benchmarks para caches distribuídos, desenvolvido pelo equipe do próprio infinspan. Infelizmente, o código do radargun estava muito atrelado ao formato de transações convencionais, e a dificuldade para modificá-lo foi semelhante à encontrada no TPC-E. Assim, ele também não pode ser utilizado.

Assim, foi definido então que a avaliação seria baseada em comparações entre transações convencionais e minitransações do próprio infinispan. Como a maior parte do código e estrutura é compartilhado por esses dois mecanismos, essa avaliação é consistente. Foi efetuada uma comparação quantitativa em relação ao tempo de execução e outra avaliação qualitativa em relação à complexidade do código. Os testes simulam dois cenários: a transferência de valores entre contas e um leilão.

No primeiro teste, transferência entre contas, dois parâmetros principais foram definidos: número de contas ($C$) e número de operadores ($O$). Cada conta é identificada por um número entre 1 e $C$, assim como cada operador é identificado por um número entre 1 e $O$. Cada conta recebe um valor inicial uniformemente distribuído no intervalo [1,6]. Cada operador é responsável por tentar efetuar um número de transferências igual a $C^2$, e em cada tentativa são escolhidas de forma aleatória as contas de origem, destino e o valor a ser transferido. Se a conta de origem possuir saldo suficiente, a transferência ocorrerá.

A listagem \ref{lst:operator_account} apresenta o trecho de código dos operadores que efetuam a transferência entre as contas. O operador do tipo TRANSACTION utiliza uma transação convencional, e MINITRANSACTION utiliza uma minitransação. O saldo das contas é armazenado no infinispan como um valor inteiro, na entrada referente à chave que identifica a conta. 

\begin{lstlisting}[caption={Operadores que executam as transferências}, label=lst:operator_account]
private enum Operator {

  TRANSACTION {

    @Override
    void transfer(Node node, long value, String accountToDebit, String accountToCredit) throws Exception {
      node.startTransaction();
      node.lock(accountToDebit, accountToCredit);
      Long fromValue = (Long) node.get(accountToDebit);
      Long toValue = (Long) node.get(accountToCredit);

      if (value <= fromValue) {
        Long newValueOfDebitAccount = fromValue - value;
        Long newValueOfCreditAccount = toValue + value;

        node.put(accountToDebit, newValueOfDebitAccount);
        node.put(accountToCredit, newValueOfCreditAccount);
        node.commitTransaction();
      } else {
        node.rollbackTransaction();
      }
    }

  },
  MINITRANSACTION {

    @Override
    void transfer(Node node, long value, String accountToDebit, String accountToCredit) {
      Minitransaction minitransaction = new Minitransaction();
      minitransaction.addComparison(ComparisonType.GE.create(accountToDebit, value));
      minitransaction.addTransformation(new TransformationOperation(accountToDebit, new AddValue(-value)));
      minitransaction.addTransformation(new TransformationOperation(accountToCredit, new AddValue(value)));
      node.execute(minitransaction);
    }

  };

  abstract void transfer(Node node, long value, String accountToDebit, String accountToCredit) throws Exception;

}
\end{lstlisting}

O segundo teste, leilão, utiliza dois parâmetros também: o número de leilões ($L$) e o número de participantes ($P$). Cada leilão é identificado com um número sequencial entre 1 e $L$, e cada participante é identificado por um número sequencial entre 1 e $P$. O infinispan é utilizando para armazenar o valor do lance vencedor da última rodada de cada leilão e o identificador do participante que efetuou esse lance vencedor.

Cada leilão recebe um valor inicial entre 1 e 6, e cada participante recebe um saldo inicial (o valor de sua carteira, \emph{wallet}) que garante que esse participante consiga efetuar no mínimo um lance. Os participantes tentam efetuar um lance de cada vez, em cada um dos leilões, em sequência, enquanto tiverem saldo em suas carteiras. Um participante não irá tentar um lance se ele já deu o lance mais alto na rodada anterior. A listagem \ref{lst:bidder_auction} apresenta o código dos participantes utilizando um transação convencional (TRANSACTION) e uma minitransação (MINITRANSACTION).  

\begin{lstlisting}[caption={Participante que efetuam os lances}, label=lst:bidder_auction]
private enum Bidder {
  TRANSACTION{

    @Override
    int bid(Node node, int id, Wallet wallet, Auction currentAuction) throws Exception {
      int count = 0;
      node.startTransaction();
      node.lock(currentAuction.code, currentAuction.code + "_WINNER");
      Integer lastBid = (Integer) node.get(currentAuction.code);
      Integer currentWinner = (Integer) node.get(currentAuction.code + "_WINNER");
      if( currentWinner != null && currentWinner == id ) {
        count++;
        node.rollbackTransaction();
      }
      else if( wallet.value <= lastBid ) {
        count++;
        node.rollbackTransaction();
      }
      else {
        int currBid = Math.min(lastBid + 1, wallet.value);
        if( currBid <= lastBid ) {
          node.rollbackTransaction();
        }
        else {
          node.put(currentAuction.code, currBid);
          node.put(currentAuction.code + "_WINNER", id);
                     
          wallet.value -= currBid;
                     
          node.commitTransaction();
        }
      }
      return count;
    } 
  },
  MINITRANSACTION{

    @Override
    int bid(Node node, int id, Wallet wallet, Auction currentAuction) throws Exception {
      int count = 0;
      Minitransaction minitransaction = new Minitransaction();
            
      minitransaction.addComparison(ComparisonType.NE.create(currentAuction.code + "_WINNER", id));
      minitransaction.addComparison(ComparisonType.LT.create(currentAuction.code, wallet));
      minitransaction.addWrite(new WriteOperation(currentAuction.code + "_WINNER", id));
      minitransaction.addTransformation(new TransformationOperation(currentAuction.code, new PlusOne()));
      minitransaction.addRead(new ReadOperation(currentAuction.code));
            
      MinitransactionExecution execution = node.execute(minitransaction);
      if( execution.isAborted() ) {
        count++;
      }
      else {
        wallet.value -= (Integer)execution.get(currentAuction.code) + 1;
      }
            
      return count;
    }
         
  };
      
  abstract int bid(Node node, int id, Wallet wallet, Auction currentAuction ) throws Exception;
}
\end{lstlisting}

Os testes foram executados utilizando o sistema operacional Ubuntu, versão 12.04, com kernel versão 3.5.0-34-generic em dois ambientes distintos. No primeiro ambiente, foi utilizado apenas um computador com processador Intel\textregistered{} Core\texttrademark{} i5 CPU, modelo 480, com 4 núcleos de 2.67GHz e com 6 GB de memória RAM. O segundo ambiente foi composto por duas máquinas virtuais com configurações idênticas ao do primeiro ambiente, em uma Blade HP (*** pegar a configuração).

As tabelas em \ref{tab:tempos_account} apresentam os tempos de execução de diversas configurações do teste que simula as transferências entre contas, quando utilizando transações e minitransações. De maneira semelhante, as tabelas em  \ref{tab:tempos_auction} apresentam os tempos do teste que simula os participantes de um leilão. Os valores estão em segundos, e são médias calculadas dos valores reais de medições obtidas das execuções efetuadas nos ambientes descritos acima.

\begin{table}[h]
	\centering
    	\begin{tabular}{|l|l|l|l|l|l|}
		\hline
		\textbf{Transação} & \multicolumn{5}{l}{No. Operadores} \\
		\hline
		No. Contas & 1 & 2 & 3 & 4 & 5 \\
		\hline
		10 &  &  &  &  &  \\
		\hline
		20 &  &  &  &  &  \\
		\hline
		50 &  &  &  &  &  \\
		\hline
		100 &  &  &  &  &  \\
		\hline
	\end{tabular}
	\begin{tabular}{|l|l|l|l|l|l|}
		\hline
		\textbf{Minitransação} & \multicolumn{5}{l}{No. Operadores} \\
		\hline
		No. Contas & 1 & 2 & 3 & 4 & 5 \\
		\hline
		10 &  &  &  &  &  \\
		\hline
		20 &  &  &  &  &  \\
		\hline
		50 &  &  &  &  &  \\
		\hline
		100 &  &  &  &  &  \\
		\hline
	\end{tabular}
	\caption{Tempos de execução - transferência de valores}
	\label{tab:tempos_account}
\end{table}

\begin{table}[h]
	\centering
    	\begin{tabular}{|l|l|l|l|l|l|}
		\hline
		\textbf{Transação} & \multicolumn{5}{l}{No. Operadores} \\
		\hline
		No. Contas & 1 & 2 & 3 & 4 & 5 \\
		\hline
		10 &  &  &  &  &  \\
		\hline
		20 &  &  &  &  &  \\
		\hline
		50 &  &  &  &  &  \\
		\hline
		100 &  &  &  &  &  \\
		\hline
	\end{tabular}
	\begin{tabular}{|l|l|l|l|l|l|}
		\hline
		\textbf{Minitransação} & \multicolumn{5}{l}{No. Operadores} \\
		\hline
		No. Contas & 1 & 2 & 3 & 4 & 5 \\
		\hline
		10 &  &  &  &  &  \\
		\hline
		20 &  &  &  &  &  \\
		\hline
		50 &  &  &  &  &  \\
		\hline
		100 &  &  &  &  &  \\
		\hline
	\end{tabular}
	\caption{Tempos de execução - leilão}
	\label{tab:tempos_auction}
\end{table}

Como pode ser notado nas tabelas, os tempos de execução das minitransações se mostraram muito superiores aos tempos de execução das transações convencionais. Esse resultado foi contra a intuição inicial de que as minitransações poderiam ocasionar uma melhora no desempenho das aplicações. Isso deve-se às otimizações que o infinispan faz ao executar as transações. 

A principal dessas otimizações, que demonstrou ser a mais relevante para o bom desempenho das transações convencionais, é relacionada à escrita de dados. Ao executar um comando de escrita em um nó A, como PutKeyValueCommand, cuja chave está sob a responsabilidade de um outro nó B, o infinispan não irá efetuar a escrita no nó remoto. O comando será executado localmente, e somente no momento da finalização da transação é que esse comando será enviado para o nó B, dentro de PrepareCommand.

Todos os comandos de escrita são agrupados e enviados de uma só vez em um PrepareCommand, de modo semelhante ao que acontece com as minitransações. A diferença é que ao executar o PrepareCommand no nó remoto, os comandos de escrita agrupados dentro do prepare são executados de uma vez também, aproveitando o fluxo de execução do PrepareCommand. Enquanto na execução da minitransação cada comando de escrita gera um novo PutKeyValueCommand, e cada um desses comandos é executado e processado por toda a cadeia de interceptadores configurado, no caso do PrepareCommand, não há a criação desses novos comandos de escrita, e a cadeia de interceptadores é percorrida somente uma vez.

Os resultados obtidos não foram satisfatórios mas, como será apresentado na seção \ref{sec:licoes_e_futuro} a seguir, há possibilidade de alterações para melhorar o desempenho do sistema em relação ao desempenho apresentado por transações convencionais. De certa forma, analisando por um ponto de vista quantitativo, este trabalho não atingiu seus objetivos.

Sob uma ótica qualitativa, porém, acreditamos que o trabalho tenha tido êxito. Se compararmos o código das aplicações apresentadas nas listagens anteriores, vemos que os trechos que fazem uso de minitransações são menores e mais claros. É evidente que um menor número de linhas de código não se traduza automaticamente em qualidade mas, nos cenários em que pode ser utilizada, uma minitransação permite expressar de forma mais concisa a intenção da transação.

Por exemplo, nas linhas 12-21 da listagem \ref{lst:operator_account} vemos que o código cliente fica a cargo de cancelar a transação caso a comparação de valores não seja bem sucedida. A intenção da transação fica perdida em meio aos mecanismos que o sistema de transações oferece para utilizá-las. 

Nas minitransações, essa intenção fica clara e não espalhada pelo código. Os aspectos semânticos ficam bem definidos no código: basta verificar as comparações que a minitransação possui para verificar em quais cenários ela será efetivada ou cancelada. Com o uso de transações convencionais, esse aspecto semântico é mais difícil de ser diretamente detectado, exigindo uma análise mais cuidadosa.

Em concordância com uma abordagem de código limpo e claro como uma ferramenta e um meio de desenvolver sistemas de qualidade (\cite{clean_code}, \cite{xp}, \cite{refactoring}), principalmente na área de sistemas distribuídos, onde há um número enorme de cenários não-triviais a serem tratados, a possibilidade de utilizar uma primitiva que traduza claramente a semântica de uma transação que pode envolver uma grande quantidade de máquinas é de grande valor.

\chapter{Conclusão}
\label{cap:conclusao}

Embora tenha sido planejado para ser modificado, houve alguns pequenos problemas para alterar o infinispan para executar minitransações. Esses problemas e as soluções encontradas estão descritos na seção \ref{sec:problemas_solucoes}. Os resultados obtidos com esse trabalho foram disponibilizados para amplo acesso, e uma análise está disponível na seção \ref{sec:resultados}. Na seção \ref{sec:licoes_e_futuro} apresentamos lições aprendidas no desenvolvimento deste trabalho e identificamos pontos que podem ser melhorados, e possíveis extensões.

\section{Problemas e soluções}
\label{sec:problemas_solucoes}

O principal problema encontrado, e de certa forma ainda não resolvido, está relacionado à avaliação da infraestrutura. Esse problema direcionou o desenvolvimento do trabalho para sua direção atual. Os outros problemas estão relacionados ao desenvolvimento.

Inicialmente, foi desenvolvida uma infraestrutura nova, sem utilizar nenhum código como base, em que o processamento de minitransações estava diretamente embutido no sistema. Essa infraestrutura armazena os dados em memória e oferece uma interface de acesso muito parecida à do infinispan. Embora essa primeira infraestrutura desenvolvida funcione e execute minitransações, foram encontrados alguns empecilhos para avaliá-la.

Em primeiro lugar, não foi encontrado nenhum outro sistema que oferecesse essa funcionalidade de execução de minitransações. Não há sentido em avaliar a infraestrutura isoladamente, pois não há nenhum parâmetro de comparação. A avaliação isolada foi feita mas com caráter funcional, para garantir que a infraestrutura estava de acordo com a especificação proposta e que era possível utilizá-la.

A avaliação pretendida era a comparação dos resultados de performance apresentados pela infraestrutura com outros resultados conhecidos, uma vez que um objetivo indireto desse trabalho é demonstrar a efetividade de minitransações como uma alternativa viável para o desenvolvimento de aplicações distribuídas. Porém, essa análise se mostrou mais complexa do que o esperado, pois os outros sistemas disponíveis com funcionalidades semelhantes já estavam consolidados e testados em ambientes de produção de alta-carga, em alguns casos com anos acumulados em melhorias de performance e desempenho.

Surgiu então a idéia de modificar um sistema já existente, que tivesse funcionalidades semelhantes, de forma que a diferença fosse mínima na implementação dos cenários testados. Após a avaliação de alguns candidatos foi escolhido o Infinispan, pois apresentava a maioria das características desejadas para a infraestrutura e era desenvolvido em Java, linguagem com a qual o autor deste trabalho possui maior experiência.

Iniciou-se um novo esforço de aprendizagem, pois o Infinispan é um sistema complexo, com muitas funcionalidade e altamente configurável. Seu código é bem estruturado e faz uso de diversos padrões, convenções e boas práticas utilizadas no desenvolvimento de sistemas distribuídos, mas mesmo assim não é de nenhuma forma um código simples. Foram necessárias diversas execuções, novas linhas de log e muitas sessões de debug para que fossem idêntificados os pontos que precisavam ser alterados. 

Ao estender o infinispan, nossa infraestrutura herdou toda sua funcionalidade, como a replicação e distribuição de dados e capacidade de armazenar os dados em diversas formas de armazenagem, como discos ou bancos de dados. Toda a camada de comunição intra-nós e entre a infraestrutura e os clientes também foi reaproveitada. De certa forma, o ponto principal do trabalho passou a ser permitir que o infinispan executasse minitransações, utilizando seus componentes. Isso, porém, não foi tão simples como esperado.

O infinispan pode atuar tanto no modo transacional quanto não-transacional. Porém, o termo "não-transacional" pode dar a impressão de que não há transações envolvidas, o que não é verdade. O deixa de existir é a transação do JTA e a possibilidade de agrupar operações em uma grande operação lógica, demarcada pela usuário. No modo não-transacional, cada operação individual é envolvida por uma transação, criada antes logo no início da execução do comando e finalizada após o fim de sua execução.

Dessa forma, o conceito de transação permeia particamente todo o infinispan, mesmo em trechos que seriam "não-transacionais". Isso dificultou um pouco a inclusão de suporte a minitransações. Por exemplo, não foi possível fazer com que PrepareMinitransactionCommand fosse uma subclasse de PrepareCommand. Inicialmente havia sido codificado dessa forma, mas havia muitos pontos em que PrepareCommand era tratado e a maioria desses pontos não fazia sentido para uma minitransação.

Um outro problema é que o Infinispan faz uma série de otimizações em relação a transações. Uma delas é tratar uma transação distribuída como sendo de somente uma fase, ou seja, em alguns cenários específicos, que dependem da configuração especificada, o infinispan efetua a efetivação ou cancelamento quando processa PrepareCommand. A configuração necessária para habilitar as minitransações resultavam necessariamente nesses cenários, o que atrapalhava a execução das minitransações.

Foram testadas algumas alternativas para a implementação, mas a solução final acabou sendo a mais simples, apresentada no capítulo sobre a implementação da infraestrutura, na seção \ref{sec:suporte_mt_infinispan}. Com essa solução a execução das minitransações ficou desvinculada da maior parte da execução de transações convencionais no infinispan.

O último problema, que remete ao primeiro citado no início dessa sessão foi a escolha de uma ferramenta que possibilitasse a correta medição de parâmetros para uma análise de performance consistente. Devido à diferença estrutural dos tratamentos no código entre transações e minitransações, instrumentar o código para efetuar essas medições não seria muito efetivo.



%5 Threads - AccountTest

%\begin{description}
%	\item[OrdinaryDebtor] 519.653s
%	\item[MinitransactionDebtor] 36000.656s 
%\end{description}

%Foi necessário

%A própria natureza das minitransações dificulta essa comparação pois como vimos, ela está restrita a alguns tipos de operações, sendo menos genérica do que uma transação convencional. Assim, comparar 


%A prosposta deste trabalho é disponibilizar uma infraestrutura com suporte a minitransações para facilitar o desenvolvimento de aplicações distribuídas, mas não foi encontrado nenhum outro sistema que oferecesse essa funcionalidade.



% Nesse âmbito, não foi encontrado nenhum outro sistema que oferecesse essa capacidade específica de minitransações e portanto, foi é possível compará-lo

%Grande parte do esforço de desenvolvimento foi voltado a entender a base de código do infinispan. O seu código está em sua grande maioria bem estruturado, com cada classes com suas responsabilidades bem definidas. A arquitetura da aplicação também foi bem planejada, e a maneira como conceitos e padrões foram usados para viabilizar a complexa tarefa de esconder uma estrutura de cache distribuída atrás de uma interface amigável ao usuário é uma lição muito importante aprendida.


%A primeira proposta desse trabalho era desenvolver uma infraestrutura totalmente do zero, e dessa forma todo o processamento de minitransações estaria embutido no sistema. Esse sistema chegou a ser desenvolvido e, apesar de ter funcionalidades bem simplificadas, as minitransações eram executadas corretamente e de modo integral, mas ele foi descontinuado por apresentar algumas dificuldades com relação à avaliação do sistema.

%A idéia para avaliar o sistema era de comparar  

%Um empecilho ao uso desse sistema era como compará-lo com outros sistemas. Não foi encontrado nenhum outro sistema com suporte a minitransações, e comp

\section{Lições aprendidas e trabalhos futuros}
\label{sec:licoes_e_futuro}

O sistema desenvolvido inicialmente não utilizou nenhum outro código como base. Por esse motivo, foi necessário o desenvolvimento de funcionalidades em áreas diversas, algumas das quais o autor não possuía muita experiência.

A primeira dessas funcionalidades foi a criação de um protocolo para a comunicação e o desenvolvimento de um interpretador para esse protocolo. Mesmo sendo um protocolo simples (esse protocolo foi descrito na versão original do texto de qualificação deste trabalho) o desenvolvimento de um interpretador não é trivial, e exigiu um estudo mais aprofundado das técnicas de construção de interpretadores (disponíveis em \cite{compilers}).

A implementação do gerenciamento e comunicação de rede também não foi simples, pois a comunicação poderia ocorrer tanto entre os nós do sistema quanto entre aplicações clientes e o sistema. Projetado para ser acessível a qualquer aplicação com acesso à uma rede de computador, foi escrito código para lidar direto com a camada \emph{TCP} da rede, utilizando as funcionalidades de entrada e saída não-bloqueantes da plataforma java (\cite{nio}), algo que o autor não havia utilizado de forma consistente anteriormente.

Esse primeiro sistema, embora tenha chegado a um estágio funcional, ficou longe de estar completo, e as funcionalidades descritas acima, vitais para a execução do sistema, também eram incompletas e sujeitas a falhas muitas vezes grosseiras. A principal lição aprendida com esse sistema foi buscar e tentar reaproveitar algo que funcione e que possa ser modificado para nossas necessidades, mesmo que tenhamos que nos desfazer de longas horas de trabalho já efetuado.

O uso do infinispan como base exigiu um novo esforço de aprendizado e descoberta. Todas as funcionalidades disponíveis no primeiro sistema, de forma bem mais completa, estavam presentes no infinispan, além de um grande número de outras que apesar de importantes, não seriam desenvolvidas por falta de tempo.

Estudar e entender a base de código do infinispan agregou muito em termos de como desenvolver um sistema totalmente distribuído, capaz de executar em diversos cenários, muitos dos quais não haviam sequer sido cogitados na proposta deste trabalho. Foi importante ver também que o próprio infinispan foi construído com base em outras sólidas bases, como o JGroups, e como muitos dos problemas enfrentados no desenvolvimento do primeiro sistema não causariam impacto se esse biblioteca tivesse sido utilizada.

Como descrito anteriormente, uma pendência deste trabalho é a otimização da execução da minitransação para melhorar seu desempenho em relação ao tempo de execução das transações convencionais. Poderia ser criado somente um comando para executar todas as escritas de uma vez, como é feito no caso do PrepareCommand, evitando assim que a cadeia de interceptadores seja percorrida repetidamente.

Uma segunda oportunidade de desenvolvimento é a validação e execução dos testes em um ambiente altamente distribuído. Conforme descrito na descrição do infinispan e baseado em discussões dos desenvolvedore do infinispan, foi reportado a utilização de agrupamentos do infinispan contendo 400 máquinas, mas as configurações para esses agrupamentos não foram divulgadas. 

De forma mais realista, a documentação do infinispan descreve como configurar e otimizar para agrupamentos de até 128 máquinas. Executar e analisar o comportamento das minitransações, uma vez que seus problemas de performance sejam corrigidos, em um ambiente com essas configurações seria muito interessante. 

Por fim, a separação de uma definição de minitransação de suas implementações parece uma proposta promissora, nos moldes do que acontece com as transações convencionais e o JTA. Como visto na seção \ref{sec:resultados}, o uso de uma minitransação permite uma representação mais direta das intenções da transação, o que pode torná-las uma ferramenta para auxiliar no desenvolvimento de um código mais claro e coeso, independente do sistema ser distribuído ou não.

Uma outra opção é a implementação de um adaptador de minitransações para sistemas transacionais já existentes. Por exemplo, esse adaptador poderia oferecer um mecanismo de execução de minitransações que fosse traduzido em tempo de execução para a linguagem do sistema sendo adaptado. Assim seria possível executar minitransações em bancos de dados ou filas de mensagens.

% cabeçalho para os apêndices
%\newpage
%\renewcommand{\chaptermark}[1]{\markboth{\MakeUppercase{\appendixname\ \thechapter}} {\MakeUppercase{#1}} }
%\fancyhead[RE,LO]{}
%\appendix
%\chapter{Códigos}

%Esse apêndice apresenta algumas listagens mais completas de códigos e exemplos de utilização do infinispan.

%\label{apx:codigo}

% ---------------------------------------------------------------------------- %
\backmatter \singlespacing   % espaçamento simples
\bibliographystyle{alpha-ime}% citação bibliográfica alpha
\bibliography{bibliografia}  % associado ao arquivo: 'bibliografia.bib'

\end{document}
