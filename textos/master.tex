\documentclass[11pt,twoside,a4paper]{book}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{latexsym}

\usepackage[brazil,brazilian]{babel}
\usepackage[pdftex]{graphicx}           
\usepackage{setspace}                   
\usepackage{indentfirst}                
\usepackage{makeidx}                  
\usepackage[nottoc]{tocbibind}     
\usepackage{courier}                    
\usepackage{type1cm}              
\usepackage{listings}                   
\usepackage{titletoc}
\usepackage{amsmath}
\usepackage[fixlanguage]{babelbib}
\usepackage[font=small,format=plain,labelfont=bf,up,textfont=it,up]{caption}
\usepackage[usenames,svgnames,dvipsnames]{xcolor}
\usepackage[a4paper,top=2.54cm,bottom=2.0cm,left=2.0cm,right=2.54cm]{geometry} % margens
\usepackage[pdftex,plainpages=false,pdfpagelabels,pagebackref,colorlinks=true,citecolor=DarkGreen,linkcolor=NavyBlue,urlcolor=DarkRed,filecolor=green,bookmarksopen=true]{hyperref} % links coloridos
\usepackage[all]{hypcap}                % soluciona o problema com o hyperref e capitulos
\usepackage[square,sort,nonamebreak,comma]{natbib}  
% \usepackage[chapter]{algorithm}
% \usepackage{algpseudocode}
\usepackage[algochapter,boxruled,linesnumbered,portuguese]{algorithm2e}
\fontsize{60}{62}\usefont{OT1}{cmr}{m}{n}{\selectfont}
\usepackage{fancyhdr}
\usepackage{multirow}
\usepackage{siunitx}
\pagestyle{fancy}
\fancyhf{}
\renewcommand{\chaptermark}[1]{\markboth{\MakeUppercase{#1}}{}}
\renewcommand{\sectionmark}[1]{\markright{\MakeUppercase{#1}}{}}
\renewcommand{\headrulewidth}{0pt}
\renewcommand*{\lstlistingname}{Listagem}
%\renewcommand*{\lstlistoflistingname}{Lista de Listagens}
\graphicspath{{imagens/}}             
\frenchspacing                          
\urlstyle{same}                         
\makeindex                              
\raggedbottom                           
\fontsize{60}{62}\usefont{OT1}{cmr}{m}{n}{\selectfont}
\cleardoublepage
\normalsize
% Ref: http://en.wikibooks.org/wiki/LaTeX/Packages/Listings
\lstset{ %
language=Java,                  % choose the language of the code
basicstyle=\footnotesize,       % the size of the fonts that are used for the code
numbers=left,                   % where to put the line-numbers
numberstyle=\footnotesize,      % the size of the fonts that are used for the line-numbers
stepnumber=1,                   % the step between two line-numbers. If it's 1 each line will be numbered
numbersep=5pt,                  % how far the line-numbers are from the code
showspaces=false,               % show spaces adding particular underscores
showstringspaces=false,         % underline spaces within strings
showtabs=false,                 % show tabs within strings adding particular underscores
frame=single,	                % adds a frame around the code
framerule=0.6pt,
tabsize=2,	                    % sets default tabsize to 2 spaces
captionpos=b,                   % sets the caption-position to bottom
breaklines=true,                % sets automatic line breaking
breakatwhitespace=false,        % sets if automatic breaks should only happen at whitespace
escapeinside={\%*}{*)},         % if you want to add a comment within your code
backgroundcolor=\color[rgb]{1.0,1.0,1.0}, % choose the background color.
rulecolor=\color[rgb]{0.8,0.8,0.8},
extendedchars=true,
xleftmargin=10pt,
xrightmargin=10pt,
framexleftmargin=10pt,
framexrightmargin=10pt
}

% Corpo do texto
\begin{document}
\frontmatter 
\fancyhead[RO]{{\footnotesize\rightmark}\hspace{2em}\thepage}
\setcounter{tocdepth}{2}
\fancyhead[LE]{\thepage\hspace{2em}\footnotesize{\leftmark}}
\fancyhead[RE,LO]{}
\fancyhead[RO]{{\footnotesize\rightmark}\hspace{2em}\thepage}

\onehalfspacing

% ---------------------------------------------------------------------------- %
% CAPA
% Nota: O título para as dissertações/teses do IME-USP devem caber em um 
% orifício de 10,7cm de largura x 6,0cm de altura que há na capa fornecida pela SPG.
\thispagestyle{empty}
\begin{center}
    \vspace*{2.3cm}
    \textbf{\Large{Uma infraestrutura para desenvolvimento de aplicações distribuídas baseada em minitransações}}\\
    
    \vspace*{1.2cm}
    \Large{Leandro Ferro Luzia}
    
    \vskip 2cm
    \textsc{
    Dissertação apresentada\\[-0.25cm] 
    ao\\[-0.25cm]
    Instituto de Matemática e Estatística\\[-0.25cm]
    da\\[-0.25cm]
    Universidade de São Paulo\\[-0.25cm]
    para\\[-0.25cm]
    obtenção do título\\[-0.25cm]
    de\\[-0.25cm]
    Mestre em Ciências}
    
    \vskip 1.5cm
    Programa: Ciências da Computação\\
    Orientador: Prof. Dr. Francisco C. R. Reverbel
    \vskip 1cm
    
    \vskip 0.5cm
    \normalsize{São Paulo, Junho de 2013}
\end{center}

% ---------------------------------------------------------------------------- %
% Página de rosto (SÓ PARA A VERSÃO DEPOSITADA - ANTES DA DEFESA)
% Resolução CoPGr 5890 (20/12/2010)
\newpage
\thispagestyle{empty}
    \begin{center}
        \vspace*{2.3 cm}
        \textbf{\Large{Uma infraestrutura para desenvolvimento de aplicações distribuídas baseada em minitransações}}\\
        \vspace*{2 cm}
    \end{center}

    \vskip 2cm

    \begin{flushright}
	Esta é a versão original da dissertação elaborada pelo\\
	candidato Leandro Ferro Luzia, tal como \\
	submetida à Comissão Julgadora.
    \end{flushright}

\pagebreak

\pagenumbering{roman}

%\chapter*{Agradecimentos}
%Texto texto texto texto texto texto texto texto texto texto texto texto texto
%texto texto texto texto texto texto texto texto texto texto texto texto texto
%texto texto texto texto texto texto texto texto texto texto texto texto texto
%texto texto texto texto. Texto opcional.

\chapter*{Resumo}

\noindent LUZIA, L. F. \textbf{Uma infraestrutura para desenvolvimento de aplicações distribuídas baseada em minitransações}. 
2012. 120 f.
Dissertação (Mestrado) - Instituto de Matemática e Estatística,
Universidade de São Paulo, São Paulo, 2013.
\\

O uso de transações simplifica a criação de sistemas ao oferecer um mecanismo que agrupa operações e as executa como uma unidade. Porém, as transações não permitem uma separação clara entre os seus aspectos operacionais e semânticos, deixando a cargo do desenvolvedor a tarefa de lidar com as condições que podem levar ao cancelamento ou efetivação de uma transação. Uma minitransação é um tipo de transação em que os aspectos semânticos são apresentados de forma explícita, permitindo automatizar a verificação das condições e o cancelamento ou efetivação da transação. Este trabalho apresenta o conceito de minitransação, suas vantagens e desvantagens para a representação de transações em aplicações e uma infraestrutura transacional com suporte à execução de minitransações. %a redução na complexidade do código de sistemas que utilizam minitransações com relação a sistemas que utilizam transações convencionais. Para isso, um ambiente de execução de transações foi modificado para permitir a execução de minitransações e a comparação entre a complexidade dos códigos obtidos ao utilizar essas duas abordagens.
\\

\noindent \textbf{Palavras-chave:} minitransação, transação, banco de dados, sistemas distribuídos.

\chapter*{Abstract}
\noindent LUZIA, L. F. \textbf{An infrastructure for developing distributed applications based in minitransactions}. 
2010. 120 f.
Dissertação (Mestrado) - Instituto de Matemática e Estatística,
Universidade de São Paulo, São Paulo, 2013.
\\
TODO
\\

\noindent \textbf{Keywords:} minitransaction, transaction, database, distributed systems.

\tableofcontents

% \chapter{Lista de Abreviaturas}
% \begin{tabular}{ll}
% 	ACID    & Atomicidade, Consistência, Isolamento e Durabilidade \\
%             & (\emph{Atomicity, Consistency, Isolation and Durability})\\
%     SGBD	& Sistema Gerenciador de Banco de Dados\\
% 	2PC		& Efetivação em Duas Fases (\emph{Two-Phase Commit})\\
% 	TCP/IP	& Conjunto de protocolos de comunicação utilizado na Internet\\
% 			& (\emph{Transmition Control Protocol} e \emph{Internet Protocol})\\
% \end{tabular}

\listoffigures
\listoftables
\listofalgorithms
\lstlistoflistings
\mainmatter

% cabeçalho para as páginas de todos os capítulos
\fancyhead[RE,LO]{\thesection}

\singlespacing              % espaçamento simples

\chapter{Introdução}
\label{chap:introducao}

\section{Motivação}
\label{sec:motivacao}
Sistemas computacionais são utilizados para gerenciar e manipular dados desde o surgimento dos computadores.
O uso da Internet e a possibilidade de acessá-la de praticamente qualquer lugar permite a coleta, armazenamento, análise, processamento e manipulação de quantidades cada vez maiores de dados.

Esses dados apresentam um relacionamento entre si e a execução de operações sobre um determinado item em geral demanda que outros itens relacionados sejam envolvidos nessas operações. Dessa forma, cuidados devem ser tomados para que esses itens relacionados permaneçam consistentes entre si após a execução dessas operações.

A chave para manter a consistência de dados é identificar sequências de operações que acessam ou modificam items de dados relacionados e garantir que ou todas essas operações sejam executadas com sucesso ou a sequência como um todo seja cancelada. Tais sequências de operações são chamadas de transações \cite{gray},  e os ambientes que permitem a execução de transações garantem que cada transação é executada em sua totalidade e que transações executadas ao mesmo tempo se comportem como se estivessem sendo executadas isoladamente, uma após a outra.

A execução de uma transação pode ser cancelada explicitamente caso determinadas condições específicas do domínio do sistema não sejam atendidas. A verificação dessas condições é de responsabilidade do próprio sistema e fica implícita em seu código-fonte.

A implementação de fluxos de controle no sistema que verificam as condições que podem levar ao cancelamento das transações aumenta a dificuldade em compreender os conceitos relacionados ao sistema e seus requisitos. Essa dificuldade é resultado do esforço para compreender como as estruturas e expressões oferecidas pela linguagem de programação foram utilizadas para implementar as condições que levam ao cancelamento ou efetivação da transação.

Modularização do código ou o uso de técnicas como orientação a objetos \cite{oop} e orientação a aspectos \cite{aop} podem ser utilizados para facilitar esse entendimento, ao isolar e separar os trechos de código que implementam as verificações, mas mesmo assim não mudam o fato de que as verificações estão implementadas no sistema.

Sistemas gerenciadores de bancos de dados atuais oferecem a possibilidade de verificar restrições e executar procedimentos armazenados no próprio banco de dados \cite{vaca}, permitindo a implementação de condições que levam ao cancelamento ou efetivação da transação no próprio banco de dados, mas isso também pode dificultar o entendimento uma vez que será necessário analisar tanto o código quanto a estrutura do banco de dados para entender os requisitos. 

O entendimento ou compreensão do código-fonte de um sistema é um processo cognitivo particular de cada desenvolvedor que não pode ser medido diretamente \cite{program_comprehension}
Não existem métricas específicas para medir o esforço de compreensão de códigos-fonte, mas essa complexidade conceitual é uma importante consideração na avaliação e comparação entre projetos de sistemas \cite{software_measurement}.

O objetivo deste trabalho é apresentar uma maneira de diminuir essa complexidade por meio da utilização de minitransações, que tornam explícitas as condições que podem levar uma transação a ser cancelada. Uma minitransação é uma maneira de representar uma transação de forma que seus aspectos semânticos sejam declarados explicitamente, ou seja, as condições que permitem que uma transação seja efetivada são agrupadas e classificadas como tal, expondo claramente o contexto em que a transação pode ser efetivada.

Essa separação clara entre os aspectos semânticos e operacionais, aqueles que não representam condições de efetivação da transação, pode permitir que a execução da transação seja otimizada, pois o ambiente de execução agora tem conhecimento do contexto no qual a transação pode ser efetivada.

Por exemplo, em uma transação que envolva operações para efetuar a transferência de valores entre contas, as operações com carater operacional são aquelas que subtraem um determinado valor da conta de origem e adicionam esse mesmo valor na conta de destino. A verificação de saldo suficiente para efetuar a transferência é uma operação de carater semântico, pois ela influencia na decisão sobre abortar ou efetivar a transação.

As minitransações permitem indicar que a leitura do valor relacionado à conta de origem será utilizada para verificar se a transação pode ser efetivada, ou seja, permitem explicitar ao ambiente de execução quais operações possuem carater semântico. Para isso, os ambientes de execução devem oferecer algum mecanismo para expressar as condições das operações de carater semântico, e o grau de expressividade pode variar de acordo com a implementação, como veremos.

Por meio da apresentação do conceito de minitransações e da demonstração de como elas podem ser utilizadas na prática, este trabalho contribui para o processo de desenvolvimento de sistemas em geral, ao possibilitar a redução da complexidade do código desses sistemas com a utilização de minitransações. Uma segunda contribuição deste trabalho é a disponibilização de uma infraestrutura de execução transacional com suporte a minitransações.

\section{Organização do texto}
\label{sec:organizacao_do_texto}
Este trabalho está dividido em quatro capítulos. O primeiro capítulo é composto por esta introdução, que motiva a utilização de minitransações na execução de grupos de operações. O segundo capítulo faz uma revisão dos conceitos básicos para a compreensão deste trabalho e também de trabalhos que estejam relacionados de alguma forma ao apresentado neste trabalho. No terceiro capítulo as minitransações são definidas de maneira formal, assim como a separação dos aspectos semânticos e operacionais de uma transação. O terceiro capítulo apresenta em detalhes a infraestrutura desenvolvida para permitir a execução de minitransações. O quarto capítulo conclui este trabalho, descrevendo alguns dos problemas enfrentados e possíveis extensões futuras.

\chapter{Conceitos e trabalhos relacionados}
\label{chap:conceitos_e_trabalhos_relacionados}
Este capítulo é composto pela apresentação de conceitos relacionados a este trabalho e necessários para o entendimento do desenvolvimento realizado.

\section{Transações}
\label{sec:transacoes}
O estado de uma aplicação é definido como um conjunto de dados relacionados de alguma maneira. Esses relacionamentos podem ser vistos como invariantes em relação aos dados e em relação a como esses dados são alterados. Quando todas essas invariantes definidas estiverem satisfeitas, o estado da aplicação é dito consistente.

A execução de uma aplicação, por mais simples que seja, está sujeita a diversos tipos de falhas. Ao passo em que evoluem, passando a ser geograficamente distribuídas, executando em diferentes equipamentos e plataformas e aumentando seus requisitos de disponibilidade e tempo de resposta, as chances de falha aumentam consideravelmente. Manter o estado da aplicação consistente em cenários de ocorrência de falhas não é uma tarefa trivial.

Falhas de hardware já foram muito comuns no passado, mas o desenvolvimento da tecnologia e de mecanismos de detecção e correção tornaram esse tipo de falha cada vez mais rara. Falhas de software são um problema bem mais frequente e difícil de resolver, a despeito do uso de processos de desenvolvimento e técnicas de teste e avaliação.

A interpretação errônea dos requisitos do sistema, um projeto de sistema que traduz de maneira inexata os requisitos, ou uma implementação incorreta desse projeto são exemplos do que pode causar problemas no sistema. Além disso, o caráter dinâmico do software, com constantes adições de funcionalidades e correções de problemas, pode introduzir falhas nos mais bem testados sistemas. Situações pontuais como sobrecarga da máquina e atrasos em subsistemas como entrada e saída ou rede podem ocasionar falhas difíceis de reproduzir e corrigir.

Uma das formas de tornar o software tolerante a falhas é utilizar uma técnica chamada de programação multi-versão (\emph{multiversion programming} ou \emph{n-version programming} \cite{n_version}), em que um programa é escrito de $n$ maneiras diferentes, gerando $n$ versões do mesmo programa. A execução do sistema vai consistir da execução em paralelo dessas versões e a resposta do sistema será tomada como o consenso entre as respostas de todas as versões. A impossibilidade de atingir um consenso implica em falha do sistema.

Embora efetiva, essa abordagem possui um custo de implementação elevado e é de difícil manutenção, pois a reparação em caso de erro não é trivial, uma vez que cada versão terá um estado interno diferente. Além disso, mesmo sendo criteriosamente testadas, as versões conterão problemas, o que pode levar à falta de consenso ou a um consenso em torno de uma resposta incorreta.

Uma outra maneira de tornar o software tolerante a falhas é por meio do uso de transações. Uma transação é uma coleção de operações sobre o estado de um sistema. Ela pode ser vista como uma operação lógica composta por operações mais simples, que acessam e modificam o estado do sistema de maneira a mantê-lo sempre consistente. Uma falha em alguma das operações faz com que a transação como um todo seja abortada e o estado do sistema seja restaurado como era no início da transação \cite{garcia-molina, vaca, gray}.

Transação é o bloco básico de construção no paradigma transacional, que oferece uma abstração de desenvolvimento que permite organizar uma aplicação em transações compostas por um conjunto de operações que, do ponto de vista da aplicação, são executadas de forma atômica. 

Ao longo do tempo foram identificadas quatro propriedades que definem uma transação. Essas propriedades acabaram por se tornar sinônimo de transação, e a sua sigla, \emph{ACID}, é usualmente associada com transações. Essas propriedades estão descritas na seção \ref{subsec:acid}.

A descrição de transação apresentada neste capítulo pode ser considerada como convencional. Hoje em dia existem diversas extensões desse modelo convencional, criadas para adequar ou otimizar a execução das transações a um determinado cenário. Essas extensões são apresentadas resumidamente na seção \ref{subsec:extensoes}.

\subsection{ACID}
\label{subsec:acid}
Transações apresentam um conjunto de propriedades que as tornam uma base simples e sólida na qual se pode basear o desenvolvimento de aplicações. Essas propriedades são chamadas conjuntamente de \emph{ACID} (\emph{Atomicity, Consistency, Isolation e Durability}, ou Atomicidade, Consistência, Isolamento e Durabilidade). 

\textbf{Atomicidade} se refere ao fato de que a execução da transação é atômica, ou seja, a execução da transação significa que todas as operações que a compõem foram executadas com sucesso. A atomicidade diz respeito a qualquer observador externo, que não deve ser capaz de acessar nenhum estado intermediário criado pela transação durante sua execução. Os únicos dois estados que um observador externo pode acessar é o estado final, após a transação ser finalizada, ou o estado inicial, após a transação ser cancelada.

\textbf{Consistência} é a propriedade que diz que o resultado da execução de uma transação é um estado consistente. Seja esse novo estado o resultado de transformações aplicadas ao estado inicial, ou o próprio estado inicial no caso de cancelamento, o ponto principal sobre essa propriedade é que o novo estado é consistente.

\textbf{Isolamento} significa que o resultado das operações de uma transação $A$ não devem interferir na execução de uma outra transação $B$, enquanto $A$ não for finalizada.

\textbf{Durabilidade} impõe que uma vez que a transação tenha sido executada com sucesso, o estado resultante do sistema será mantido. Nenhuma falha posterior, seja ela causada pelo usuário, pelo ambiente ou por componentes de hardware, poderá alterar esse estado. A única maneira de faze-lo é com a execução de uma nova transação.

Embora separadas e nomeadas de forma a gerar um acrônimo com sonoridade atraente, essas propriedades não são totalmente independentes umas das outras, e suas definições em geral fazem referência às outras, como veremos a seguir.

%Garantir a atomicidade e durabilidade na execução de múltiplas transações concorrentes em situações de erro é uma tarefa complexa. Fazê-la atendendo a requisitos de performance e economia de recursos torna-a mais complicada. 

%\emph{ARIES} (\emph{Algorithm for Recovery and Isolation Exploiting Semantics}, \cite{aries}) é o método mais utilizado para implementar os mecanismos que asseguram ao um ambiente de execução transacional as propriedades \emph{ACID}. Esse método utiliza o conceito de registros de atividades e de travas como base para a implementação dos mecanismos, e sua idéia geral está distribuída nas seções seguintes.

%\begin{figure}
%  \centering
%  \includegraphics[width=\textwidth]{transicao_estado} 
%  \caption{Transição de estados de uma transação}
%  \label{fig:transicao_estado} 
%\end{figure}

% *** TODO explicar a transição de estados ou colocar em uma outra seção melhor...

\subsubsection*{Consistência}
A propriedade mais básica é a consistência, que é também a mais abstrata das quatro propriedades. Ela está relacionada à validação do estado da aplicação, que por sua vez diz respeito às invariantes impostas sobre os dados que compõem esse estado. Sua importância reside no fato de que uma aplicação, para atender de maneira efetiva seus requisitos, não pode utilizar dados inconsistentes por um período indefinido de tempo. Ela é abstrata no sentido que muitas das invariantes não podem ser diretamente expressas ou validadas, o que confere a ela um caráter menos determinístico.

Um ponto importante a destacar é que a propriedade de consistência declara que o resultado da transação deve ser um estado de sistema consistente, obedecendo às invariantes impostas. Porém, a execução das operações da transação pode deixar o estado temporariamente inconsistente, até que todas as operações tenham sido executadas. Ao término de todas as operações, e por consequência da transação, o estado deve ser consistente.

Por exemplo, vamos supor que o estado de um sistema seja composto por duas variáveis, $X$ e $Y$, que representam os saldos de duas contas bancárias. O sistema em questão permite a transferência de valores entre essas duas contas. As invariantes nesse sistema declaram que o valor de todas as contas precisa ser no mínimo zero e que ao efetuar uma transferência o valor agregado das contas não pode mudar, ou seja, se $X_{t_1} + Y_{t_1} = Z$ então $X_{t_2} + Y_{t_2} = Z$, onde $t_1$ é o momento em que a transação inicia e $t_2$ é o momento seguinte ao qual ela é finalizada.

\begin{algorithm}
\caption{Transferência de valores}
\label{alg:transferencia_transacao_1}
\Inicio{
	$IniciarTransacao$\;
	$V \gets \text{Valor a transferir}$\;
	$X \gets X - V$\;
	$Y \gets Y + S$\;
	$EfetivarTransacao$\;
}
\end{algorithm}

Como podemos ver no Algoritmo \ref{alg:transferencia_transacao_1}, durante a execução da transação o estado do sistema fica inconsistente. A modificação efetuada pela operação da quarta linha leva o estado do sistema à uma situação inconsistente com a invariante declarada. Essa inconsistência é corrigida na quinta linha, ao adicionar o valor removido de $X$ à variável $Y$.

Apesar da simplicidade, a transação do Algoritmo \ref{alg:transferencia_transacao_1} nos mostra que mesmo as funcionalidades mais elementares irão deixar o estado do sistema temporariamente inconsistente. O que deve ser respeitado é o fato de que, ao término da transação, o estado do sistema esteja novamente consistente.

Como o estado do sistema pode ficar inconsistente durante a execução da transação, uma transação $T_1$ não pode ter acesso ao resultado das transformações efetuadas por uma outra transação $T_2$ que ainda não tenha sido finalizada. Se isso ocorrer, $T_1$ efetuará  suas próprias transformações a partir de um estado inicial inconsistente, quebrando a regra de consistência.

Assim, a propriedade de isolamento toma forma para impedir que transações em curso que efetuaram transformações que deixaram o sistema inconsistente afetem outras transações em execução. 

\subsubsection*{Isolamento}
Retomando o exemplo anterior sobre transferência de valores, vamos supor agora que existam duas transações $T_1$ e $T_2$ sendo executadas ao mesmo tempo.

Considerando que o valor inicial de $X$ seja 30 e de $Y$ seja 0, e que $T_1$ precisa transferir $10$ e $T_2$ precisa transferir $15$, poderíamos ter um cenário em que as escolhas do escalonador do sistema operacional levassem a um fluxo de execução como o seguinte (com o processo $P_1$ executando $T_1$ e o processo $P_2$ executando $T_2$):

%Uma operação simples como $X \gets X - V$, declarada em apenas uma linha em linguagens de programação de alto-nível, abstrai uma série de micro-operações efetuadas pelo processador para efetuar uma conta e armazenar o seu resultado em uma variável (na verdade, essa atribuição em conjunto com a subtração podem ser vistos como uma transação, que retorna somente se a subtração for bem sucedida e o seu resultado for armazenado no espaço de memória identificado por $X$). 

%O Algoritmo \ref{alg:assembly_subtracao} descreve de forma simplificada os passos efetuados pelo hardware para executar a quarta linha do Algoritmo \ref{alg:transferencia_transacao_1}, $X = X - V$. Como podemos ver, um conjunto de operações de baixo-nível precisam ser efetuadas para que a subtração ocorra.

%\begin{algorithm}
%\caption{Descrição simplificada da execução em nível de hardware}
%\label{alg:assembly_subtracao}
%\Inicio{
%	Carregar no registrador $A$ o conteúdo do endereço de memória identificado por $X$\;
%	Carregar no registrador $B$ o conteúdo do endereço de memória identificado por $V$\;
%	Somar os valores dos registradores $A$ e $B$ e armazenar o resultado no registrador $C$\; 
%	Copiar o conteúdo do registrador $C$ para o endereço de memória identificado por $X$;
%}
%\end{algorithm}

%Levando em conta os Algoritmos \ref{alg:transferencia_transacao_1} e \ref{alg:assembly_subtracao} e que os valores iniciais de $X$ seja 30 e $Y$ seja 0, se a execução das transações não fosse isolada poderíamos ter um cenário em que as escolhas do escalonador do sistema operacional levassem a um fluxo de execução como o seguinte (com o processo $P_1$ executando $T_1$ e o processo $P_2$ executando $T_2$):

\begin{enumerate}
	\item $P_1$ inicia a transação $T_1$ e copia o valor de $X$ para o registrador $A$.
	\item O escalonador troca a execução para o processo $P_2$, efetuando todo o chaveamento de contexto.
	\item $P_2$ inicia a transação $T_2$, armazenando o valor de $X$ no registrador $A$.
	\item O escalonador é executado novamente e reativa o processo $P_1$.
	\item $P_1$ armazena 20 em $X$, 10 em $Y$ e efetiva a transação $T_1$.
	\item O escalonador reativa $P_2$.
	\item $P_2$, não tendo conhecimento do novo valor de $X$ armazenado por $P_1$, armazena 15 em $X$, 25 em $Y$ e  efetiva a transação $T_2$.
\end{enumerate}

Antes do início da transação tínhamos um total de 30 somando os valores das duas contas. Após o término da transação esse total é de 40, violando a invariante declarada. Portanto, o estado desse sistema está inconsistente devido à falta de isolamento entre as execuções concorrentes das transações.

O mecanismo mais comum para a implementação do isolamento são as travas (\emph{locks}). A implementação mais simples de travas associa a cada dado que compõem o estado do sistema uma trava. Quando uma transação precisa acessar um determinado dado, o ambiente de execução automaticamente tenta atribuir a trava associada a esse dado à transação. Se a trava não estiver associada a nenhuma outra transação no momento, ela será atribuída à transação solicitante, e essa atribuição irá perdurar até o final da transação. Se essa trava já estiver associada a uma outra transação, a primeira transação irá esperar até que a trava esteja liberada para poder continuar.

Diversas variações e otimizações desse mecanismo de travas foram criadas, visando aumentar o grau de concorrência e a performance das transações, mas o conceito básico é o descrito acima.

O isolamento na execução de transações concorrentes permite ao desenvolvedor ignorar questões ligadas ao controle de concorrência nas aplicações, pois essas são gerenciadas pelo ambiente de execução. Assim, o software resultante fica menos complexo e mais claro.

\subsubsection*{Atomicidade}
Atomicidade é a propriedade que confere às transações o seu caráter \textbf{tudo-ou-nada} de execução. Esse caráter facilita o modelo de desenvolvimento ao apresentar um protocolo simples ao desenvolvedor: a transação é efetivada e as possíveis alterações de estado são aplicadas ao sistema ou a transação é cancelada e nenhuma alteração de estado é notada pela aplicação. 

A efetivação é o caminho natural e é atingida somente se todas as operações que compõem a transação forem executadas sem nenhum erro. O estado do sistema é alterado para refletir quaisquer alterações que a transação possa ter produzido. A consistência desse novo estado é assumido como válido pelo ambiente de execução, uma vez que a transação não foi cancelada explicitamente. Assim, fica a cargo do desenvolvedor compor a transação de maneira correta, utilizando as operações de tal forma que o resultado final seja consistente.

O cancelamento da transação é um caso de exceção e pode ocorrer por dois motivos: por solicitação da aplicação ou devido a algum problema durante a execução da transação. 

A aplicação pode solicitar explicitamente que a transação seja cancelada, descartando quaisquer alterações efetuadas e retornando o estado para o apresentado no início da transação. Esse cancelamento explícito faz parte do controle de consistência que a aplicação efetua. Se a aplicação identificar que suas ações irão deixar o estado inconsistente, ou que o fluxo de execução não pode continuar por algum motivo, a solicitação de cancelamento é a ferramenta à disposição da aplicação para manter o estado consistente.

O Algoritmo \ref{alg:transferencia_transacao_2} ilustra essa situação de cancelamento explícito da transação. A aplicação verifica se o valor da conta $X$ continua válido (maior do que zero) após o débito do valor. Se esse valor for negativo, a transação é cancelada.

\begin{algorithm}
\caption{Transferência de valores com cancelamento explícito}
\label{alg:transferencia_transacao_2}
\Inicio{
	$IniciarTransacao$\;
	$V \gets \text{Valor a transferir}$\;
	$X \gets X - V$\;
	\eSe{$X < 0$}
	{
		$CancelarTransacao$\;
	}
	{
		$Y \gets Y + V$\;
		$EfetivarTransacao$\;
	}
}
\end{algorithm}

Em alguns ambientes de execução, como SGBD's, essa restrição de que o valor da conta não pode ser negativo pode ser expressa diretamente no ambiente de execução, de forma que ele possa efetuar a validação e cancelar a transação caso a validação falhe. Aqui, essa validação é feita explicitamente pela aplicação.

O cancelamento devido a algum problema durante a execução da transação é solicitado automaticamente pelo ambiente de execução. Falhas de hardware, software ou rede, como trilhas de discos danificadas, erros de programação ou perda na ligação entre duas sub-redes são exemplos de problemas que fazem com que o ambiente de execução cancele automaticamente uma transação.

A atomicidade é implementada com o auxílio de um registro de atividades (\emph{log}) das transações. Nesse registro são armazenadas estruturas que representam informações sobre a execução das transações. O registro possui duas funcionalidades principais: permitir a restauração do estado da aplicação no caso do cancelamento da transação (atomicidade) e garantir que um novo estado gerado pela execução bem sucedida de uma transação não seja perdido (durabilidade, que será descrita na próxima seção). Essa estrutura pode variar para incluir diversos tipos de informação, de acordo com o ambiente de execução utilizado, mas as informações principais estão descritas a seguir.

Todas as atividades da transação são armazenadas nesse registro. Uma pseudo-atividade é criada para indicar o início da transação, quando $IniciarTransacao$ é executada no algoritmo \ref{alg:transferencia_transacao_2}. Cada operação efetuada pela transação que modifica o estado do sistema é incluída nesse registro, em conjunto com informações adicionais como os valores do subconjunto do estado da aplicação modificado (tanto os valores antigos quanto os novos), a transação da qual a operação faz parte, o momento da execução da operação e um identificador único desse registro. 

Para finalizar, $CancelarTransacao$ e $EfetivarTransacao$ geram também pseudo-atividades que são armazenadas no registro, indicando como a transação deve ser finalizada, revertendo ou armazenando as modificações. 

Para efetuar o cancelamento de uma transação, o registro de atividades é lido do fim para o início, ou seja, a leitura começa na atividade mais recente da transação sendo cancelada, e continua nesse sentido até chegar à primeira operação registrada da transação. A cada operação lida, os valores alterados são substituídos pelo valor correspondente ao apresentado pelo sistema antes do início dessa operação. Dessa forma, ao final desse procedimento os valores iniciais do subconjunto do estado do sistema alterado pela transação terá sido recuperado.

A efetivação de uma transação consiste em aplicar todas as modificações efetuadas por essa transação ao estado do sistema. Como uma consequência da propriedade de isolamento, a efetivação de uma transação não pode interferir na execução de outras transações que estiverem executando concorrentemente e ainda não tenham sido efetivadas.

A aplicação das modificações efetuadas pela transação é feita por meio da leitura do registro de atividades. Essa leitura é feita em ordem crescente de tempo, ou seja, da operação mais antiga para a mais nova da transação. A cada operação lida, a modificação é aplicada, alterando o estado do sistema. Ao fim desse procedimento, os dados estarão atualizados, refletindo as modificações executadas pela transação.

\subsubsection*{Durabilidade}
Durabilidade é a propriedade que diz que uma vez finalizada a transação, o resultado de sua execução não pode ser desfeito arbitrariamente pelo ambiente de execução. Ou seja, o novo estado gerado pela execução da transação deve ser mantido a despeito de falhas ou problemas que possam ocorrer em um momento posterior à finalização da transação.

Isso não quer dizer que esse novo estado não possa ser modificado. O que essa propriedade assegura é que a única forma de modificar o resultado de uma transação finalizada é por meio da execução de uma nova transação, que efetua operações que revertem ou alteram os dados modificados pela primeira transação.

A implementação da durabilidade é feita também com o auxílio do registro de atividades, sendo utilizado quando o ambiente de execução é reiniciado, em geral após alguma falha. Nesses casos, o registro de atividades e o estado do sistema são analisados em busca de transações que tenham sido registradas como efetivadas mas cujas alterações não estão refletidas no estado do sistema.

Transações nessa situação são reexecutadas automaticamente, efetuando novamente as operações da transação. Um controle especial precisa ser feito pois pode acontecer de somente algumas operações não estarem refletidas no estado do sistema, e portanto a implementação não pode reexecutar essas transações.

Esse procedimento acaba por assegurar também a atomicidade, pois pode ocorrer da transação estar registrada como cancelada mas o estado do sistema não estar refletindo a situação inicial, antes do início da transação. Nesse caso, as alterações são desfeitas.

\subsection{Extensões}
\label{subsec:extensoes}
A característica tudo-ou-nada das transações convencionais apresenta uma semântica de tratamento de falhas muito simples: se algum erro ocorrer, todas as operações serão canceladas. Essa semântica facilita o tratamento de erros pela aplicação, mas pode não ser a melhor forma de lidar com falhas, dependendo da situação.

Algumas aplicações precisam efetuar um controle maior sobre a efetivação ou o cancelamento de transações. Nesse contexto, uma série de extensões e variações do modelo convencional foram criadas ao longo do tempo. Algumas dessas extensões estão descritas a seguir.

\subsubsection*{Pontos de salvamento}
Esse tipo de transação permite a especificação de pontos de salvamento (\emph{savepoint}) para demarcar momentos no tempo ao longo da execução da transação.

Esses pontos de salvamento são unicamente identificados e é possível solicitar o cancelamento da transação até um desses pontos. Dessa forma é possível cancelar apenas uma parte das operações e continuar a execução a partir do ponto especificado.

Isso fornece maior flexibilidade na composição e no desenvolvimento da transação, mas a semântica de tratamento de erros passa ser um pouco mais complexa do que em uma transação convencional.

Os pontos de salvamento são voláteis, e qualquer falha durante a execução da transação irá causar a perda deles. O cancelamento será feito em toda a transação, desfazendo todas as operações.

\subsubsection*{Transações encadeadas}
Esse tipo de transação estende a idéia de pontos de salvamento, trocando os pontos por efetivações. A idéia é permitir efetivar a transação aos poucos, evitando a perda que pode ocorrer com a utilização dos pontos de salvamento, mas mantendo o contexto transacional.

Isso forma um encadeamento de transações que representa passos em uma transação maior. Por fim, o que ocorre é similar a uma transação de transações.

Por outro lado, como é efetuada uma efetivação, a única possibilidade de cancelamento é da transação atual no fim da cadeia. No caso de pontos de salvamento, é possível voltar para qualquer um dos pontos salvos. Novamente, essa flexibilidade pode ocasionar perda de operações.

\subsubsection*{Transações aninhadas}
Transações aninhadas são uma generalização da idéia de pontos de salvamento. Enquanto nesse tipo de transação podemos organizar uma transação como uma sequência de ações que podem ser canceladas individualmente, as transações aninhadas formam uma hierarquia de unidades de trabalho.

Cada subtransação nessa hierarquia é uma nova transação, com as propriedades de atomicidade, consistência e isolamento, que pode ser completamente efetivada ou cancelada. 

A efetivação de uma subtransação torna as modificações efetuadas por ela visíveis apenas para a transação imediatamente superior na hierarquia. A efetivação total é efetuada quando a transação no nível mais alto da hierarquia for efetivada.

Da mesma forma, o cancelamento de uma transação irá ser propagado e, por consequência, cancelará todas as transações hierarquicamente subordinadas a ela.

\subsubsection*{Transações distribuídas}
Uma transação distribuída é uma transação convencional que executa em um ambiente distribuído e por isso envolve operações em diferentes computadores, ou nós.

Enquanto nas transações aninhadas as transações são decompostas de forma funcional, uma transação distribuída é decomposta de acordo com a distribuição dos dados na rede.

Essa decomposição em subtransações não reflete a hierarquia estrutural dos programas a serem executados, mas sim a localização dos dados dentro da rede. Essas subtransações representam mais fatias em que a transação principal foi cortada do que uma subdivisão funcional da transação principal.

A efetivação ou o cancelamento das subtransações não pode ser feito de forma individual. Todas as substranções precisam chegar a um consenso sobre qual deve ser a ação a ser executada na finalização da transação.

\subsubsection*{Transações multinível}
Esse tipo de transação é uma forma mais liberal e genérica de transação aninhada.

Com as transações multinível é possível pré-efetivar uma subtransação, excluíndo a possibilidade de um cancelamento unilateral de atualizações.

Aqui, é assumida a existência de transações compensatórias, que são capazes de reverter semanticamente as alterações efetuadas por uma subtransação/transação no caso de a transação pai ser cancelada. 

\section{Minitransações}
\label{sec:minitransacao}
%Embora originalmente proposta como uma otimização do protocolo de efetivação em duas fases (\emph{2PC}, \emph{Two-Phase Commit}), nosso trabalho aborda o conceito de minitransação como uma forma de representar uma transação de maneira a explicitar os seus aspectos semânticos.

%A seção \ref{sec:minitransacao_original} fala sobre a definição original de minitransação e sua origem a partir de otimizações no \emph{2PC}.

%A seção \ref{sec:formalizacao} apresenta a formalização da definição de minitransações com uma abor as vantagens dessa forma de utilizá-las e restrições 


%\subsection{Definição original}
%\label{sec:minitransacao_original}
A definição original de minitransação é apresentada em um trabalho de Aguilera et al. \cite{sinfonia}. Nesse trabalho, os autores efetuam algumas observações sobre o protocolo \emph{2PC}, de forma a obter uma otimização desse protocolo. 

Essa otimização visa a diminuição na quantidade de mensagens utilizadas para efetuar o \emph{2PC}, com o intuito de criar um ambiente de execução transacional para aplicações com requisitos de performance rígidos, como gerenciadores de sistemas de arquivos distribuídos, por exemplo. 

Como parte desta revisão, nós apresentamos de maneira mais detalhada as transações distribuídas, uma vez que essas são o  ponto de partida para a definição original de minitransações.


%Na subseção \ref{subsec:transacoes_distribuidas} nós apresentamos uma descrição mais detalhada das transações distribuídas do que a apresentada em \ref{subsec:extensoes}.

%A subseção \ref{subsec:2pc} descreve os detalhes do protocolo de efetivação em duas fases, utilizado para coordenar a efetivação de transações distribuídas.

%Em \ref{subsec:modificacao_2pc} é explicado de que maneira os autores originais modificaram o \emph{2PC}, criando o protocolo de minitransações.

\subsection{Transações distribuídas}
\label{subsec:transacoes_distribuidas}
Uma transação distribuída é uma transação convencional que é executada em um ambiente de execução distribuído, envolvendo diversas máquinas (nós) que coletivamente gerenciam o estado da aplicação. Em cada um desses nós é encontrado um gerenciador de recursos, responsável por gerenciar o subconjunto do estado da aplicação naquele nó, executando os comandos da transação distribuída que acessam ou modificam esse subconjunto.

\begin{figure}
  \centering
  \includegraphics[width=0.4\textwidth]{transferencia_valores_distribuido} 
  \caption{Transferência de valores em um ambiente de execução distribuído}
  \label{fig:transferencia_valores_distribuido} 
\end{figure}

Na figura \ref{fig:transferencia_valores_distribuido} apresentamos uma visualização da execução do algoritmo \ref{alg:transferencia_transacao_4} em um ambiente distribuído. O valor da conta $X$ está armazenado no nó A, e o valor da conta $Y$ está armazenado no nó B.

Uma transação distribuída é composta por subtransações que executam em cada um dos nós envolvidos na transação. Como podemos ver na figura \ref{fig:transferencia_valores_distribuido}, a transação \textbf{T} criada para efetuar a transferência cria duas subtransações, \textbf{SA} e \textbf{SB}, nos nós \textbf{A} e \textbf{B}, respectivamente.

Essas subtransações são como transações convencionais executando nos nós envolvidos. Elas representam trechos da transação original, e só fazem sentido no contexto dessa transação. A efetivação ou o cancelamento da transação original \textbf{T} implica na mesma finalização em cada uma das subtransações. Da mesma forma, não é possível que uma subtransação seja cancelada sem que a transação original seja cancelada também.

Como as subtransações são transações convencionais executando nos nós participantes, não existe diferença nos mecanismos utilizados na execução da transação descritos neste capítulo. A diferença se apresenta no momento da finalização da transação.

Para efetuar a efetivação da transação é preciso que todos os nós participantes concordem com tal finalização. Se algum deles não puder efetuar a efetivação, seja por qualquer problema,  nem a transação e nenhuma das suas outras subtransações poderá ser efetivada. 

A decisão pela efetivação deve ser unânime, para preservar as propriedades \emph{ACID} da transação. Na subseção \ref{subsec:2pc} será descrito um protocolo para garantir a efetivação em um ambiente de execução distribuído.

\subsection{O protocolo de efetivação em duas fases}
\label{subsec:2pc}
O protocolo de efetivação em duas fases, ou 2PC (\emph{two-phase commit}, \cite{2pc}), é o protocolo padrão utilizado para coordenar a finalização de transações distribuídas.

Quando a aplicação termina de executar todos os comandos da transação, ela solicita ao ambiente de execução que essa transação seja efetivada. Nesse momento é executado o 2PC para verificar se todos os participantes estão aptos a efetivar suas respectivas subtransações.

Caso todos os participantes respondam confirmando a efetivação, todos os outros serão notificados e a transação termina. Se algum dos participantes não responder, ou responder negativamente, indicando que não pode efetivar a subtransação, todos os nós participantes são notificados e a transação e suas subtransações são canceladas.

Assim, esse protocolo é executado em duas rodadas, ou fases, para verificar a ação a ser tomada na finalização da transação. A primera rodada é a votação, que questiona os participantes se a subtransação pode ser efetivada. A segunda rodada, de notificação, é utilizada para comunicar aos participantes a decisão tomada por todos.

\begin{figure}
  \centering
  \includegraphics[width=.50\textwidth]{fase_votacao_2pc} 
  \caption{Fase de votação do 2PC - o coordenador verifica se cada participante pode efetivar}
  \label{fig:fase_votacao_2pc} 
\end{figure}

A figura \ref{fig:fase_votacao_2pc} ilustra a primeira fase do protocolo. Como pode ser visto, o 2PC estabelece o papel de um \textbf{coordenador}, um elemento do ambiente de execução que irá coordenar a execução do protocolo e decidirá qual deve ser o tipo de finalização da transação. Na figura o coordenador está logicamente separado da aplicação e dos nós participantes, mas fisicamente ele pode estar rodando em qualquer nó do ambiente, inclusive em algum participante ou na própria aplicação.

Cada nó participante irá verificar se a subtransação associada à transação T pode ser efetivada. Alguns ambientes de execução podem postergar para o momento da efetivação checagens de invariantes. Por exemplo, SGBD's podem optar por efetuar a validação de restrições (\emph{constraints}) sobre os dados alterados para o momento da efetivação, por questões de performance. Se as invariantes forem válidas, e nenhum outro tipo de problema ocorrer, o participante responderá votando pela efetivação da transação. Se alguma variante for violada, ou se algum erro ocorrer, o participante responderá votando pelo cancelamento da transação.

\begin{figure}
  \centering
  \includegraphics[width=\textwidth]{fase_votacao_2pc_respostas} 
  \caption{Fase de votação do 2PC - resposta dos participantes}
  \label{fig:fase_votacao_2pc_respostas} 
\end{figure}

Na figura \ref{fig:fase_votacao_2pc_respostas} estão ilustradas as quatro combinações possíveis de resposta que os participantes podem enviar para o coordenador. No item \textbf{a} da figura todos os participante confirmam a efetivação de suas subtransações. O coordenador recolhe todas as respostas e verifica que, como todas foram positivas, a transação pode ser efetivada.

Os items \textbf{b} e \textbf{c} ilustram os casos em que um dos participantes não podem efetivar a sua respectiva subtransação (devido a violações das invariantes ou outra falha ocorrida), e o item \textbf{d} mostra o caso em que nenhum participante pode efetuar a efetivação. O coordenador recebe as respostas e, como uma delas (ou todas) foram negativas, ele não pode efetivar a transação. Portanto, a única ação a ser tomada é o cancelamento.

Finalizada a fase de votação e decidida a ação a ser efetuada para finalizar a transação, o coordenador inicia a segunda fase do protocolo, de notificação. O cordenador registra a ação escolhida em seu \emph{log}, e garante que esse registro seja gravado em algum meio de armazenamento não volátil. Isso ocorre por que o coordenador é a autoridade final para dizer se a transação foi efetivada ou cancelada. 

Uma vez que o coordenador tenha registrado em seu \emph{log} que a transação foi efetivada ou cancelada, qualquer falha posterior, tanto no coordenador quanto nos participantes, não pode mudar essa decisão. Após a informação sobre o cancelamento ou efetivação da transação ser armazenada definitivamente, o coordenador notifica os participantes do resultado da votação, e retorna à aplicação esse resultado.

\begin{figure}
  \centering
  \includegraphics[width=\textwidth]{fase_notificacao_2pc} 
  \caption{Fase de notificação do 2PC}
  \label{fig:fase_notificacao_2pc} 
\end{figure}

A figura \ref{fig:fase_notificacao_2pc} apresenta uma ilustração da execução da segunda fase do protocolo no caso de efetivação (o procedimento é análogo para o cancelamento). O item \textbf{a} da figura mostra o registro da efetivação da transação no \emph{log} do coordenador. O coordenador precisa garantir que essa informação foi salva permanentemente antes de prosseguir para a notificação dos participantes, no item \textbf{b}. Após notificar os participantes, o coordenador retorna para a aplicação, informando que a transação foi efetivada (item \textbf{c}). 

\subsection{Modificação do 2PC}
\label{subsec:modificacao_2pc}
O trabalho descrito em \cite{sinfonia} altera a maneira como a transação e o protocolo 2PC são executados, utilizando a primeira fase do 2PC para executar as operações da transação. Embora esse trabalho não faça referência explícita aos aspectos operacionais e semânticos de uma transação, a modificação efetuada por eles acaba por utilizar o conceito desses aspectos para obter um mecanismo de execução que tire vantagem do aspecto semântico das transações.

Em primeiro lugar, os autores notaram que o cancelamento explícito de uma transação depende somente de operações de consulta. Dessa forma, se uma transação fosse composta somente por operações de modificação, essas operações poderiam ser enviadas aos nós participantes dessa transação na primeira fase do 2PC, em uma só mensagem pela rede. Qualquer erro que ocorresse na execução dessas operações faria com que o participante respondesse negativamente à votação, cancelando a transação.

No caso de transações que contém somente operações de modificação, a intenção explícita da aplicação é efetivar a transação. Como nenhum dado foi lido, entende-se que a intenção da aplicação é simplesmente alterar o estado do sistema, sem nenhum condicionamento. Assim, a efetivação é o resultado natural dessas transações, e o participante da transação sabe que essa transação será efetivada.

A intenção dos autores era agrupar todas as operações da transação na mensagem enviada na primeira fase do 2PC pelo coordenador para os participantes. No entanto, as operações de consulta não poderiam sempre ser enviadas dessa maneira, pois devido ao caráter semântico que podem assumir, o resultado de sua execução pode ser necessário para a aplicação decidir se a transação precisa ser cancelada explicitamente. Isso faz com que um participante da transação tenha que aguardar a aplicação utilizar a informação lida e decidir se vai efetivar a transação ou não.

Porém, se o participante da transação souber como esses dados serão utilizados pela aplicação, ele mesmo poderá efetuar a comparação e verificar, durante a própria execução da operação, se a aplicação iria solicitar um cancelamento ou não da transação.

O que o trabalho descrito em \cite{sinfonia} fez foi dotar os nós participantes da transação com a capacidade de efetuar comparações que a aplicação efetuaria com o resultado de uma operação de consulta. Com isso, eles foram capazes de enviar tanto os comandos com caráter operacional quanto os comandos com caráter semântico na mensagem da primeira fase do 2PC.

Essa maneira de executar as operações de uma transação de uma só vez na primeira fase do protocolo 2PC foi chamada de \textbf{minitransação}. O protocolo resultante dessa modificação do 2PC foi utilizado para implementar o \emph{Sinfonia}, explicado brevemente em seguida.

Como veremos também, as minitransações oferecidas pelo Sinfonia possuem um escopo de utilização limitado devido ao tipo de comparação que conseguem efetuar. O escopo dessas comparações atende ao requisitos do Sinfonia mas, como veremos, podem não ser suficientes para todas as aplicações. A definição e a implementação apresentadas neste trabalho aumentam esse escopo e, portanto, a abrangência do uso de minitransações.

\subsection{Sinfonia}
Sinfonia é um serviço distribuído que permite o armazenamento de dados em um ambiente tolerante a falhas, escalável e consistente. O foco do sinfonia é prover a execução transacional de operações sobre esses dados para o que os autores chamam de aplicações de infraestrutura de centrais de dados (\emph{data center infrastructure applications}) como sistemas de arquivos distribuídos, gerenciadores de travas e serviços de comunicação de grupos de aplicações. Essas aplicações precisam ser tolerantes a falha e escaláveis, além de quase sempre precisarem oferecer consistência aos seus usuários e performance em um nível razoável.

Esse serviço procura oferecer um balanceamento entre funcionalidade e escalabilidade. A chave para alcançar escalabilidade é separar operações executadas por diferentes nós o máximo possível, de tal forma que essas operações possam ser executadas de maneira independente. Para oferecer essa escalabilidade, o Sinfonia oferece um espaço de endereçamento bem granularizado para acessar os dados armazenados, sem impor nenhum tipo de estrutura, ficando a cargo da aplicação organizar os dados da maneira mais conveniente.

O Sinfonia oferece uma primitiva de minitransação que as aplicações podem utilizar para acessar e modificar os dados, de maneira atômica e condicional, em diversos \textbf{nós de memória}. Além disso, as aplicações utilizam uma biblioteca de interface para efetuar a execução das minitransações. Essa biblioteca é responsável por coordenar a execução da minitransação entre os diversos nós de memória participantes, e assume assim o papel de coordenador descrito no 2PC.

\begin{figure}
  \centering
  \includegraphics[width=\textwidth]{sinfonia} 
  \caption{Estrutura do Sinfonia}
  \label{fig:sinfonia} 
\end{figure}

A figura \ref{fig:sinfonia} ilustra a divisão entre a aplicação e a biblioteca de interface e os nós de memória, que compõem o Sinfonia. A aplicação utiliza somente as funcionalidades disponibilizadas pela biblioteca de interface. Essa fica responsável por encapsular o ambiente distribuído do Sinfonia e gerenciar a execução do protocolo que executa e finaliza as minitransações.

Os nós de memória armazenam os dados e são responsáveis pela execução das operações que compõem a minitransação. Cada nó de memória mantém uma sequência opaca de palavras de memória com algum comprimento padrão (a implementação descrita utiliza 1 \emph{byte} como comprimento). 

Esses bytes são organizados como um espaço de endereçamento linear sem nenhuma estrutura. Cada nó de memória possui um espaço de endereçamento separado. Portanto, qualquer dado no Sinfonia é referenciado por meio de um par contendo o identificador do nó de memória e o endereço do byte a ser acessado.

O formato das minitransações utilizadas para acessar e modificar os dados e a maneira como elas são executadas no Sinfonia estão descritos a seguir.

\subsection{Minitransações no sinfonia}
\label{subsec:minitransacoes_sinfonia}
As minitransações oferecidas pelo Sinfonia possuem uma estrutura composta por três tipos de operações, como ilustrado na figura \ref{fig:minitransacao_sinfonia}.

\begin{figure}
  \centering
  \includegraphics[width=0.4\textwidth]{minitransacao_sinfonia} 
  \caption{Estrutura das minitransações do Sinfonia}
  \label{fig:minitransacao_sinfonia} 
\end{figure}

Os campos do comando de comparação estão descritos a seguir:

\begin{itemize}
	\item \textbf{Id-Nó}: identificador do nó de memória
	\item \textbf{Endereço}: número do byte no espaço de endereçamento do nó identificado por \textbf{Id-Nó}
	\item \textbf{Tamanho}: especifica quantos bytes, a partir de \textbf{Endereço}, devem ser comparados
	\item \textbf{Dados}: é uma sequência de \textbf{Tamanho} bytes com a qual o conteúdo do nó será comparado
\end{itemize}

Nos campos do comando de escrita e leitura os campos \textbf{Id-Nó} e \textbf{Endereço} possuem a mesmo significado que os do comando de comparação. O significado de \textbf{Tamanho} e \textbf{Dados} nos comandos de leitura e escrita está apresentado a seguir:

\begin{itemize}
	\item \textbf{Tamanho} identifica quantos bytes devem ser lidos, no caso de leitura, ou modificados, no caso de escrita
	\item \textbf{Dados} é uma sequência de \textbf{Tamanho} bytes que deve ser gravado a partir do byte identificado por \textbf{Endereço}. Esse campo é sempre vazio nos comandos de leitura
\end{itemize}

A comparação efetuada pelo Sinfonia é a igualdade byte a byte, ou seja, o conteúdo armazenado no nó será comparado byte a byte com o valor especificado em \textbf{Dados}. O comando de leitura especifica um bloco de dados a ser retornado e o comando de escrita especifica um bloco de dados a ser modificado.

A execução de uma minitransação segue os seguintes passos:

\begin{enumerate}
	\item As comparações são efetuadas, uma a uma.
	\item Se alguma comparação falhar, o nó de memória irá cancelar a subtransação e responder para o coordenador indicando que a minitransação precisa ser cancelada.
	\item Se todas as comparações forem bem sucedidas, o nó de memória irá ler todos os blocos especificados pelas operações de leitura e modificar todos os blocos especificados pelas operações de escrita.
	\item O nó de memória irá responder para o coordenador indicando que a minitransação pode ser efetivada. Nessa resposta são retornados também todos os blocos lidos.
\end{enumerate}

Essa é a primeira fase do protocolo, que nesse caso é chamada de fase de execução. A fase de notificação é análoga à do 2PC, em que o coordenador recebe todas as respostas dos nós participantes e calcula qual será a finalização da minitransação.

Todos os mecanismos descritos anteriormente são utilizados, como o \emph{log} para registrar as atividades da transação e as travas para garantir o isolamento entre as minitransações.

\section{Trabalhos relacionados}
\label{sec:trabalhos_relacionados}
O conceito de minitransação é introduzido como base para a construção de \emph{Sinfonia} em Aguilera et al. \cite{sinfonia}, um sistema cujo foco é prover a base para o desenvolvimento de sistemas distribuídos de baixo nível, como sistemas de arquivos distribuídos, gerenciadores de travas ou serviços de comunicação de grupos de computadores. Como visto em \ref{subsec:minitransacoes_sinfonia}, as minitransações oferecidas pelo Sinfonia permitem somente comparações de igualdade, o que reduz o escopo de utilização por aplicações de maneira geral. Esse trabalho também não faz nenhuma distinção entre os aspectos operacionais e semânticos da transação, embora eles estejam implícitos na estrutura da minitransação utilizada.

\cite{padilha} apresenta um sistema de armazenamento baseado em minitransações tolerante a falhas bizantinas. Em sistemas que toleram somente componentes com falhas simples (\emph{fail-stop components}), é assumido que um componente pode estar em dois estados: ativo e inativo. Se estiver em um estado ativo, o componente se comportará de acordo com a especificação do sistema. Se estiver inativo, o componente simplesmente para de interagir com o sistema. Essa é uma maneira simples e um tanto simplificada de lidar com falhas no sistema, mas é a forma utilizada por diversos sistemas, entre eles \emph{Sinfonia} e a nossa infraestrutura. A maneira mais geral de lidar com falhas é através da modelagem de falhas bizantinas \cite{byzantine}. Em sistemas que lidam com esse tipo de falha, um componente ativo pode se comportar de forma incorreta, enviando mensagens com conteúdo aleatório (correto ou incorreto), ou não enviando mensagem nenhuma. O tratamento de falhas bizantinas não será discutido neste trabalho.

O uso mais difundido de transações é no contexto dos gerenciadores de bancos de dados relacionais \cite{vaca}, como \emph{Oracle} \cite{oracle}, \emph{MySQL} \cite{mysql}, \emph{SQL Server} \cite{sqlserver}, entre diversos outros. Essas transações podem ser usadas em cenários nos quais não conseguimos utilizar as minitransações, sendo portanto muito mais gerais. %Porém, devido às propriedades que devem garantir, o uso dessas transações não permite escalar o banco de dados para um grande número de máquinas, algo que as minitransações permitem.

%Existem diversos sistemas que visam o armazenamento escalável de informações e a disponibilização de serviços para facilitar o  desenvolvimento de sistemas distribuídos, visando em geral a utilização em aplicações de internet de larga escala. Entre eles, podemos citar \emph{Bigtable} \cite{bigtable}, \emph{Dynamo} \cite{dynamo}, \emph{ZooKeeper} \cite{zookeeper}, e \emph{PNUTS} \cite{pnuts}.

%\emph{Bigtable} é o sistema de armazenamento distribuído do \emph{Google} que oferece uma abstração de um mapa ordenado, multidimensional, esparso e distribuído. \emph{Dynamo}, da \emph{Amazon}, é um sistema de armazenamento chave-valor que visa oferecer alta disponibilidade às aplicações. Esses dois sistemas permitem que dados sejam particionados e replicados para obter melhor desempenho e disponibilidade, mas permitem que diferentes máquinas possam ter versões diferentes de uma mesma informação.

%\emph{ZooKeeper} é um sistema que provê serviços de coordenação e sincronização para a construção de sistemas distribuídos que utiliza o algoritmo \emph{Paxos} \cite{paxos} para garantir consistência entre as operações. Como o objetivo do \emph{ZooKeeper} é permitir a coordenação entre componentes de um sistema distribuído, sua capacidade de armazenamento é limitada (em um \emph{megabyte}), e portanto não é utilizável como um repositório de dados geral.

%\emph{PNUTS} é o serviço de armazenamento de dados do \emph{Yahoo!} que garante que todas as réplicas de um determinado dado armazenado executam as mesmas alterações, na mesma ordem. PNUTS permite a existência de várias versões de um dado, e oferece uma primitiva \emph{test-and-set-write}, que efetua uma escrita de dados somente se uma determinada versão do dado for encontrada, semelhante ao mecanismo de comparação das minitransações.

%Por último, \emph{Hazelcast} \cite{hazelcast} e \emph{Akka} \cite{akka} são ferramentas para o desenvolvimento de sistemas distribuídos que visam eliminar a necessidade de comunicação explícita entre os participantes do sistema, oferecendo abstrações como estruturas de dados distribuídas ou memória transacional. \emph{Hazelcast} oferece a programas rodando na \emph{JVM Java} implementações distribuídas das coleções da biblioteca padrão (\emph{Collection, Set, List e Map}). \emph{Akka} permite a utilização de memória transacional por \emph{software} (\emph{software transactional memory} ou \emph{STM} \cite{stm}), uma abordagem que emprega o conceito de transação discutido neste trabalho em operações de leitura e escrita na memória principal do computador.

\chapter{Aspectos transacionais e a infraestrutura de execução}
\label{chap:desenvolvimento}
Este capítulo apresenta a definição mais geral de minitransação a partir da separação dos aspectos transacionais em operacionais e semânticos. Aqui, as minitransações não são vistas somente como uma extensão do 2PC, mas como uma alternativa na maneira de representar qualquer transação. Neste capítulo também descrevemos a infraestrutura criada para permitir a execução de minitransações.

\section{Aspectos operacionais e semânticos de uma transação}
\label{aspectos_operacionais_e_semanticos}
Nós podemos dividir as operações de uma transação em dois grupos: modificação e consulta. Operações de modificação alteram o estado do sistema, seja introduzindo novos dados ou modificando dados já existentes. Operações de consulta permitem que a aplicação observe o estado do sistema (na verdade, o que a aplicação vê é uma fotografia do estado no momento em que a transação iniciou).

Esse agrupamento das operações é importante pois os dois grupos resultantes possuem objetivos diferentes e, por consequência, possuem influências diferenciadas sobre a execução da transação. A possibilidade de misturar esses dois tipos de operações em uma só transação influencia também a maneira como os ambientes de execução implementam a execução dessas transações.

Operações com caráter de modificação são as responsáveis por introduzir no estado do sistema os resultados da transação. O efeito produzido por essas operações é que deve ser isolado de transações concorrentes até o momento da efetivação da transação, e as modificações produzidas por essas operações é que devem ser descartadas no caso do cancelamento da transação. 

As operações de consulta permitem à aplicação acessar o estado do sistema, utilizando os dados obtidos para efetuar verificações sobre o estado do sistema. Esses dados podem ser utilizados também como base para modificar o estado do sistema.

Não há nenhuma regra que obrigue limitar ou ordenar o número ou a sequência em que esses dois tipos de operações podem ser utilizados em uma transação. Como essas operações são agrupadas e ordenadas fica totalmente a cargo do desenvolvedor da aplicação. Essa generalidade aliada à simplicidade no tratamento de erros oferecida pela transação é o que a torna uma ferramenta de grande utilidade para o desenvolvimento de aplicações.

Ao utilizar uma transação, só há três possíveis cenários de finalização: efetivação, cancelamento explícito ou cancelamento automático. Esse número enxuto facilita projetar as aplicações, pois oferece uma maneira simplificada e ao mesmo tempo completa de agrupar as operações em unidades lógicas.

Esses três cenários estão ilustrados na figura \ref{fig:cenarios_finalizacao}. A aplicação pode solicitar tanto a efetivação quanto o cancelamento (casos \textbf{a} e \textbf{b} da figura). Em qualquer um desses casos, essa solicitação indica também o final da transação. O caso \textbf{c} da figura acontece quando ocorre um erro durante a execução da transação, implicando em seu cancelamento automático.

\begin{figure}
  \centering
  \includegraphics[width=\textwidth]{cenarios_finalizacao} 
  \caption{Cenários de finalização de uma transação}
  \label{fig:cenarios_finalizacao} 
\end{figure}

A efetivação é o caminho natural a ser seguido. A maneira como as operações são utilizadas e como os dados são tratados é sempre planejada de forma a resultar de maneira natural na efetivação da transação.

A atomicidade gera a necessidade do cancelamento automático, evitando que erros ocorridos durante a execução de uma transação façam o estado do sistema refletir parcialmente os resultados de uma transação.

O cancelamento explícito da transação representa um caso de exceção. O intuito inicial de qualquer transação é ser efetivada, e o seu cancelamento por parte da aplicação significa que alguma situação não esperada foi encontrada durante a execução dessa transação.

\begin{algorithm}
\caption{Transferência de valores com cancelamento explícito (reprodução)}
\label{alg:transferencia_transacao_3}
\Inicio{
	$IniciarTransacao$\;
	$V \gets \text{Valor a transferir}$\;
	$X \gets X - V$\;
	\eSe{$X < 0$}
	{
		$CancelarTransacao$\;
	}
	{
		$Y \gets Y + V$\;
		$EfetivarTransacao$\;
	}
}
\end{algorithm}

Por exemplo, o algoritmo \ref{alg:transferencia_transacao_3} (que reproduz o algoritmo \ref{alg:transferencia_transacao_2} aqui por questões de clareza) apresenta um exemplo de cancelamento explícito. Como podemos ver, esse cancelamento ocorre por que o valor de $X$ ficou negativo, ou seja, a decisão sobre o cancelamento da transação foi feita com base na verificação do estado do sistema.

Os cancelamentos explícitos apresentam a característica descrita acima: são baseados em verificações a respeito do estado da aplicação. Assim, no caso do algoritmo \ref{alg:transferencia_transacao_3}, a operação de consulta $X < 0$ é que determina o cancelamento ou efetivação da transação.

Portanto, além de classificar as operações como sendo de modificação ou consulta, podemos diferenciá-las em relação ao seu caráter operacional ou semântico na transação.

Uma operação com caráter operacional é aquela que não participa na decisão sobre o cancelamento explícito de uma transação. Note que a operação pode ainda sim ocasionar um cancelamento automático, caso a sua execução gere um erro no ambiente. Porém, a classificação é em relação ao cancelamento explícito da transação. Tanto operações de modificação quanto de consulta podem ser classificadas como operacionais.

Operações de caratér semântico são aquelas que influenciam a decisão sobre um cancelamento explícito da transação. Somente operações de consulta podem ser consideradas de caráter semântico.

Ao analisar o algoritmo \ref{alg:transferencia_transacao_3}, poderíamos considerar que a operação $X \gets X - V$ é de caráter semântico. Afinal de contas, é essa a única operação que pode levar a condição $X < 0$ a ser verdadeira. Embora isso seja verdade, a influência dessa operação sobre a decisão não é absoluta. Considere por exemplo o algoritmo \ref{alg:transferencia_transacao_4}.

\begin{algorithm}
\caption{Transferência de valores com cancelamento explícito modificado}
\label{alg:transferencia_transacao_4}
\Inicio{
	$IniciarTransacao$\;
	$V \gets \text{Valor a transferir}$\;
	\eSe{$X < V$}
	{
		$CancelarTransacao$\;
	}
	{
		$X \gets X - V$\;
		$Y \gets Y + V$\;
		$EfetivarTransacao$\;
	}
}
\end{algorithm}

Como podemos ver no algoritmo \ref{alg:transferencia_transacao_4}, a operação de modificação $X \gets X - V$ deixou de influenciar a decisão sobre o cancelamento. Essa modificação deixa claro que a operação de modificação não possui caráter semântico.

\begin{algorithm}
\caption{Transferência de valores com saldo negativo}
\label{alg:transferencia_transacao_5}
\Inicio{
	$IniciarTransacao$\;
	$V \gets \text{Valor a transferir}$\;
	\eSe{$X < V$}
	{
		$X_n \gets X_n + (V - X)$\;
		\Se{$X_n > L_X$}
		{
			$CancelarTransacao$\;
		}
		$X \gets 0$\;
	}
	{
		$X \gets X - V$\;
		$Y \gets Y + V$\;
	}
	$EfetivarTransacao$\;
}
\end{algorithm}

Da mesma forma, nem toda operação de consulta possui caráter semântico. Por exemplo, o algoritmo \ref{alg:transferencia_transacao_5} apresenta uma outra variação do algoritmo de transferência, que permite controlar o saldo negativo de uma conta. Agora, $X_n$ representa o saldo negativo da conta $X$, e esse saldo pode ser no máximo um limite definido previamente $L_X$. A comparação $X < V$ deixou de ter caráter semântico, pois não participa na decisão sobre o cancelamento da transação diretamente.

A classificação em relação ao caráter operacional ou semântico envolve uma análise da intenção e da composição da transação. Embora a relação entre a operação e o cancelamento exista, essa relação se dá no nível da intenção do desenvolvedor, e não está explícita na transação.

Uma \textbf{minitransação} é uma maneira de representar uma transação de forma a separar explicitamente os aspectos semânticos e operacionais de uma transação. Essa separação permite analisar e entender melhor o objetivo da transação, podendo ser utilizada para otimizações.

%\section{Formalização}
%\label{sec:formalizacao}
A definição de minitransação encontrada em \cite{sinfonia} é específica para a implementação no ambiente oferecido pelo Sinfonia, onde uma minitransação é exposta como uma primitva implementada pelo Sinfonia para executar operações atomicamente.

%Na seção \ref{subsec:definicao} formalizamos e generalizamos esse conceito de forma que possa ser implementado e utilizado em outros ambientes, independente do protocolo de execução e efetivação.

%A seção \ref{subsec:vantagens_e_desvantagens} apresenta uma comparação com o modelo convencional de transação e as vantagens e desvantagens da minitransação, assim como cenários em que podem ser utilizadas.

%\subsection{Definição}
%\label{subsec:definicao}
Uma minitransação é um modelo de representação de uma transação em que os componentes semânticos dessa transação são indicados explicitamente. Esse modelo expõe diretamente os componentes semânticos, que definem condições sob as quais uma transação deve ser cancelada.

Assim, uma minitransação $M$ é um par formado por:

\begin{itemize}
	\item $S$: conjunto de componentes semânticos da transação
	\item $O$: conjunto de componentes operacionais da transação
\end{itemize}

\begin{figure}
  \centering
  \includegraphics[width=0.7\textwidth]{mapeamento_minitransacao} 
  \caption{Modelo de uma minitransação e seu mapeamento para a implementação do Sinfonia}
  \label{fig:mapeamento_minitransacao} 
\end{figure}

A figura \ref{fig:mapeamento_minitransacao} ilustra o modelo de uma minitransação e como esse modelo é mapeado para a implementação de minitransações oferecida pelo Sinfonia. Os componentes operacionais são todos aqueles que não influenciam na decisão da aplicação em efetivar ou não a transação. No caso do Sinfonia, os comandos de leitura e escrita possuem essa característica.

Os componentes semânticos são aqueles que influenciam a aplicação em relação a efetivar ou cancelar a transação. Os comandos de comparação são portanto semânticos, pois é por meio deles que o Sinfonia decide se a transação pode ser efetivada ou não.

%\subsection{Vantagens e Desvantagens}
%\label{subsec:vantagens_e_desvantagens}
A principal vantagem na utilização de uma minitransação é a separação clara entre os aspectos semânticos e operacionais de uma transação. Essa separação deixa explícita na estrutura da transação quais os componentes que influenciam o resultado de sua execução.

Isso aumenta o grau de manutenibilidade do código da aplicação, uma vez que os componentes semânticos estão agrupados e organizados, e não espalhados pelo código em estruturas condicionais, por exemplo.

Essa separação também permite análises estáticas da aplicação em relação à transação, pois é simples identificar as condições sob as quais a transação será cancelada. Ferramentas de análise de código-fonte podem ser utilizadas para obter estatísticas e até mesmo ajudar a otimizar a construção das transações.

Otimizações também são possíveis ao efetuar essa separação, como ocorre com o protocolo 2PC modificado utilizado pelo Sinfonia. 

As desvantagens do modelo de minitransações estão relacionadas ao poder de expressão dos componentes semânticos. Por exemplo, no Sinfonia, o único componente semântico permitido é a operação de comparação de igualdade.

A expressividade desses componentes está relacionada à implementação utilizada. A infraestrutura descrita a seguir, por exemplo, permite que outras comparações sejam feita, como maior, menor, etc. Mesmo assim, o poder de expressão dessas construções não pode ser igualado ao de uma expressão que pode ser construída por uma linguagem de programação de alto-nível.

Por esse motivo, condições de cancelamento que precisem analisar dados e informações externas ao ambiente de execução não podem ser utilizadas. Assim, o modelo de minitransações não pode ser aplicado a esses cenários.

\section{Infraestrutura para execução de minitransações}
\label{sec:infraestrutura_para_execucao_de_minitransacoes}

%\label{chap:implementacao}
%A seção \ref{sec:infinispan} apresenta o Infinispan, detalhando os pontos importantes de sua arquitetura e a parte central de sua implementação. 

%A seção \ref{sec:mt_infinispan} descreve como as minitransações se encaixam na estrutura de transações do Infinispan e as alterações que foram necessárias nessa estrutura para disponibilizar as minitransações.

%\subsection{Infinispan}
O Infinispan foi escolhido como base para o desenvolvimento de nossa infraestrutura por ser uma plataforma e repositório de dados distribuído. Além disso, ele é um sistema de código aberto, escrito em \emph{Java} \cite{java}, projetado para expor uma estrutura de dados altamente concorrente e para obter o melhor desempenho das modernas arquiteturas de múltiplos processadores e múltiplos núcleos, ao mesmo tempo em que oferece funcionalidades de \emph{cache} distribuído.

%Na seção \ref{sec:arquitetura_infinispan} descrevemos a arquitetura do Infinispan, e os principais conceitos sobre os quais essa arquitetura se baseia. A seção \ref{sec:implementacao_infinispan} detalha o núcleo de código que habilita os pontos centrais dessa arquitetura.

\subsubsection{Arquitetura do infinispan}
\label{sec:arquitetura_infinispan}
As máquinas rodando Infinispan podem formar um ou mais agrupamentos (\emph{clusters}), caso sejam configuradas de tal forma. Esses agrupamentos permitem que os dados sejam espalhados por diferentes máquinas, possibilitando uma melhor distribuição de carga entre as máquinas e aumento na disponibilidade dos dados.

O componente principal do Infinispan é a interface \emph{org.infinispan.Cache}, uma extensão da interface \emph{java.util.Map} da biblioteca padrão de coleções do \emph{Java}. O acesso aos dados segue então a mesma abordagem, armazenando entradas, em que um valor é associado a uma chave arbitrária definida pela aplicação. \emph{Cache} permite abstrair os diversos modos de execução em que o Infinispan pode rodar, oferecendo uma interface simples e de ampla utilização para acessar os dados.

Os três modos de execução oferecidos pelo Infinispan são: local, replicado e distribuído.

No modo \textbf{Local} todas as entradas ficam armazenadas na mesma máquina em que o cache está configurado, não permitindo que aplicações compartilhem os dados. O modo \textbf{Replicado} garante alta disponibilidade dos dados, uma vez que cada entrada está copiada em todas as máquinas do agrupamento. Assim, um dado só ficará indisponível no caso em que todas as máquinas do agrupamento em que ele esteja armazenado fiquem indisponíveis. No modo \textbf{Distribuído} o Infinispan armazena uma determinada entrada em um subconjunto do agrupamento. Dessa forma, se esse subconjunto de máquinas ficar indisponível, essa determinada entrada ficará indisponível também. 

O modo \textbf{Distribuído} permite um certo grau de disponibilidade ao mesmo tempo em que oferece um espaço de armazenamento expandido compartilhado entre o agrupamento. Esse grau de disponibilidade é controlado pelo tamanho do subconjunto em que uma entrada será replicada, podendo variar de 1 (não havendo nenhuma replicação, cada entrada é armazenada em somente uma máquina) até o total de máquinas no agrupamento (o que fará esse modo idêntico ao \textbf{Replicado}). O grau de expansão do espaço de armazenamento é inversamente proporcional à disponibilidade, ou seja, quanto maior a disponibilidade, menor a expansão, pois menos espaço ficará disponível devido ao maior número de cópias de uma entrada.

O Infinispan oferece também duas modalidades de acesso: embarcado ou cliente-servidor. Na modalidade de acesso \textbf{embarcado}, o espaço de armazenamento do Infinispan compartilha a mesma máquina virtual \emph{Java} (e portanto, a mesma memória) que a aplicação. No modo \textbf{cliente-servidor}, uma máquina virtual fica dedicada ao espaço de armazenamento do Infinispan, e a aplicação pode acessar esse espaço por meio de alguns protocolos disponíveis: HTTP, Memcached ou HotRod \cite{infinispan}.

As máquinas que compõem o agrupamento (os nós) formam uma rede \textbf{P2P} (\emph{Peer-to-Peer} ou ponto-a-ponto \cite{p2p}). Em uma rede P2P, cada participante (cada nó rodando o Infinispan) compartilha uma parcela de seus próprios recursos (processador, memória, etc...) para oferecer um serviço em conjunto com todos os outros participantes (nesse caso, oferecer uma abstração de cache distribuído).

O ponto central dessa rede P2P é que não há distinção entre os nós. Cada nó pode atuar tanto como um provedor quanto como um solicitante de recursos. Qualquer nó pode receber uma solicitação para armazenar ou recuperar um dado associado a qualquer chave, e essa solicitação será atendida de forma transparente por meio da cooperação entre os nós que compõem a rede.

O que permite essa transparência no acesso e independência de localização é uma abstração conhecida como \textbf{DHT} (\emph{distributed hash table}, ou tabela de espalhamento distribuída \cite{dht}). Em uma DHT, existe um conjunto finito de localizadores, e a cada nó que compõe a rede é atribuída a tutela sobre um determinado subconjunto desses localizadores. A DHT permite então encontrar ou armazenar um par de chave e valor por meio do mapeamento da chave para um determinado localizador, que por sua vez está sob a tutela de um nó da rede.

A associação entre localizadores e um nó é feito por uma função de espalhamento consistente (\emph{consistent hashing} \cite{consistent_hashing}), que é um tipo especial de função de espalhamento (\emph{hash function} \cite{taocp_3}). Como toda função de espalhamento, ela mapeia um conjunto de valores para um índice em um espaço de endereçamento (um localizador) de uma forma que a cada localizador desse espaço sejam mapeados subconjuntos com aproximadamente o mesmo tamanho. A propriedade essencial da função de espalhamento consistente que a torna de grande utilidade em um ambiente distribuído é que, ao contrário dos outros tipos de funções de espalhamento, um pequena alteração no espaço de endereçamento resulta em um número pequeno e limitado de remapeamentos, mantendo a maioria dos valores mapeados para os mesmos localizadores.

\subsubsection{Implementação do Infinispan}
\label{sec:implementacao_infinispan}
Infinispan é implementado integralmente na plataforma java, versão padrão (\emph{SE} ou \emph{Standard Edition}). Dessa forma é possível executar o Infinispan em qualquer sistema operacional e plataforma de máquina que ofereça suporte à essa versão do java. Seu código é aberto e público, o que permitiu sua utilização como base para o desenvolvimento de nossa infraestrutura.

A natureza distribuída do Infinispan exige que os nós se comuniquem por meio da rede, e o Infinispan utiliza o JGroups \cite{jgroups} para isso. JGroups oferece uma camada de abstração sobre a rede permitindo um mecanismo de troca de mensagens confiável entre um ou mais nós de uma só vez, que o Infinispan utiliza para a formação dos agrupamentos e comunicação entre os nós.

A interface Cache é uma extensão da interface \emph{java.util.concurrent.ConcurrentMap}, que por sua vez estende \emph{java.util.Map}. \emph{Map} permite armazenar e recuperar entradas compostas por uma chave e um valor, além de possuir alguns outros comandos úteis, como verificar se uma determinada chave foi armazenada, ou consultar o número de entradas armazenadas. A interface \emph{ConcurrentMap} introduz alguns comandos úteis para a utilização de um mapa em um ambiente de código concorrente, como um comando para armazenar uma entrada somente se a chave associada não tiver sido mapeada (\emph{putIfAbsent}) ou para trocar o valor de uma entrada baseado em um valor já existente (\emph{replace}). A interface Cache acrescenta as funcionalidades para a representação de um cache distribuído e outras funcionalidades específicas para a manutenção e utilização dos agrupamentos formados no Infinispan.

Infinispan começou a ser desenvolvido em paralelo à especificação da JSR-107 \cite{jsr107}, uma padronização ao acesso de mecanismos de cache em java. Essa especificação define uma interface \emph{javax.cache.Cache} que é muito parecida com a interface Cache do infinispan, mas que não disponibiliza acesso a todos os recursos presentes no infinispan. Assim, para poder adequar e permitir que o infinispan possa ser usado por aplicações acessando caches por meio da JSR-107, foi criado o AdvancedCache, uma interface que estende Cache e permite acessar detalhes específicos do infinispan como adicionar e remover interceptadores, gerenciadores de travas e etc. A interface Cache é compatível com a interface de mesmo nome da JSR-107, enquanto que AdvancedCache acrescenta o que é específico do infinispan.

\emph{CacheImpl} é a classe que implementa AdvancedCache (e portanto, Cache). Ela converte as chamadas das funções da interface em comandos representando as ações a serem executadas, contendo referências e informações necessárias para essa execução. Esses comandos são executados por diferentes tipos de processadores de comandos, cada um responsável por diferentes aspectos que um comando apresenta (como distribuição na rede ou persistência de dados em disco). Os processadores são dispostos em uma sequência pré-configurada, e a execução do comando é composta então pela atuação de cada um desses processadores, um após o outro, seguindo a sequência estabelecida. Esse esquema de execução é baseado em alguns padrões (\emph{design patterns}), como \emph{Command}, \emph{Visitor}, \emph{Chain of Responsibility} e \emph{Interceptor} (\cite{design_patterns}, \cite{posa}).

Por exemplo, a operação \emph{Cache.get(Object k)}, que permite recuperar a entrada associada à chave \emph{k}, é transformada no comando \emph{GetKeyValueCommand}. De acordo com a configuração e detalhes específicos de cada cache, a sequência de processadores pode ser ligeiramente diferente, mas os tipos mais representativos de processadores são:

\begin{description} 
	\item[DistributionInterceptor] - Provê funcionalidades básicas para que o cache opere de forma distribuída. Processadores mais específicos como \textbf{TxDistributionInterceptor} e \textbf{NonTxDistributionInterceptor} estendem a classe base e são usados de acordo com a configuração para obter melhor desempenho.
	\item[LockingInterceptor] - Gerencia a aquisição e liberação de travas em chaves ou grupos de chaves. Conforme a configuração, são utilizadas classes mais especializadas como \textbf{OptimisticLockingInterceptor} ou \textbf{PessimisticLockingInterceptor}.
	\item[TxInterceptor] - Responsável por tratar de aspectos transacionais, como registrar o cache como um participante em uma transação distribuída.
	\item[CallInterceptor] - Sempre posicionado como o último processador na sequência, é responsável por invocar a operação específica de cada comando.
\end{description}

Um componente muito importante na execução de um comando é InvocationContext, a interface principal da hierarquia ilustrada na figura \ref{fig:invocation_context}, e a escolha de uma ou outra implementação é determinada em tempo de execução de acordo com a configuração. InvocationContext contém informações como o endereço do nó de origem da execução e as chaves sobre as quais a execução obteve travas. AbstractInvocationContext provê a base necessária para a implementação dos contextos, implementando os métodos definidos em InvocationContext de maneira direta. NonTxInvocationContext é utilizado quando o cache não está configurado para utilizar transações, e SingleKeyNonTxInvocationContext é uma otimização para quando a operação envolve somente uma chave. TxInvocationContext permite acessar a transação associada à execução e pode ser de dois tipos: LocalTxInvocationContext ou RemoteTxInvocationContext. A implementação Local é utilizada para operações transacionais que foram iniciadas no mesmo nó que estiver executando a operação, e Remote é utilizada quando a operação tiver sido iniciada em um outro nó. 

\begin{figure}
  \centering
  \includegraphics[width=\textwidth]{invocation_context} 
  \caption{Hierarquia de InvocationContext}
  \label{fig:invocation_context} 
\end{figure}

\section{Minitransações no Infinispan}
\label{sec:mt_infinispan}
%O subsistema de transações do Infinispan permite agrupar operações em unidades lógicas de execução, oferecendo uma opção transacional para quem utiliza o cache. A seção \ref{sec:tx_infinispan} detalha o subsistema que gerencia e executa transações dentro do Infinispan. A seção seguinte, \ref{sec:suporte_mt_infinispan}, apresenta as modificações necessárias nesse subsistema para que o Infinispan permita a execução de minitransações.

%\subsection{O subsistema de transações do Infinispan}
%\label{sec:tx_infinispan}
O Infinispan pode ser configurado para agrupar ou não as operações em transações. Quando configurado para não agrupar, cada operação efetuada no cache é considerada isolada, sem relação com as outras operações. Nessa configuração, cada operação pertence a uma transação distinta, que é iniciada antes da operação ser executada e finalizada após o término da execução da operação.

Quando configurado para agrupar as operações, o Infinispan permite que o usuário defina as operações que formam uma transação, explicitamente iniciando e finalizando uma transação de modo a englobar as operações que precisam ser executadas como uma única operação lógica.

A abstração central do subsistema de transações é CacheTransaction, uma \emph{interface Java} \cite{java} que define os detalhes de uma transação no Infinispan. CacheTransaction é o topo de uma complexa estrutura projetada para atender a diferentes demandas transacionais e permitir a integração com \emph{JTA} (\emph{Java Transaction API} \cite{jta}) e \emph{X/Open XA} (\emph{Extended Architecture} \cite{xa}). Um resumo dessa estrutura é apresentado na figura \ref{fig:subsistema_transacoes}.

\begin{figure}
  \centering
  \includegraphics[width=\textwidth]{subsistema_transacoes} 
  \caption{Resumo do subsistema de transações}
  \label{fig:subsistema_transacoes} 
\end{figure}

LocalTransaction é utilizada na execução de transações iniciadas localmente e RemoteTransaction representa uma transação em execução em um nó A que foi iniciada em um outro nó B do agrupamento e que altera informações sob a responsabilidade de A. A classe LocalTransaction referencia uma Transaction do JTA. SyncLocalTransaction é utilizada por SynchronizationAdapter, que implementa a interface Synchronization definida pela JTA. LocalXATransaction é utilizada pelo TransactionXAAdapter, que implementa XAResource para integração com gerenciadores compatíveis com XOpen/XA. Tanto SynchronizationAdapter quando TransactionXAAdapter mapeiam chamadas do JTA e XOpen/XA, respectivamente, para operações de TransactionCoordinator, que centraliza a lógica para o controle de estado e execução das transações. O relacionamento entre essas classes pode ser visto na figura \ref{fig:transaction_coordinator}

\begin{figure}
  \centering
  \includegraphics[width=\textwidth]{transaction_coordinator} 
  \caption{TransactionCoordinator e seus adaptadores}
  \label{fig:transaction_coordinator} 
\end{figure}

GlobalTransaction representa um identificador de transação único em todo o agrupamento, para distinguir uma transação, independente do nó em que foi originada. Ela também é uma representação de alto-nível, sendo especializada por outras classes dependendendo da configuração do Infinispan. A figura \ref{fig:global_transaction} nos mostra de maneira simplificada essas classes. A DldGlobalTransaction implementa algoritmos para detecção de impasses (\emph{deadlocks}) na obtenção de travas para a execução das transações. Xid é uma interface que identifica uma transação no XOpen/XA.

\begin{figure}
  \centering
  \includegraphics[width=\textwidth]{global_transaction} 
  \caption{GlobalTransaction}
  \label{fig:global_transaction} 
\end{figure}

Os comandos que encapsulam operações diretamente relacionadas a uma transação são PrepareCommand, CommitCommand e RollbackCommand. PrepareCommand registra a transação relacionada na estrutura de dados do Infinispan que controla as transações (TransactionTable). CommitCommand e RollbackCommand marcam nessa mesma tabela que a transação relacionada foi finalizada. Outros comportamentos relacionados à esses comandos são implementados nos interceptadores TxInterceptor e TxDistributionInterceptor. TxInterceptor gerencia os comandos transacionais recebidos de outros nós, e TxDistributionInterceptor distribui comandos dentro da transação (como escrita, leitura, etc) para os nós responsáveis pelas chaves especificadas.

Na Listagem \ref{lst:exemplo_transaction} há um trecho de código que ilustra uma transação que utilizaremos para demonstrar como o Infinispan processa transações. Esse código está incompleto e simplificado por questões de clareza.

\begin{lstlisting}[caption={Transação convencional}, label=lst:exemplo_transaction]
cache.getAdvancedCache().getTransactionManager().begin();
cache.put("CHAVE 1", "VALOR 1");
cache.getAdvancedCache().getTransactionManager().commit();
\end{lstlisting}

A primeira linha instrui o gerenciador de transações (\emph{Transaction Manager}) do JTA a criar uma nova transação (\emph{javax.transaction.Transaction} \cite{jta}) e associá-la com a \emph{thread} de execução atual (\cite{ipc}). 

A segunda linha instrui o cache a inserir um novo elemento. Internamente, a classe CacheImpl irá criar os dois objetos necessários para a execução da operação. Um deles é PutKeyValueCommand, responsável por armazenar na chave especificada o valor fornecido. O outro objeto é LocalTxInvocationContext, que vai representar uma execução transacional iniciada no mesmo nó que executa o comando. 

Após criar o comando e o contexto de execução, o infinispan inicia o processamento do comando, oferecendo a cada interceptador configurado a oportunidade de aplicar sua lógica específica à execução do comando em questão. Os interceptadores mais relevantes na execução do comando de escrita são TxInterceptor, LockingInterceptor e EntryWrappingInterceptor.

TxInterceptor vai criar uma implementação de CacheTransaction e mapeá-la para a Transaction criada pela TransactionManager (associada à thread de execução). Dessa forma, a transação pode ser propagada para outros nós (uma vez que a Transaction do JTA não é propagada) e permite que vários nós executem operações em uma mesma transação. O tipo mais comum de CacheTransaction utilizado é o SyncLocalTransaction, que irá permitir que o TransactionManager notifique o infinispan que uma transação foi finalizada.

LockingInterceptor é responsável por efetuar a trava das chaves relacionadas ao comando. Existem duas implementações desse interceptador: OptimisticLockingInterceptor e PessimisticLockingInterceptor. Optimistic utiliza uma abordagem otimista no processo de travamento, postergando a obtenção da trava para o momento da efetivação da transação. Pessimistic tenta obter as travas no momento da execução do comando.

EntryWrappingInterceptor é responsável por obter as entradas do cache referentes às chaves especificadas no comando e disponibilizá-las no contexto de execução. Essas entradas são encapsuladas por uma classe, MVCCEntry, que permite o multiversionamento dos valores e garante as propriedades ACID da transação.

Por último, CallInterceptor irá executar o método \emph{perform} de PutKeyValueCommand, que por sua vez irá alterar o valor da entrada armazenada no contexto de execução disponibilizado por EntryWrappingInterceptor.

A terceira linha faz com que TransactionManager inicie o processo de efetivação da transação. O infinispan faz uso do mecanismo de notificação de eventos do JTA para ser avisado que a transação foi finalizada. Quando isso acontece, é criado um novo contexto de execução e um novo comando do tipo PrepareCommand. Esse comando representa a primera fase do 2PC, e é responsável por notificar os nós participantes da transação que a transação foi finalizada. 

Esse comando será processado pela mesma cadeia de interceptadores configurada, e os interceptadores mais relevantes para esse execução são TxInterceptor e TxDistributionInterceptor. TxInterceptor fica responsável por registrar como \textbf{preparada} a transação em questão, e TxDistributionInterceptor é o responsável por replicar o comando para os outros nós envolvidos na transação.

O próximo passo dependerá do resultado da execução de PrepareCommand. Se nenhum erro ocorrer, TransactionManager irá então solicitar a efetivação da transação. Caso contrário, a transação será cancelada. No caso de efetivação é criado um CommitCommand e no caso de cancelamento, um RollbackCommand. Os dois comandos resultam em marcar a transação como finalizada, mas CommitCommand faz com que EntryWrappingInterceptor efetive as alterações efetuadas nas entradas, disponibilizando-as para outras transações.

%\subsubsection{Suporte a minitransações}
%\label{sec:suporte_mt_infinispan}

%Esta seção descreve as alterações efetuadas no código do Infinispan para que esse pudesse suportar a execução de minitransações.

\begin{figure}
  \centering
  \includegraphics[width=\textwidth]{transaction_operations} 
  \caption{Estrutura de classes das minitransações}
  \label{fig:transaction_operations} 
\end{figure}

A primeira alteração efetuada para permitir a execução de minitransações foi a criação de uma estrutura para representar uma minitransação, ilustrada na figura \ref{fig:transaction_operations}. Minitransaction é a classe que agrupa as operações que podem ser efetuadas no contexto de uma minitransação. A interface MinitransactionOperation é a base que deve ser implementada por qualquer operação que faça parte de uma minitransação.

A operação mais simples é ReadOperation, que especifica a chave cujo valor associado deve ser retornado. ComparisonOperation vai efetuar uma comparação, designada por ComparisonType, entre um valor especificado pelo usuário e o valor associado à chave no cache. WriteOperation irá armazenar no cache o valor especificado e associá-lo à chave especificada. TransformationOperation é a operação mais flexível, pois permite que o usuário aplique uma função de transformação no valor associado à chave especificada. Essa função de transformação é uma implementação de TransformationCallback.

A listagem \ref{lst:exemplo_minitransaction} contém código utilizando minitransações com funcionalidade equivalente ao código da listagem \ref{lst:exemplo_transaction}, e apresenta os principais elementos presentes ao codificarmos utilizando minitransações.

\begin{lstlisting}[caption={Minitransação}, label=lst:exemplo_minitransaction]
Minitransaction minitransaction = new Minitransaction();
minitransaction.addWrite(new WriteOperation("CHAVE 1", "VALOR 1"));
MinitransactionExecution execution = cache.getAdvancedCache().execute(minitransaction);
\end{lstlisting}

O método \textbf{execute} de AdvancedCache inicia criando uma transação em TransactionManager. Esse passo é necessário pois a execução de minitransações é baseada no subsistema de transações do infinispan, e esse vai exigir a presença de uma transação no contexto de execução.

Como segundo passo, \textbf{execute} cria uma PrepareMinitransactionCommand, referenciando o objeto Minitransaction recebido como parâmetro. Esse comando percorre então a cadeia de interceptadores, sendo tratado em quase todos eles da mesma maneira que um PrepareCommand, com exceção de TxInterceptor.

O papel de TxInterceptor ao interceptar PrepareMinitransactionCommand é popular a tabela de transações com uma nova CacheTransaction associada à Transaction atual, e associar ao comando a GlobalTransaction que vai permitir que a transação seja identificada dentro do agrupamento, quando o comando for replicado para os outros nós envolvidos.

A lógica de execução da minitransação é implementada no método \textbf{perform} de PrepareMinitransactionCommand. O nó para o qual a minitransação foi submetida - aquele em que o método \textbf{execute} foi executado - será chamado aqui de coordenador, e os demais nós envolvidos - aqueles responsáveis por chaves envolvidas na minitransação - são chamados de participantes. Devido ao caráter não-centralizado do infinispan, qualquer minitransação pode ser submetida a qualquer nó do agrupamento, inclusive um nó que não seja responsável por nenhuma chave envolvida na minitransação. Uma chave está envolvida na minitransação se ela for referenciada por qualquer operação dessa minitransação.

O objeto Minitransaction que originou a execução é repassado para todos os nós envolvidos, mas cada nó executa somente as operações relacionadas às chaves sob sua responsabilidade. A replicação de dados que não serão usados não acarreta grandes problemas de performance, mas é um ajuste que pode ser feito facilmente no futuro.

A arquitetura do infinispan permite que tanto o código do coordenador quanto dos participantes seja centralizado no método \textbf{perform} do comando. Quando esse comando é executado como resultado da submissão da minitransação para o coordenador, o fluxo é simplesmente um encadeamento de chamadas de métodos dentro da mesma JVM, que culminam na execução de \textbf{perform} (o código completo dessa função foi disponibilizado na listagem \ref{lst:perform}) e na obtenção do resultado dessa execução, um MinitransactionExecution. Quando replicado para os participantes, esse comando é transmitido pela rede, reconstruído em cada participante e inserido no fluxo de execução de comandos, como uma chamada de método comum. O objeto retornado pelo método como resultado de sua execução percorre o caminho inverso, sendo enviado de cada participante de volta para o coordenador.

\begin{lstlisting}[caption={Função PrepareMinitransactionCommand.perform}, label=lst:perform]
@Override
public Object perform(InvocationContext ctx) throws Throwable {

  if( ctx == null ) {
    RemoteTransaction transaction = txTable.getRemoteTransaction(globalTx);

    if (transaction == null) {
      transaction = txTable.createRemoteTransaction(globalTx, null);
    }
         
    ctx = icc.createRemoteTxInvocationContext(transaction, getOrigin());
  }
  
  boolean originLocal = ctx.isOriginLocal();
      
  MinitransactionExecution execution = new MinitransactionExecution();
      
  boolean comparisonResult = true;

  processKeys();
      
  if(!localKeys.isEmpty()) {
    LockControlCommand lockControlCommand = cf.buildLockControlCommand(localKeys, flags, globalTx);
    lockControlCommand.setOrigin(getOrigin());
    invoker.invoke(ctx, lockControlCommand);

    for (ComparisonOperation comparison : minitransaction.getComparisons()) {
      if( localKeys.contains(comparison.getKey()) ) {
        KeyValueComparisonCommand comparisonCommand = cf.buildKeyValueComparisonCommand(comparison, EnumSet.noneOf(Flag.class));
        Object invoke = invoker.invoke(ctx, comparisonCommand);
        if (invoke != null && invoke instanceof Boolean) {
          if (!(comparisonResult = (Boolean) invoke)) {
            break;
          }
        }
      }
    }
  }

  if (!comparisonResult) {
    execution.markAsAborted();
  } else {
    for (ReadOperation read : minitransaction.getReads()) {
      if( localKeys.contains(read.getKey()) ) {
        GetKeyValueCommand getKeyValueCommand = cf.buildGetKeyValueCommand(read.getKey(),
        EnumSet.noneOf(Flag.class));

        Object invoke = invoker.invoke(ctx, getKeyValueCommand);
        execution.addReadKeyValue(read.getKey(), invoke);
      }
    }

    List<WriteCommand> modifications = new ArrayList<WriteCommand>();
    for (WriteOperation write : minitransaction.getWrites()) {
      if( localKeys.contains(write.getKey()) ) {
        PutKeyValueCommand putKeyValueCommand = cf.buildPutKeyValueCommand(write.getKey(), write.getValue(), -1,
               -1, EnumSet.noneOf(Flag.class));
        if(originLocal) {
          invoker.invoke(ctx, putKeyValueCommand);
        }
        else {
          modifications.add(putKeyValueCommand);
        }
      }
    }

    for (TransformationOperation transformation : minitransaction.getTransformations()) {
      if( localKeys.contains(transformation.getKey()) ) {
        TransformCommand transformCommand = cf.buildTransformCommand(transformation.getKey(), transformation.getCallback(), -1,
                -1, EnumSet.noneOf(Flag.class));
        if(originLocal) {
          invoker.invoke(ctx, transformCommand);
        }
        else {
          modifications.add(transformCommand);
        }
      }
    }
         
    if( originLocal ) {
      PrepareMinitransactionCommand remote = new PrepareMinitransactionCommand(cacheName, minitransaction, globalTx);
      remote.setOrigin(rm.getAddress());
      Collection<Address> affectedNodes = new HashSet<Address>(dm.getAffectedNodes(minitransaction.getAllKeys()));
      affectedNodes.remove(rm.getAddress());
      Map<Address, Response> responses = rm.invokeRemotely(affectedNodes, remote, true);
      for( Response response : responses.values() ) {
        if(response.isSuccessful()) {
          SuccessfulResponse sr = (SuccessfulResponse) response;
          MinitransactionExecution remoteExecution = (MinitransactionExecution) sr.getResponseValue();
          execution.mergeWith( remoteExecution );
        }
        else {
          execution.markAsAborted();
        }
        if(execution.isAborted()){
          break;
        }
      }
    }
    else {
      PrepareCommand prepareCommand = cf.buildPrepareCommand(globalTx, modifications, true);
      invoker.invoke(ctx, prepareCommand);
    }
  }

  return execution;
}
\end{lstlisting}

O primeiro passo na execução é obter acesso exclusivo às chaves envolvidas na transação utilizando o mecanismo de travas do infinispan. Um LockControlCommand é criado e executado na cadeia de interceptadores. Se não for possível travar uma ou mais chaves, ocorrerá um erro e a minitransação será cancelada.

Com as entradas referentes às chaves da minitransação travadas, são executadas todas as comparações referentes ao nó atual. Se alguma delas falhar, a minitransação como um todo deve ser cancelada. Para indicar isso, é utilizado o método \textbf{markAsAborted} de MinitransactionExecution. Se todas as comparações forem bem-sucedidas, ou se não houver nenhuma comparação para o nó atual, o fluxo de execução segue.

As operações de leitura são efetuadas em seguida. Para isso, são criados e executados comandos do tipo GetKeyValueCommand, um para cada chave especificada. O valor retornado pela execução de cada um desses comandos é registrado em MinitransactionExecution, com o método \textbf{addReadKeyValue}.

Após as leituras é a vez das operações de escrita, efetuadas com o comando PutKeyValueCommand. Esses comandos são enviados para a cadeia de interceptadores e segue o mesmo fluxo de execução já descrito.

O último tipo de operação a ser efetuado é a transformação, que é representada por TransformCommand e por sua implementação de TransformationCallback. Esse comando é semanticamente muito semelhante à PutKeyValueCommand no sentido em que ele atribui um valor a uma entrada. A diferença é que esse valor é uma função aplicada sobre o valor já existente na entrada. Essa função é representada pela interface TransformCallback e é implementada de acordo com a necessidade do usuário.

Para o nó participante, \textbf{perform} termina nesse ponto, retornando um MinitransactionExecution que será transmitido pela rede para o coordenador. O nó coordenador precisa agrupar todos os resultados obtidos dos participantes e combiná-los por meio do método \textbf{mergeWith} de MinitransactionExecution. Esse método vai agrupar em um só conjunto os resultados das leituras efetuadas e irá marcar esse resultado combinado como sendo cancelado caso algum dos resultados obtidos tenha sido cancelado.

Esse resultado combinado é retornado pelo coordenador e é utilizado pelo método \textbf{execute} para determinar se a minitransação deve ser efetivada ou não. Se \textbf{isAborted} for verdadeiro, a minitransação deve ser abortada e suas alterações devem ser desfeitas. Caso contrário, as alterações devem ser efetivadas e disponibilizadas para futuras transações. Esse processo de efetivação e cancelamento segue o fluxo normal de efetivação e cancelamento do infinispan, sem passar porém pela fase de preparação do 2PC.

\chapter{Conclusões}
\label{chap:conclusoes}

Embora tenha sido planejado para ser modificado, houve alguns pequenos problemas para alterar o infinispan para executar minitransações. Esses problemas e as soluções encontradas estão descritos na seção \ref{sec:problemas_solucoes}. Os resultados obtidos com esse trabalho foram disponibilizados para amplo acesso, e uma análise está disponível na seção \ref{sec:resultados}. Na seção \ref{sec:licoes_e_futuro} apresentamos lições aprendidas no desenvolvimento deste trabalho e identificamos pontos que podem ser melhorados, e possíveis extensões.

\section{Avaliação e resultados}
\label{cap:resultados}

Inicialmente foi pretendido executar os testes baseado na comparação de referências (\emph{benchmarks}), em que os sistemas são executados em um ambiente controlado e os resultados são comparados com valores de referência. O benchmark candidato foi o TPC-E \cite{tpce}, que simula a carga de trabalho em um sistema de processamento de transações de uma correta de valores. A escolha desse benchmark foi a princípio natural, pois ele foi criado pelo TPC (\emph{Transaction Processing Performance Council}, ou conselho de performance de processamento de transações), mas por fim não foi possível utilizá-lo. 

Um dos motivos é que os indicadores de performance desse benchmark são em sua maioria voltados para utilização dos do disco rígido, e nossa infraestrutura mantém todos os dados em memória. O segundo motivo foi a indisponibilidade de versões livres do TPC-E implementados em java. Foi feita uma tentativa de execução da implementação em C++, mas o tempo e o esforço de adequação para conseguir conectar à infraestrutura seria muito grande. Por fim, o TPC é um benchmark bem "pesado", exigindo muita infraestrutura de hardware.

Foram encontrados alguns outros benchmarks, mas nenhum com o peso e critérios do TPC, o que não conferiam a esses um caráter muito confiável. Por fim, foi encontrado o Radargun \cite{radargun}, um arcabouço para o desenvolvimento de benchmarks para caches distribuídos, desenvolvido pelo equipe do próprio infinspan. Infelizmente, o código do radargun estava muito atrelado ao formato de transações convencionais, e a dificuldade para modificá-lo foi semelhante à encontrada no TPC-E. Assim, ele também não pode ser utilizado.

Assim, foi definido então que a avaliação seria baseada em comparações entre transações convencionais e minitransações do próprio infinispan. Como a maior parte do código e estrutura é compartilhado por esses dois mecanismos, essa avaliação é consistente. Foi efetuada uma comparação quantitativa em relação ao tempo de execução e outra avaliação qualitativa em relação à complexidade do código. Os testes simulam dois cenários: a transferência de valores entre contas e um leilão.

No primeiro teste, transferência entre contas, dois parâmetros principais foram definidos: número de contas ($C$) e número de operadores ($O$). Cada conta é identificada por um número entre 1 e $C$, assim como cada operador é identificado por um número entre 1 e $O$. Cada conta recebe um valor inicial uniformemente distribuído no intervalo [1,6]. Cada operador é responsável por tentar efetuar um número de transferências igual a $C^2$, e em cada tentativa são escolhidas de forma aleatória as contas de origem, destino e o valor a ser transferido. Se a conta de origem possuir saldo suficiente, a transferência ocorrerá.

A listagem \ref{lst:operator_account} apresenta o trecho de código dos operadores que efetuam a transferência entre as contas. O operador do tipo TRANSACTION utiliza uma transação convencional, e MINITRANSACTION utiliza uma minitransação. O saldo das contas é armazenado no infinispan como um valor inteiro, na entrada referente à chave que identifica a conta. 

\begin{lstlisting}[caption={Operadores que executam as transferências}, label=lst:operator_account]
private enum Operator {

  TRANSACTION {

    @Override
    void transfer(Node node, long value, String accountToDebit, String accountToCredit) throws Exception {
      node.startTransaction();
      node.lock(accountToDebit, accountToCredit);
      Long fromValue = (Long) node.get(accountToDebit);
      Long toValue = (Long) node.get(accountToCredit);

      if (value <= fromValue) {
        Long newValueOfDebitAccount = fromValue - value;
        Long newValueOfCreditAccount = toValue + value;

        node.put(accountToDebit, newValueOfDebitAccount);
        node.put(accountToCredit, newValueOfCreditAccount);
        node.commitTransaction();
      } else {
        node.rollbackTransaction();
      }
    }

  },
  MINITRANSACTION {

    @Override
    void transfer(Node node, long value, String accountToDebit, String accountToCredit) {
      Minitransaction minitransaction = new Minitransaction();
      minitransaction.addComparison(ComparisonType.GE.create(accountToDebit, value));
      minitransaction.addTransformation(new TransformationOperation(accountToDebit, new AddValue(-value)));
      minitransaction.addTransformation(new TransformationOperation(accountToCredit, new AddValue(value)));
      node.execute(minitransaction);
    }

  };

  abstract void transfer(Node node, long value, String accountToDebit, String accountToCredit) throws Exception;

}
\end{lstlisting}

O segundo teste, leilão, utiliza dois parâmetros também: o número de leilões ($L$) e o número de participantes ($P$). Cada leilão é identificado com um número sequencial entre 1 e $L$, e cada participante é identificado por um número sequencial entre 1 e $P$. O infinispan é utilizado para armazenar o valor do lance vencedor da última rodada de cada leilão e o identificador do participante que efetuou esse lance vencedor.

Cada leilão recebe um valor inicial entre 1 e 6, e cada participante recebe um saldo inicial (o valor de sua carteira, \emph{wallet}) que garante que esse participante consiga efetuar no mínimo um lance. Os participantes tentam efetuar um lance de cada vez, em cada um dos leilões, em sequência, enquanto possuírem saldo em suas carteiras. Um participante não irá tentar um lance se ele já deu o lance mais alto na rodada anterior. A listagem \ref{lst:bidder_auction} apresenta o código dos participantes utilizando um transação convencional (TRANSACTION) e uma minitransação (MINITRANSACTION).  

\begin{lstlisting}[caption={Participante que efetuam os lances}, label=lst:bidder_auction]
private enum Bidder {
  TRANSACTION{

    @Override
    int bid(Node node, int id, Wallet wallet, Auction currentAuction) throws Exception {
      int count = 0;
      node.startTransaction();
      node.lock(currentAuction.code, currentAuction.code + "_WINNER");
      Integer lastBid = (Integer) node.get(currentAuction.code);
      Integer currentWinner = (Integer) node.get(currentAuction.code + "_WINNER");
      if( currentWinner != null && currentWinner == id ) {
        count++;
        node.rollbackTransaction();
      }
      else if( wallet.value <= lastBid ) {
        count++;
        node.rollbackTransaction();
      }
      else {
        int currBid = Math.min(lastBid + 1, wallet.value);
        if( currBid <= lastBid ) {
          node.rollbackTransaction();
        }
        else {
          node.put(currentAuction.code, currBid);
          node.put(currentAuction.code + "_WINNER", id);
                     
          wallet.value -= currBid;
                     
          node.commitTransaction();
        }
      }
      return count;
    } 
  },
  MINITRANSACTION{

    @Override
    int bid(Node node, int id, Wallet wallet, Auction currentAuction) throws Exception {
      int count = 0;
      Minitransaction minitransaction = new Minitransaction();
            
      minitransaction.addComparison(ComparisonType.NE.create(currentAuction.code + "_WINNER", id));
      minitransaction.addComparison(ComparisonType.LT.create(currentAuction.code, wallet));
      minitransaction.addWrite(new WriteOperation(currentAuction.code + "_WINNER", id));
      minitransaction.addTransformation(new TransformationOperation(currentAuction.code, new PlusOne()));
      minitransaction.addRead(new ReadOperation(currentAuction.code));
            
      MinitransactionExecution execution = node.execute(minitransaction);
      if( execution.isAborted() ) {
        count++;
      }
      else {
        wallet.value -= (Integer)execution.get(currentAuction.code) + 1;
      }
            
      return count;
    }
         
  };
      
  abstract int bid(Node node, int id, Wallet wallet, Auction currentAuction ) throws Exception;
}
\end{lstlisting}

Os testes foram executados utilizando o sistema operacional Ubuntu, versão 12.04, com kernel versão 3.5.0-34-generic, utilizado um computador com processador Intel\textregistered{} Core\texttrademark{} i5 CPU, modelo 480, com 4 núcleos de 2.67GHz e com 6 GB de memória RAM.

As tabelas em \ref{tab:tempos_account} apresentam os tempos de execução de diversas configurações do teste que simula as transferências entre contas, quando utilizando transações e minitransações. De maneira semelhante, as tabelas em  \ref{tab:tempos_auction} apresentam os tempos do teste que simula os participantes de um leilão. Os valores estão em segundos, e são médias calculadas dos valores reais de medições obtidas das execuções efetuadas nos ambientes descritos acima.

%Como pode ser notado nas tabelas, os tempos de execução das minitransações se mostraram muito superiores aos tempos de execução das transações convencionais. Esse resultado foi contra a intuição inicial de que as minitransações poderiam ocasionar uma melhora no desempenho das aplicações. Isso deve-se às otimizações que o infinispan faz ao executar as transações. 

%A principal dessas otimizações, que demonstrou ser a mais relevante para o bom desempenho das transações convencionais, é relacionada à escrita de dados. Ao executar um comando de escrita em um nó A, como PutKeyValueCommand, cuja chave está sob a responsabilidade de um outro nó B, o infinispan não irá efetuar a escrita no nó remoto. O comando será executado localmente, e somente no momento da finalização da transação é que esse comando será enviado para o nó B, dentro de PrepareCommand.

%Todos os comandos de escrita são agrupados e enviados de uma só vez em um PrepareCommand, de modo semelhante ao que acontece com as minitransações. A diferença é que ao executar o PrepareCommand no nó remoto, os comandos de escrita agrupados dentro do prepare são executados de uma vez também, aproveitando o fluxo de execução do PrepareCommand. Enquanto na execução da minitransação cada comando de escrita gera um novo PutKeyValueCommand, e cada um desses comandos é executado e processado por toda a cadeia de interceptadores configurado, no caso do PrepareCommand, não há a criação desses novos comandos de escrita, e a cadeia de interceptadores é percorrida somente uma vez.

%Os resultados obtidos não foram satisfatórios mas, como será apresentado na seção \ref{sec:licoes_e_futuro} a seguir, há possibilidade de alterações para melhorar o desempenho do sistema em relação ao desempenho apresentado por transações convencionais. De certa forma, analisando por um ponto de vista quantitativo, este trabalho não atingiu seus objetivos.

Sob uma ótica qualitativa, porém, acreditamos que o trabalho tenha tido êxito. Se compararmos o código das aplicações apresentadas nas listagens anteriores, vemos que os trechos que fazem uso de minitransações são menores e mais claros. É evidente que um menor número de linhas de código não se traduza automaticamente em qualidade mas, nos cenários em que pode ser utilizada, uma minitransação permite expressar de forma mais concisa a intenção da transação. *** TODO referencia ao livro de analise de complexidade

Por exemplo, nas linhas 12-21 da listagem \ref{lst:operator_account} vemos que o código cliente fica a cargo de cancelar a transação caso a comparação de valores não seja bem sucedida. A intenção da transação fica perdida em meio aos mecanismos que o sistema de transações oferece para utilizá-las. 

Nas minitransações, essa intenção fica clara e não espalhada pelo código. Os aspectos semânticos ficam bem definidos no código: basta verificar as comparações que a minitransação possui para verificar em quais cenários ela será efetivada ou cancelada. Com o uso de transações convencionais, esse aspecto semântico é mais difícil de ser diretamente detectado, exigindo uma análise mais cuidadosa.

Em concordância com uma abordagem de código limpo e claro como uma ferramenta e um meio de desenvolver sistemas de qualidade (\cite{clean_code}, \cite{xp}, \cite{refactoring}), principalmente na área de sistemas distribuídos, onde há um número enorme de cenários não-triviais a serem tratados, a possibilidade de utilizar uma primitiva que traduza claramente a semântica de uma transação que pode envolver uma grande quantidade de máquinas é de grande valor.

\section{Problemas e soluções}
\label{sec:problemas_solucoes}

Inicialmente, foi desenvolvida uma infraestrutura nova, sem utilizar nenhum código como base, em que o processamento de minitransações estava diretamente embutido no sistema. Essa infraestrutura armazena os dados em memória e oferece uma interface de acesso muito parecida à do infinispan. Embora essa primeira infraestrutura desenvolvida funcione e execute minitransações, foram encontrados alguns empecilhos para avaliá-la.

Em primeiro lugar, não foi encontrado nenhum outro sistema que oferecesse essa funcionalidade de execução de minitransações. Não há sentido em avaliar a infraestrutura isoladamente, pois não há nenhum parâmetro de comparação. A avaliação isolada foi feita mas com caráter funcional, para garantir que a infraestrutura estava de acordo com a especificação proposta e que era possível utilizá-la.

A avaliação pretendida era a comparação dos resultados de performance apresentados pela infraestrutura com outros resultados conhecidos, uma vez que um objetivo indireto desse trabalho é demonstrar a efetividade de minitransações como uma alternativa viável para o desenvolvimento de aplicações distribuídas. Porém, essa análise se mostrou mais complexa do que o esperado, pois os outros sistemas disponíveis com funcionalidades semelhantes já estavam consolidados e testados em ambientes de produção de alta-carga, em alguns casos com anos acumulados em melhorias de performance e desempenho.

Surgiu então a idéia de modificar um sistema já existente, que tivesse funcionalidades semelhantes, de forma que a diferença fosse mínima na implementação dos cenários testados. Após a avaliação de alguns candidatos foi escolhido o Infinispan, pois apresentava a maioria das características desejadas para a infraestrutura e era desenvolvido em Java, linguagem com a qual o autor deste trabalho possui maior experiência.

Iniciou-se um novo esforço de aprendizagem, pois o Infinispan é um sistema complexo, com muitas funcionalidade e altamente configurável. Seu código é bem estruturado e faz uso de diversos padrões, convenções e boas práticas utilizadas no desenvolvimento de sistemas distribuídos, mas mesmo assim não é de nenhuma forma um código simples. Foram necessárias diversas execuções, novas linhas de log e muitas sessões de debug para que fossem identificados os pontos que precisavam ser alterados. 

Ao estender o infinispan, nossa infraestrutura herdou toda sua funcionalidade, como a replicação e distribuição de dados e capacidade de armazenar os dados em diversas formas de armazenagem, como discos ou bancos de dados. Toda a camada de comunição intra-nós e entre a infraestrutura e os clientes também foi reaproveitada. De certa forma, o ponto principal do trabalho passou a ser permitir que o infinispan executasse minitransações, utilizando seus componentes. Isso, porém, não foi tão simples como esperado.

O infinispan pode atuar tanto no modo transacional quanto não-transacional. Porém, o termo "não-transacional" pode dar a impressão de que não há transações envolvidas, o que não é verdade. O deixa de existir é a transação do JTA e a possibilidade de agrupar operações em uma grande operação lógica, demarcada pela usuário. No modo não-transacional, cada operação individual é envolvida por uma transação, criada antes logo no início da execução do comando e finalizada após o fim de sua execução.

Dessa forma, o conceito de transação permeia particamente todo o infinispan, mesmo em trechos que seriam "não-transacionais". Isso dificultou a inclusão de suporte a minitransações. Por exemplo, não foi possível fazer com que PrepareMinitransactionCommand fosse uma subclasse de PrepareCommand. Inicialmente havia sido codificado dessa forma, mas havia muitos pontos em que PrepareCommand era tratado e a maioria desses pontos não fazia sentido para uma minitransação.

Um outro problema é que o Infinispan faz uma série de otimizações em relação a transações. Uma delas é tratar uma transação distribuída como sendo de somente uma fase, ou seja, em alguns cenários específicos, que dependem da configuração especificada, o infinispan efetua a efetivação ou cancelamento quando processa PrepareCommand. A configuração necessária para habilitar as minitransações resultavam necessariamente nesses cenários, o que atrapalhava a execução das minitransações.

Foram testadas algumas alternativas para a implementação, mas a solução final acabou sendo a mais simples, apresentada no capítulo sobre a implementação da infraestrutura, na seção \ref{sec:suporte_mt_infinispan}. Com essa solução a execução das minitransações ficou desvinculada da maior parte da execução de transações convencionais no infinispan.

O último problema, que remete ao primeiro citado no início dessa sessão foi a escolha de uma ferramenta que possibilitasse a correta medição de parâmetros para uma análise de performance consistente. Devido à diferença estrutural dos tratamentos no código entre transações e minitransações, instrumentar o código para efetuar essas medições não seria muito efetivo.

\section{Lições aprendidas e trabalhos futuros}
\label{sec:licoes_e_futuro}

O sistema desenvolvido inicialmente não utilizou nenhum outro código como base. Por esse motivo, foi necessário o desenvolvimento de funcionalidades em áreas diversas, algumas das quais o autor não possuía muita experiência.

A primeira dessas funcionalidades foi a criação de um protocolo para a comunicação e o desenvolvimento de um interpretador para esse protocolo. Mesmo sendo um protocolo simples (esse protocolo foi descrito na versão original do texto de qualificação deste trabalho) o desenvolvimento de um interpretador não é trivial, e exigiu um estudo mais aprofundado das técnicas de construção de interpretadores (disponíveis em \cite{compilers}).

A implementação do gerenciamento e comunicação de rede também não foi simples, pois a comunicação poderia ocorrer tanto entre os nós do sistema quanto entre aplicações clientes e o sistema. Projetado para ser acessível a qualquer aplicação com acesso à uma rede de computador, foi escrito código para lidar direto com a camada \emph{TCP} da rede, utilizando as funcionalidades de entrada e saída não-bloqueantes da plataforma java (\cite{nio}), algo que o autor não havia utilizado de forma consistente anteriormente.

Esse primeiro sistema, embora tenha chegado a um estágio funcional, ficou longe de estar completo, e as funcionalidades descritas acima, vitais para a execução do sistema, também eram incompletas e sujeitas a falhas muitas vezes grosseiras. A principal lição aprendida com esse sistema foi buscar e tentar reaproveitar algo que funcione e que possa ser modificado para nossas necessidades, mesmo que tenhamos que nos desfazer de longas horas de trabalho já efetuado.

O uso do infinispan como base exigiu um novo esforço de aprendizado e descoberta. Todas as funcionalidades disponíveis no primeiro sistema, de forma bem mais completa, estavam presentes no infinispan, além de um grande número de outras que apesar de importantes, não seriam desenvolvidas por falta de tempo.

Estudar e entender a base de código do infinispan agregou muito em termos de como desenvolver um sistema totalmente distribuído, capaz de executar em diversos cenários, muitos dos quais não haviam sequer sido cogitados na proposta deste trabalho. Foi importante ver também que o próprio infinispan foi construído com base em outras sólidas bases, como o JGroups, e como muitos dos problemas enfrentados no desenvolvimento do primeiro sistema não causariam impacto se esse biblioteca tivesse sido utilizada.

Como descrito anteriormente, uma pendência deste trabalho é a otimização da execução da minitransação para melhorar seu desempenho em relação ao tempo de execução das transações convencionais. Poderia ser criado somente um comando para executar todas as escritas de uma vez, como é feito no caso do PrepareCommand, evitando assim que a cadeia de interceptadores seja percorrida repetidamente.

Uma segunda oportunidade de desenvolvimento é a validação e execução dos testes em um ambiente altamente distribuído. Conforme descrito na descrição do infinispan e baseado em discussões dos desenvolvedore do infinispan, foi reportado a utilização de agrupamentos do infinispan contendo 400 máquinas, mas as configurações para esses agrupamentos não foram divulgadas. 

De forma mais realista, a documentação do infinispan descreve como configurar e otimizar para agrupamentos de até 128 máquinas. Executar e analisar o comportamento das minitransações, uma vez que seus problemas de performance sejam corrigidos, em um ambiente com essas configurações seria muito interessante. 

Por fim, a separação de uma definição de minitransação de suas implementações parece uma proposta promissora, nos moldes do que acontece com as transações convencionais e o JTA. Como visto na seção \ref{sec:resultados}, o uso de uma minitransação permite uma representação mais direta das intenções da transação, o que pode torná-las uma ferramenta para auxiliar no desenvolvimento de um código mais claro e coeso, independente do sistema ser distribuído ou não.

Uma outra opção é a implementação de um adaptador de minitransações para sistemas transacionais já existentes. Por exemplo, esse adaptador poderia oferecer um mecanismo de execução de minitransações que fosse traduzido em tempo de execução para a linguagem do sistema sendo adaptado. Assim seria possível executar minitransações em bancos de dados ou filas de mensagens.

% cabeçalho para os apêndices
%\newpage
%\renewcommand{\chaptermark}[1]{\markboth{\MakeUppercase{\appendixname\ \thechapter}} {\MakeUppercase{#1}} }
%\fancyhead[RE,LO]{}
%\appendix
%\chapter{Códigos}

%Esse apêndice apresenta algumas listagens mais completas de códigos e exemplos de utilização do infinispan.

%\label{apx:codigo}

% ---------------------------------------------------------------------------- %
\backmatter \singlespacing   % espaçamento simples
\bibliographystyle{alpha-ime}% citação bibliográfica alpha
\bibliography{bibliografia}  % associado ao arquivo: 'bibliografia.bib'

\end{document}
